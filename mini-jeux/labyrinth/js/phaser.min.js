(function (b, c) {
    if (typeof define === "function" && define.amd) {
        define(c)
    } else {
        if (typeof exports === "object") {
            module.exports = c()
        } else {
            b.Phaser = c()
        }
    }
}(this, function (c) {
    var g = g || {};
    var d = d || {
            VERSION: "1.1.2",
            DEV_VERSION: "1.1.2",
            GAMES: [],
            AUTO: 0,
            CANVAS: 1,
            WEBGL: 2,
            SPRITE: 0,
            BUTTON: 1,
            BULLET: 2,
            GRAPHICS: 3,
            TEXT: 4,
            TILESPRITE: 5,
            BITMAPTEXT: 6,
            GROUP: 7,
            RENDERTEXTURE: 8,
            TILEMAP: 9,
            TILEMAPLAYER: 10,
            EMITTER: 11,
            NONE: 0,
            LEFT: 1,
            RIGHT: 2,
            UP: 3,
            DOWN: 4
        };
    g.InteractionManager = function (b) {
    };
    d.Utils = {
        shuffle: function (l) {
            for (var k = l.length - 1; k > 0; k--) {
                var h = Math.floor(Math.random() * (k + 1));
                var b = l[k];
                l[k] = l[h];
                l[h] = b
            }
            return l
        }, pad: function (l, b, k, h) {
            if (typeof(b) == "undefined") {
                var b = 0
            }
            if (typeof(k) == "undefined") {
                var k = " "
            }
            if (typeof(h) == "undefined") {
                var h = 3
            }
            if (b + 1 >= l.length) {
                switch (h) {
                    case 1:
                        l = Array(b + 1 - l.length).join(k) + l;
                        break;
                    case 3:
                        var i = Math.ceil((padlen = b - l.length) / 2);
                        var j = padlen - i;
                        l = Array(j + 1).join(k) + l + Array(i + 1).join(k);
                        break;
                    default:
                        l = l + Array(b + 1 - l.length).join(k);
                        break
                }
            }
            return l
        }, isPlainObject: function (h) {
            if (typeof(h) !== "object" || h.nodeType || h === h.window) {
                return false
            }
            try {
                if (h.constructor && !hasOwn.call(h.constructor.prototype, "isPrototypeOf")) {
                    return false
                }
            } catch (b) {
                return false
            }
            return true
        }, extend: function () {
            var q, j, b, h, n, o, m = arguments[0] || {}, l = 1, k = arguments.length, p = false;
            if (typeof m === "boolean") {
                p = m;
                m = arguments[1] || {};
                l = 2
            }
            if (k === l) {
                m = this;
                --l
            }
            for (; l < k; l++) {
                if ((q = arguments[l]) != null) {
                    for (j in q) {
                        b = m[j];
                        h = q[j];
                        if (m === h) {
                            continue
                        }
                        if (p && h && (d.Utils.isPlainObject(h) || (n = Array.isArray(h)))) {
                            if (n) {
                                n = false;
                                o = b && Array.isArray(b) ? b : []
                            } else {
                                o = b && d.Utils.isPlainObject(b) ? b : {}
                            }
                            m[j] = d.Utils.extend(p, o, h)
                        } else {
                            if (h !== undefined) {
                                m[j] = h
                            }
                        }
                    }
                }
            }
            return m
        }
    };
    function e(b) {
        return [(b >> 16 & 255) / 255, (b >> 8 & 255) / 255, (b & 255) / 255]
    }

    if (typeof Function.prototype.bind != "function") {
        Function.prototype.bind = (function () {
            var b = Array.prototype.slice;
            return function (h) {
                var k = this, l = b.call(arguments, 1);
                if (typeof k != "function") {
                    throw new TypeError()
                }
                function i() {
                    var m = l.concat(b.call(arguments));
                    k.apply(this instanceof i ? this : h, m)
                }

                i.prototype = (function j(m) {
                    m && (j.prototype = m);
                    if (!(this instanceof j)) {
                        return new j
                    }
                })(k.prototype);
                return i
            }
        })()
    }
    function f() {
        g.Matrix = (typeof Float32Array !== "undefined") ? Float32Array : Array;
        return g.Matrix
    }

    f();
    g.mat3 = {};
    g.mat3.create = function () {
        var b = new g.Matrix(9);
        b[0] = 1;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        b[4] = 1;
        b[5] = 0;
        b[6] = 0;
        b[7] = 0;
        b[8] = 1;
        return b
    };
    g.mat3.identity = function (b) {
        b[0] = 1;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        b[4] = 1;
        b[5] = 0;
        b[6] = 0;
        b[7] = 0;
        b[8] = 1;
        return b
    };
    g.mat4 = {};
    g.mat4.create = function () {
        var b = new g.Matrix(16);
        b[0] = 1;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        b[4] = 0;
        b[5] = 1;
        b[6] = 0;
        b[7] = 0;
        b[8] = 0;
        b[9] = 0;
        b[10] = 1;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return b
    };
    g.mat3.multiply = function (v, m, n) {
        if (!n) {
            n = v
        }
        var C = v[0], B = v[1], A = v[2], l = v[3], k = v[4], j = v[5], t = v[6], s = v[7], r = v[8], q = m[0], p = m[1], o = m[2], z = m[3], w = m[4], u = m[5], i = m[6], h = m[7], b = m[8];
        n[0] = q * C + p * l + o * t;
        n[1] = q * B + p * k + o * s;
        n[2] = q * A + p * j + o * r;
        n[3] = z * C + w * l + u * t;
        n[4] = z * B + w * k + u * s;
        n[5] = z * A + w * j + u * r;
        n[6] = i * C + h * l + b * t;
        n[7] = i * B + h * k + b * s;
        n[8] = i * A + h * j + b * r;
        return n
    };
    g.mat3.clone = function (h) {
        var b = new g.Matrix(9);
        b[0] = h[0];
        b[1] = h[1];
        b[2] = h[2];
        b[3] = h[3];
        b[4] = h[4];
        b[5] = h[5];
        b[6] = h[6];
        b[7] = h[7];
        b[8] = h[8];
        return b
    };
    g.mat3.transpose = function (i, h) {
        if (!h || i === h) {
            var k = i[1], j = i[2], b = i[5];
            i[1] = i[3];
            i[2] = i[6];
            i[3] = k;
            i[5] = i[7];
            i[6] = j;
            i[7] = b;
            return i
        }
        h[0] = i[0];
        h[1] = i[3];
        h[2] = i[6];
        h[3] = i[1];
        h[4] = i[4];
        h[5] = i[7];
        h[6] = i[2];
        h[7] = i[5];
        h[8] = i[8];
        return h
    };
    g.mat3.toMat4 = function (h, b) {
        if (!b) {
            b = g.mat4.create()
        }
        b[15] = 1;
        b[14] = 0;
        b[13] = 0;
        b[12] = 0;
        b[11] = 0;
        b[10] = h[8];
        b[9] = h[7];
        b[8] = h[6];
        b[7] = 0;
        b[6] = h[5];
        b[5] = h[4];
        b[4] = h[3];
        b[3] = 0;
        b[2] = h[2];
        b[1] = h[1];
        b[0] = h[0];
        return b
    };
    g.mat4.create = function () {
        var b = new g.Matrix(16);
        b[0] = 1;
        b[1] = 0;
        b[2] = 0;
        b[3] = 0;
        b[4] = 0;
        b[5] = 1;
        b[6] = 0;
        b[7] = 0;
        b[8] = 0;
        b[9] = 0;
        b[10] = 1;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return b
    };
    g.mat4.transpose = function (j, i) {
        if (!i || j === i) {
            var n = j[1], l = j[2], k = j[3], b = j[6], m = j[7], h = j[11];
            j[1] = j[4];
            j[2] = j[8];
            j[3] = j[12];
            j[4] = n;
            j[6] = j[9];
            j[7] = j[13];
            j[8] = l;
            j[9] = b;
            j[11] = j[14];
            j[12] = k;
            j[13] = m;
            j[14] = h;
            return j
        }
        i[0] = j[0];
        i[1] = j[4];
        i[2] = j[8];
        i[3] = j[12];
        i[4] = j[1];
        i[5] = j[5];
        i[6] = j[9];
        i[7] = j[13];
        i[8] = j[2];
        i[9] = j[6];
        i[10] = j[10];
        i[11] = j[14];
        i[12] = j[3];
        i[13] = j[7];
        i[14] = j[11];
        i[15] = j[15];
        return i
    };
    g.mat4.multiply = function (u, n, p) {
        if (!p) {
            p = u
        }
        var C = u[0], B = u[1], z = u[2], v = u[3];
        var m = u[4], k = u[5], i = u[6], b = u[7];
        var t = u[8], s = u[9], r = u[10], q = u[11];
        var E = u[12], D = u[13], A = u[14], w = u[15];
        var o = n[0], l = n[1], j = n[2], h = n[3];
        p[0] = o * C + l * m + j * t + h * E;
        p[1] = o * B + l * k + j * s + h * D;
        p[2] = o * z + l * i + j * r + h * A;
        p[3] = o * v + l * b + j * q + h * w;
        o = n[4];
        l = n[5];
        j = n[6];
        h = n[7];
        p[4] = o * C + l * m + j * t + h * E;
        p[5] = o * B + l * k + j * s + h * D;
        p[6] = o * z + l * i + j * r + h * A;
        p[7] = o * v + l * b + j * q + h * w;
        o = n[8];
        l = n[9];
        j = n[10];
        h = n[11];
        p[8] = o * C + l * m + j * t + h * E;
        p[9] = o * B + l * k + j * s + h * D;
        p[10] = o * z + l * i + j * r + h * A;
        p[11] = o * v + l * b + j * q + h * w;
        o = n[12];
        l = n[13];
        j = n[14];
        h = n[15];
        p[12] = o * C + l * m + j * t + h * E;
        p[13] = o * B + l * k + j * s + h * D;
        p[14] = o * z + l * i + j * r + h * A;
        p[15] = o * v + l * b + j * q + h * w;
        return p
    };
    g.Point = function (b, h) {
        this.x = b || 0;
        this.y = h || 0
    };
    g.Point.prototype.clone = function () {
        return new g.Point(this.x, this.y)
    };
    g.Point.prototype.constructor = g.Point;
    g.Rectangle = function (h, j, i, b) {
        this.x = h || 0;
        this.y = j || 0;
        this.width = i || 0;
        this.height = b || 0
    };
    g.Rectangle.prototype.clone = function () {
        return new g.Rectangle(this.x, this.y, this.width, this.height)
    };
    g.Rectangle.prototype.contains = function (b, j) {
        if (this.width <= 0 || this.height <= 0) {
            return false
        }
        var h = this.x;
        if (b >= h && b <= h + this.width) {
            var i = this.y;
            if (j >= i && j <= i + this.height) {
                return true
            }
        }
        return false
    };
    g.Rectangle.prototype.constructor = g.Rectangle;
    g.DisplayObject = function () {
        this.last = this;
        this.first = this;
        this.position = new g.Point();
        this.scale = new g.Point(1, 1);
        this.pivot = new g.Point(0, 0);
        this.rotation = 0;
        this.alpha = 1;
        this.visible = true;
        this.hitArea = null;
        this.buttonMode = false;
        this.renderable = false;
        this.parent = null;
        this.stage = null;
        this.worldAlpha = 1;
        this._interactive = false;
        this.worldTransform = g.mat3.create();
        this.localTransform = g.mat3.create();
        this.color = [];
        this.dynamic = true;
        this._sr = 0;
        this._cr = 1
    };
    g.DisplayObject.prototype.constructor = g.DisplayObject;
    g.DisplayObject.prototype.setInteractive = function (b) {
        this.interactive = b
    };
    Object.defineProperty(g.DisplayObject.prototype, "interactive", {
        get: function () {
            return this._interactive
        }, set: function (b) {
            this._interactive = b;
            if (this.stage) {
                this.stage.dirty = true
            }
        }
    });
    Object.defineProperty(g.DisplayObject.prototype, "mask", {
        get: function () {
            return this._mask
        }, set: function (b) {
            this._mask = b;
            if (b) {
                this.addFilter(b)
            } else {
                this.removeFilter()
            }
        }
    });
    g.DisplayObject.prototype.addFilter = function (o) {
        if (this.filter) {
            return
        }
        this.filter = true;
        var b = new g.FilterBlock();
        var j = new g.FilterBlock();
        b.mask = o;
        j.mask = o;
        b.first = b.last = this;
        j.first = j.last = this;
        b.open = true;
        var i = b;
        var k = b;
        var n;
        var m;
        m = this.first._iPrev;
        if (m) {
            n = m._iNext;
            i._iPrev = m;
            m._iNext = i
        } else {
            n = this
        }
        if (n) {
            n._iPrev = k;
            k._iNext = n
        }
        var i = j;
        var k = j;
        var n = null;
        var m = null;
        m = this.last;
        n = m._iNext;
        if (n) {
            n._iPrev = k;
            k._iNext = n
        }
        i._iPrev = m;
        m._iNext = i;
        var h = this;
        var l = this.last;
        while (h) {
            if (h.last == l) {
                h.last = j
            }
            h = h.parent
        }
        this.first = b;
        if (this.__renderGroup) {
            this.__renderGroup.addFilterBlocks(b, j)
        }
        o.renderable = false
    };
    g.DisplayObject.prototype.removeFilter = function () {
        if (!this.filter) {
            return
        }
        this.filter = false;
        var i = this.first;
        var l = i._iNext;
        var m = i._iPrev;
        if (l) {
            l._iPrev = m
        }
        if (m) {
            m._iNext = l
        }
        this.first = i._iNext;
        var j = this.last;
        var l = j._iNext;
        var m = j._iPrev;
        if (l) {
            l._iPrev = m
        }
        m._iNext = l;
        var k = j._iPrev;
        var h = this;
        while (h.last == j) {
            h.last = k;
            h = h.parent;
            if (!h) {
                break
            }
        }
        var b = i.mask;
        b.renderable = true;
        if (this.__renderGroup) {
            this.__renderGroup.removeFilterBlocks(i, j)
        }
    };
    g.DisplayObject.prototype.updateTransform = function () {
        if (this.rotation !== this.rotationCache) {
            this.rotationCache = this.rotation;
            this._sr = Math.sin(this.rotation);
            this._cr = Math.cos(this.rotation)
        }
        var w = this.localTransform;
        var k = this.parent.worldTransform;
        var b = this.worldTransform;
        w[0] = this._cr * this.scale.x;
        w[1] = -this._sr * this.scale.y;
        w[3] = this._sr * this.scale.x;
        w[4] = this._cr * this.scale.y;
        var s = this.pivot.x;
        var r = this.pivot.y;
        var n = w[0], m = w[1], l = this.position.x - w[0] * s - r * w[1], v = w[3], u = w[4], t = this.position.y - w[4] * r - s * w[3], q = k[0], p = k[1], o = k[2], j = k[3], i = k[4], h = k[5];
        w[2] = l;
        w[5] = t;
        b[0] = q * n + p * v;
        b[1] = q * m + p * u;
        b[2] = q * l + p * t + o;
        b[3] = j * n + i * v;
        b[4] = j * m + i * u;
        b[5] = j * l + i * t + h;
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this.vcount = g.visibleCount
    };
    g.visibleCount = 0;
    g.DisplayObjectContainer = function () {
        g.DisplayObject.call(this);
        this.children = []
    };
    g.DisplayObjectContainer.prototype = Object.create(g.DisplayObject.prototype);
    g.DisplayObjectContainer.prototype.constructor = g.DisplayObjectContainer;
    g.DisplayObjectContainer.prototype.addChild = function (n) {
        if (n.parent != undefined) {
            n.parent.removeChild(n)
        }
        n.parent = this;
        this.children.push(n);
        if (this.stage) {
            var k = n;
            do {
                if (k.interactive) {
                    this.stage.dirty = true
                }
                k.stage = this.stage;
                k = k._iNext
            } while (k)
        }
        var j = n.first;
        var i = n.last;
        var l;
        var m;
        if (this.filter) {
            m = this.last._iPrev
        } else {
            m = this.last
        }
        l = m._iNext;
        var h = this;
        var b = m;
        while (h) {
            if (h.last == b) {
                h.last = n.last
            }
            h = h.parent
        }
        if (l) {
            l._iPrev = i;
            i._iNext = l
        }
        j._iPrev = m;
        m._iNext = j;
        if (this.__renderGroup) {
            if (n.__renderGroup) {
                n.__renderGroup.removeDisplayObjectAndChildren(n)
            }
            this.__renderGroup.addDisplayObjectAndChildren(n)
        }
    };
    g.DisplayObjectContainer.prototype.addChildAt = function (h, k) {
        if (k >= 0 && k <= this.children.length) {
            if (h.parent != undefined) {
                h.parent.removeChild(h)
            }
            h.parent = this;
            if (this.stage) {
                var j = h;
                do {
                    if (j.interactive) {
                        this.stage.dirty = true
                    }
                    j.stage = this.stage;
                    j = j._iNext
                } while (j)
            }
            var i = h.first;
            var l = h.last;
            var o;
            var n;
            if (k == this.children.length) {
                n = this.last;
                var b = this;
                var m = this.last;
                while (b) {
                    if (b.last == m) {
                        b.last = h.last
                    }
                    b = b.parent
                }
            } else {
                if (k == 0) {
                    n = this
                } else {
                    n = this.children[k - 1].last
                }
            }
            o = n._iNext;
            if (o) {
                o._iPrev = l;
                l._iNext = o
            }
            i._iPrev = n;
            n._iNext = i;
            this.children.splice(k, 0, h);
            if (this.__renderGroup) {
                if (h.__renderGroup) {
                    h.__renderGroup.removeDisplayObjectAndChildren(h)
                }
                this.__renderGroup.addDisplayObjectAndChildren(h)
            }
        } else {
            throw new Error(h + " The index " + k + " supplied is out of bounds " + this.children.length)
        }
    };
    g.DisplayObjectContainer.prototype.swapChildren = function (h, b) {
        return
    };
    g.DisplayObjectContainer.prototype.getChildAt = function (b) {
        if (b >= 0 && b < this.children.length) {
            return this.children[b]
        } else {
            throw new Error(child + " Both the supplied DisplayObjects must be a child of the caller " + this)
        }
    };
    g.DisplayObjectContainer.prototype.removeChild = function (h) {
        var k = this.children.indexOf(h);
        if (k !== -1) {
            var i = h.first;
            var l = h.last;
            var n = l._iNext;
            var m = i._iPrev;
            if (n) {
                n._iPrev = m
            }
            m._iNext = n;
            if (this.last == l) {
                var o = i._iPrev;
                var b = this;
                while (b.last == l.last) {
                    b.last = o;
                    b = b.parent;
                    if (!b) {
                        break
                    }
                }
            }
            l._iNext = null;
            i._iPrev = null;
            if (this.stage) {
                var j = h;
                do {
                    if (j.interactive) {
                        this.stage.dirty = true
                    }
                    j.stage = null;
                    j = j._iNext
                } while (j)
            }
            if (h.__renderGroup) {
                h.__renderGroup.removeDisplayObjectAndChildren(h)
            }
            h.parent = undefined;
            this.children.splice(k, 1)
        } else {
            throw new Error(h + " The supplied DisplayObject must be a child of the caller " + this)
        }
    };
    g.DisplayObjectContainer.prototype.updateTransform = function () {
        if (!this.visible) {
            return
        }
        g.DisplayObject.prototype.updateTransform.call(this);
        for (var h = 0, b = this.children.length; h < b; h++) {
            this.children[h].updateTransform()
        }
    };
    g.blendModes = {};
    g.blendModes.NORMAL = 0;
    g.blendModes.SCREEN = 1;
    g.Sprite = function (b) {
        g.DisplayObjectContainer.call(this);
        this.anchor = new g.Point();
        this.texture = b;
        this.blendMode = g.blendModes.NORMAL;
        this._width = 0;
        this._height = 0;
        if (b.baseTexture.hasLoaded) {
            this.updateFrame = true
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind)
        }
        this.renderable = true
    };
    g.Sprite.prototype = Object.create(g.DisplayObjectContainer.prototype);
    g.Sprite.prototype.constructor = g.Sprite;
    Object.defineProperty(g.Sprite.prototype, "width", {
        get: function () {
            return this.scale.x * this.texture.frame.width
        }, set: function (b) {
            this.scale.x = b / this.texture.frame.width;
            this._width = b
        }
    });
    Object.defineProperty(g.Sprite.prototype, "height", {
        get: function () {
            return this.scale.y * this.texture.frame.height
        }, set: function (b) {
            this.scale.y = b / this.texture.frame.height;
            this._height = b
        }
    });
    g.Sprite.prototype.setTexture = function (b) {
        if (this.texture.baseTexture != b.baseTexture) {
            this.textureChange = true;
            this.texture = b;
            if (this.__renderGroup) {
                this.__renderGroup.updateTexture(this)
            }
        } else {
            this.texture = b
        }
        this.updateFrame = true
    };
    g.Sprite.prototype.onTextureUpdate = function (b) {
        if (this._width) {
            this.scale.x = this._width / this.texture.frame.width
        }
        if (this._height) {
            this.scale.y = this._height / this.texture.frame.height
        }
        this.updateFrame = true
    };
    g.Sprite.fromFrame = function (h) {
        var b = g.TextureCache[h];
        if (!b) {
            throw new Error("The frameId '" + h + "' does not exist in the texture cache" + this)
        }
        return new g.Sprite(b)
    };
    g.Sprite.fromImage = function (b) {
        var h = g.Texture.fromImage(b);
        return new g.Sprite(h)
    };
    g.Stage = function (h, b) {
        g.DisplayObjectContainer.call(this);
        this.worldTransform = g.mat3.create();
        this.interactive = b;
        this.interactionManager = new g.InteractionManager(this);
        this.dirty = true;
        this.__childrenAdded = [];
        this.__childrenRemoved = [];
        this.stage = this;
        this.stage.hitArea = new g.Rectangle(0, 0, 100000, 100000);
        this.setBackgroundColor(h);
        this.worldVisible = true
    };
    g.Stage.prototype = Object.create(g.DisplayObjectContainer.prototype);
    g.Stage.prototype.constructor = g.Stage;
    g.Stage.prototype.updateTransform = function () {
        this.worldAlpha = 1;
        this.vcount = g.visibleCount;
        for (var h = 0, b = this.children.length; h < b; h++) {
            this.children[h].updateTransform()
        }
        if (this.dirty) {
            this.dirty = false;
            this.interactionManager.dirty = true
        }
        if (this.interactive) {
            this.interactionManager.update()
        }
    };
    g.Stage.prototype.setBackgroundColor = function (b) {
        this.backgroundColor = b || 0;
        this.backgroundColorSplit = e(this.backgroundColor);
        var h = this.backgroundColor.toString(16);
        h = "000000".substr(0, 6 - h.length) + h;
        this.backgroundColorString = "#" + h
    };
    g.Stage.prototype.getMousePosition = function () {
        return this.interactionManager.mouse.global
    };
    g.CustomRenderable = function () {
        g.DisplayObject.call(this)
    };
    g.CustomRenderable.prototype = Object.create(g.DisplayObject.prototype);
    g.CustomRenderable.prototype.constructor = g.CustomRenderable;
    g.CustomRenderable.prototype.renderCanvas = function (b) {
    };
    g.CustomRenderable.prototype.initWebGL = function (b) {
    };
    g.CustomRenderable.prototype.renderWebGL = function (h, b) {
    };
    g.Strip = function (j, i, b) {
        g.DisplayObjectContainer.call(this);
        this.texture = j;
        this.blendMode = g.blendModes.NORMAL;
        try {
            this.uvs = new Float32Array([0, 1, 1, 1, 1, 0, 0, 1]);
            this.verticies = new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0]);
            this.colors = new Float32Array([1, 1, 1, 1]);
            this.indices = new Uint16Array([0, 1, 2, 3])
        } catch (h) {
            this.uvs = [0, 1, 1, 1, 1, 0, 0, 1];
            this.verticies = [0, 0, 0, 0, 0, 0, 0, 0, 0];
            this.colors = [1, 1, 1, 1];
            this.indices = [0, 1, 2, 3]
        }
        this.width = i;
        this.height = b;
        if (j.baseTexture.hasLoaded) {
            this.width = this.texture.frame.width;
            this.height = this.texture.frame.height;
            this.updateFrame = true
        } else {
            this.onTextureUpdateBind = this.onTextureUpdate.bind(this);
            this.texture.addEventListener("update", this.onTextureUpdateBind)
        }
        this.renderable = true
    };
    g.Strip.prototype = Object.create(g.DisplayObjectContainer.prototype);
    g.Strip.prototype.constructor = g.Strip;
    g.Strip.prototype.setTexture = function (b) {
        this.texture = b;
        this.width = b.frame.width;
        this.height = b.frame.height;
        this.updateFrame = true
    };
    g.Strip.prototype.onTextureUpdate = function (b) {
        this.updateFrame = true
    };
    g.Rope = function (i, h) {
        g.Strip.call(this, i);
        this.points = h;
        try {
            this.verticies = new Float32Array(h.length * 4);
            this.uvs = new Float32Array(h.length * 4);
            this.colors = new Float32Array(h.length * 2);
            this.indices = new Uint16Array(h.length * 2)
        } catch (b) {
            this.verticies = verticies;
            this.uvs = uvs;
            this.colors = colors;
            this.indices = indices
        }
        this.refresh()
    };
    g.Rope.prototype = Object.create(g.Strip.prototype);
    g.Rope.prototype.constructor = g.Rope;
    g.Rope.prototype.refresh = function () {
        var r = this.points;
        if (r.length < 1) {
            return
        }
        var j = this.uvs;
        var s = this.indices;
        var b = this.colors;
        var p = r[0];
        var o;
        var h = {x: 0, y: 0};
        var q = r[0];
        this.count -= 0.2;
        j[0] = 0;
        j[1] = 1;
        j[2] = 0;
        j[3] = 1;
        b[0] = 1;
        b[1] = 1;
        s[0] = 0;
        s[1] = 1;
        var n = r.length;
        for (var k = 1; k < n; k++) {
            var q = r[k];
            var m = k * 4;
            var l = k / (n - 1);
            if (k % 2) {
                j[m] = l;
                j[m + 1] = 0;
                j[m + 2] = l;
                j[m + 3] = 1
            } else {
                j[m] = l;
                j[m + 1] = 0;
                j[m + 2] = l;
                j[m + 3] = 1
            }
            m = k * 2;
            b[m] = 1;
            b[m + 1] = 1;
            m = k * 2;
            s[m] = m;
            s[m + 1] = m + 1;
            p = q
        }
    };
    g.Rope.prototype.updateTransform = function () {
        var s = this.points;
        if (s.length < 1) {
            return
        }
        var b = this.verticies;
        var q = s[0];
        var o;
        var h = {x: 0, y: 0};
        var r = s[0];
        this.count -= 0.2;
        b[0] = r.x + h.x;
        b[1] = r.y + h.y;
        b[2] = r.x - h.x;
        b[3] = r.y - h.y;
        var p = s.length;
        for (var k = 1; k < p; k++) {
            var r = s[k];
            var m = k * 4;
            if (k < s.length - 1) {
                o = s[k + 1]
            } else {
                o = r
            }
            h.y = -(o.x - q.x);
            h.x = o.y - q.y;
            var n = (1 - (k / (p - 1))) * 10;
            if (n > 1) {
                n = 1
            }
            var j = Math.sqrt(h.x * h.x + h.y * h.y);
            var l = this.texture.height / 2;
            h.x /= j;
            h.y /= j;
            h.x *= l;
            h.y *= l;
            b[m] = r.x + h.x;
            b[m + 1] = r.y + h.y;
            b[m + 2] = r.x - h.x;
            b[m + 3] = r.y - h.y;
            q = r
        }
        g.DisplayObjectContainer.prototype.updateTransform.call(this)
    };
    g.Rope.prototype.setTexture = function (b) {
        this.texture = b;
        this.updateFrame = true
    };
    g.TilingSprite = function (i, h, b) {
        g.DisplayObjectContainer.call(this);
        this.texture = i;
        this.width = h;
        this.height = b;
        this.tileScale = new g.Point(1, 1);
        this.tilePosition = new g.Point(0, 0);
        this.renderable = true;
        this.blendMode = g.blendModes.NORMAL
    };
    g.TilingSprite.prototype = Object.create(g.DisplayObjectContainer.prototype);
    g.TilingSprite.prototype.constructor = g.TilingSprite;
    g.TilingSprite.prototype.setTexture = function (b) {
        this.texture = b;
        this.updateFrame = true
    };
    g.TilingSprite.prototype.onTextureUpdate = function (b) {
        this.updateFrame = true
    };
    g.FilterBlock = function (b) {
        this.graphics = b;
        this.visible = true;
        this.renderable = true
    };
    g.MaskFilter = function (b) {
        this.graphics
    };
    g.Graphics = function () {
        g.DisplayObjectContainer.call(this);
        this.renderable = true;
        this.fillAlpha = 1;
        this.lineWidth = 0;
        this.lineColor = "black";
        this.graphicsData = [];
        this.currentPath = {points: []}
    };
    g.Graphics.prototype = Object.create(g.DisplayObjectContainer.prototype);
    g.Graphics.prototype.constructor = g.Graphics;
    g.Graphics.prototype.lineStyle = function (b, h, i) {
        if (this.currentPath.points.length == 0) {
            this.graphicsData.pop()
        }
        this.lineWidth = b || 0;
        this.lineColor = h || 0;
        this.lineAlpha = (i == undefined) ? 1 : i;
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: g.Graphics.POLY
        };
        this.graphicsData.push(this.currentPath)
    };
    g.Graphics.prototype.moveTo = function (b, h) {
        if (this.currentPath.points.length == 0) {
            this.graphicsData.pop()
        }
        this.currentPath = this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [],
            type: g.Graphics.POLY
        };
        this.currentPath.points.push(b, h);
        this.graphicsData.push(this.currentPath)
    };
    g.Graphics.prototype.lineTo = function (b, h) {
        this.currentPath.points.push(b, h);
        this.dirty = true
    };
    g.Graphics.prototype.beginFill = function (b, h) {
        this.filling = true;
        this.fillColor = b || 0;
        this.fillAlpha = (h == undefined) ? 1 : h
    };
    g.Graphics.prototype.endFill = function () {
        this.filling = false;
        this.fillColor = null;
        this.fillAlpha = 1
    };
    g.Graphics.prototype.drawRect = function (h, j, i, b) {
        if (this.currentPath.points.length == 0) {
            this.graphicsData.pop()
        }
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [h, j, i, b],
            type: g.Graphics.RECT
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true
    };
    g.Graphics.prototype.drawCircle = function (h, i, b) {
        if (this.currentPath.points.length == 0) {
            this.graphicsData.pop()
        }
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [h, i, b, b],
            type: g.Graphics.CIRC
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true
    };
    g.Graphics.prototype.drawElipse = function (h, j, i, b) {
        if (this.currentPath.points.length == 0) {
            this.graphicsData.pop()
        }
        this.currentPath = {
            lineWidth: this.lineWidth,
            lineColor: this.lineColor,
            lineAlpha: this.lineAlpha,
            fillColor: this.fillColor,
            fillAlpha: this.fillAlpha,
            fill: this.filling,
            points: [h, j, i, b],
            type: g.Graphics.ELIP
        };
        this.graphicsData.push(this.currentPath);
        this.dirty = true
    };
    g.Graphics.prototype.clear = function () {
        this.lineWidth = 0;
        this.filling = false;
        this.dirty = true;
        this.clearDirty = true;
        this.graphicsData = []
    };
    g.Graphics.POLY = 0;
    g.Graphics.RECT = 1;
    g.Graphics.CIRC = 2;
    g.Graphics.ELIP = 3;
    g.CanvasGraphics = function () {
    };
    g.CanvasGraphics.renderGraphics = function (C, k) {
        var u = C.worldAlpha;
        for (var A = 0; A < C.graphicsData.length; A++) {
            var E = C.graphicsData[A];
            var z = E.points;
            k.strokeStyle = color = "#" + ("00000" + (E.lineColor | 0).toString(16)).substr(-6);
            k.lineWidth = E.lineWidth;
            if (E.type == g.Graphics.POLY) {
                k.beginPath();
                k.moveTo(z[0], z[1]);
                for (var v = 1; v < z.length / 2; v++) {
                    k.lineTo(z[v * 2], z[v * 2 + 1])
                }
                if (z[0] == z[z.length - 2] && z[1] == z[z.length - 1]) {
                    k.closePath()
                }
                if (E.fill) {
                    k.globalAlpha = E.fillAlpha * u;
                    k.fillStyle = color = "#" + ("00000" + (E.fillColor | 0).toString(16)).substr(-6);
                    k.fill()
                }
                if (E.lineWidth) {
                    k.globalAlpha = E.lineAlpha * u;
                    k.stroke()
                }
            } else {
                if (E.type == g.Graphics.RECT) {
                    if (E.fillColor) {
                        k.globalAlpha = E.fillAlpha * u;
                        k.fillStyle = color = "#" + ("00000" + (E.fillColor | 0).toString(16)).substr(-6);
                        k.fillRect(z[0], z[1], z[2], z[3])
                    }
                    if (E.lineWidth) {
                        k.globalAlpha = E.lineAlpha * u;
                        k.strokeRect(z[0], z[1], z[2], z[3])
                    }
                } else {
                    if (E.type == g.Graphics.CIRC) {
                        k.beginPath();
                        k.arc(z[0], z[1], z[2], 0, 2 * Math.PI);
                        k.closePath();
                        if (E.fill) {
                            k.globalAlpha = E.fillAlpha * u;
                            k.fillStyle = color = "#" + ("00000" + (E.fillColor | 0).toString(16)).substr(-6);
                            k.fill()
                        }
                        if (E.lineWidth) {
                            k.globalAlpha = E.lineAlpha * u;
                            k.stroke()
                        }
                    } else {
                        if (E.type == g.Graphics.ELIP) {
                            var l = E.points;
                            var q = l[2] * 2;
                            var B = l[3] * 2;
                            var p = l[0] - q / 2;
                            var o = l[1] - B / 2;
                            k.beginPath();
                            var r = 0.5522848, n = (q / 2) * r, m = (B / 2) * r, t = p + q, b = o + B, s = p + q / 2, D = o + B / 2;
                            k.moveTo(p, D);
                            k.bezierCurveTo(p, D - m, s - n, o, s, o);
                            k.bezierCurveTo(s + n, o, t, D - m, t, D);
                            k.bezierCurveTo(t, D + m, s + n, b, s, b);
                            k.bezierCurveTo(s - n, b, p, D + m, p, D);
                            k.closePath();
                            if (E.fill) {
                                k.globalAlpha = E.fillAlpha * u;
                                k.fillStyle = color = "#" + ("00000" + (E.fillColor | 0).toString(16)).substr(-6);
                                k.fill()
                            }
                            if (E.lineWidth) {
                                k.globalAlpha = E.lineAlpha * u;
                                k.stroke()
                            }
                        }
                    }
                }
            }
        }
    };
    g.CanvasGraphics.renderGraphicsMask = function (D, k) {
        var u = D.worldAlpha;
        var B = D.graphicsData.length;
        if (B > 1) {
            B = 1;
            console.log("Pixi.js warning: masks in canvas can only mask using the first path in the graphics object")
        }
        for (var A = 0; A < 1; A++) {
            var F = D.graphicsData[A];
            var z = F.points;
            if (F.type == g.Graphics.POLY) {
                k.beginPath();
                k.moveTo(z[0], z[1]);
                for (var v = 1; v < z.length / 2; v++) {
                    k.lineTo(z[v * 2], z[v * 2 + 1])
                }
                if (z[0] == z[z.length - 2] && z[1] == z[z.length - 1]) {
                    k.closePath()
                }
            } else {
                if (F.type == g.Graphics.RECT) {
                    k.beginPath();
                    k.rect(z[0], z[1], z[2], z[3]);
                    k.closePath()
                } else {
                    if (F.type == g.Graphics.CIRC) {
                        k.beginPath();
                        k.arc(z[0], z[1], z[2], 0, 2 * Math.PI);
                        k.closePath()
                    } else {
                        if (F.type == g.Graphics.ELIP) {
                            var l = F.points;
                            var q = l[2] * 2;
                            var C = l[3] * 2;
                            var p = l[0] - q / 2;
                            var o = l[1] - C / 2;
                            k.beginPath();
                            var r = 0.5522848, n = (q / 2) * r, m = (C / 2) * r, t = p + q, b = o + C, s = p + q / 2, E = o + C / 2;
                            k.moveTo(p, E);
                            k.bezierCurveTo(p, E - m, s - n, o, s, o);
                            k.bezierCurveTo(s + n, o, t, E - m, t, E);
                            k.bezierCurveTo(t, E + m, s + n, b, s, b);
                            k.bezierCurveTo(s - n, b, p, E + m, p, E);
                            k.closePath()
                        }
                    }
                }
            }
        }
    };
    g.CanvasRenderer = function (i, b, h, j) {
        this.transparent = j;
        this.width = i || 800;
        this.height = b || 600;
        this.view = h || document.createElement("canvas");
        this.context = this.view.getContext("2d");
        this.refresh = true;
        this.view.width = this.width;
        this.view.height = this.height;
        this.count = 0
    };
    g.CanvasRenderer.prototype.constructor = g.CanvasRenderer;
    g.CanvasRenderer.prototype.render = function (b) {
        g.texturesToUpdate = [];
        g.texturesToDestroy = [];
        g.visibleCount++;
        b.updateTransform();
        if (this.view.style.backgroundColor != b.backgroundColorString && !this.transparent) {
            this.view.style.backgroundColor = b.backgroundColorString
        }
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.width, this.height);
        this.renderDisplayObject(b);
        if (b.interactive) {
            if (!b._interactiveEventsAdded) {
                b._interactiveEventsAdded = true;
                b.interactionManager.setTarget(this)
            }
        }
        if (g.Texture.frameUpdates.length > 0) {
            g.Texture.frameUpdates = []
        }
    };
    g.CanvasRenderer.prototype.resize = function (h, b) {
        this.width = h;
        this.height = b;
        this.view.width = h;
        this.view.height = b
    };
    g.CanvasRenderer.prototype.renderDisplayObject = function (m) {
        var j;
        var k = this.context;
        k.globalCompositeOperation = "source-over";
        var i = m.last._iNext;
        m = m.first;
        do {
            j = m.worldTransform;
            if (!m.visible) {
                m = m.last._iNext;
                continue
            }
            if (!m.renderable) {
                m = m._iNext;
                continue
            }
            if (m instanceof g.Sprite) {
                var l = m.texture.frame;
                if (l) {
                    k.globalAlpha = m.worldAlpha;
                    k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                    k.drawImage(m.texture.baseTexture.source, l.x, l.y, l.width, l.height, (m.anchor.x) * -l.width, (m.anchor.y) * -l.height, l.width, l.height)
                }
            } else {
                if (m instanceof g.Strip) {
                    k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                    this.renderStrip(m)
                } else {
                    if (m instanceof g.TilingSprite) {
                        k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                        this.renderTilingSprite(m)
                    } else {
                        if (m instanceof g.CustomRenderable) {
                            m.renderCanvas(this)
                        } else {
                            if (m instanceof g.Graphics) {
                                k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                                g.CanvasGraphics.renderGraphics(m, k)
                            } else {
                                if (m instanceof g.FilterBlock) {
                                    if (m.open) {
                                        k.save();
                                        var h = m.mask.alpha;
                                        var b = m.mask.worldTransform;
                                        k.setTransform(b[0], b[3], b[1], b[4], b[2], b[5]);
                                        m.mask.worldAlpha = 0.5;
                                        k.worldAlpha = 0;
                                        g.CanvasGraphics.renderGraphicsMask(m.mask, k);
                                        k.clip();
                                        m.mask.worldAlpha = h
                                    } else {
                                        k.restore()
                                    }
                                }
                            }
                        }
                    }
                }
            }
            m = m._iNext
        } while (m != i)
    };
    g.CanvasRenderer.prototype.renderStripFlat = function (j) {
        var k = this.context;
        var l = j.verticies;
        var o = j.uvs;
        var m = l.length / 2;
        this.count++;
        k.beginPath();
        for (var p = 1; p < m - 2; p++) {
            var q = p * 2;
            var n = l[q], h = l[q + 2], b = l[q + 4];
            var t = l[q + 1], s = l[q + 3], r = l[q + 5];
            k.moveTo(n, t);
            k.lineTo(h, s);
            k.lineTo(b, r)
        }
        k.fillStyle = "#FF0000";
        k.fill();
        k.closePath()
    };
    g.CanvasRenderer.prototype.renderTilingSprite = function (j) {
        var i = this.context;
        i.globalAlpha = j.worldAlpha;
        if (!j.__tilePattern) {
            j.__tilePattern = i.createPattern(j.texture.baseTexture.source, "repeat")
        }
        i.beginPath();
        var b = j.tilePosition;
        var h = j.tileScale;
        i.scale(h.x, h.y);
        i.translate(b.x, b.y);
        i.fillStyle = j.__tilePattern;
        i.fillRect(-b.x, -b.y, j.width / h.x, j.height / h.y);
        i.scale(1 / h.x, 1 / h.y);
        i.translate(-b.x, -b.y);
        i.closePath()
    };
    g.CanvasRenderer.prototype.renderStrip = function (A) {
        var l = this.context;
        var k = A.verticies;
        var z = A.uvs;
        var s = k.length / 2;
        this.count++;
        for (var B = 1; B < s - 2; B++) {
            var w = B * 2;
            var H = k[w], G = k[w + 2], E = k[w + 4];
            var q = k[w + 1], o = k[w + 3], j = k[w + 5];
            var F = z[w] * A.texture.width, D = z[w + 2] * A.texture.width, C = z[w + 4] * A.texture.width;
            var n = z[w + 1] * A.texture.height, h = z[w + 3] * A.texture.height, b = z[w + 5] * A.texture.height;
            l.save();
            l.beginPath();
            l.moveTo(H, q);
            l.lineTo(G, o);
            l.lineTo(E, j);
            l.closePath();
            l.clip();
            var I = F * h + n * C + D * b - h * C - n * D - F * b;
            var v = H * h + n * E + G * b - h * E - n * G - H * b;
            var u = F * G + H * C + D * E - G * C - H * D - F * E;
            var t = F * h * E + n * G * C + H * D * b - H * h * C - n * D * E - F * G * b;
            var r = q * h + n * j + o * b - h * j - n * o - q * b;
            var p = F * o + q * C + D * j - o * C - q * D - F * j;
            var m = F * h * j + n * o * C + q * D * b - q * h * C - n * D * j - F * o * b;
            l.transform(v / I, r / I, u / I, p / I, t / I, m / I);
            l.drawImage(A.texture.baseTexture.source, 0, 0);
            l.restore()
        }
    };
    g._batchs = [];
    g._getBatch = function (b) {
        if (g._batchs.length == 0) {
            return new g.WebGLBatch(b)
        } else {
            return g._batchs.pop()
        }
    };
    g._returnBatch = function (b) {
        b.clean();
        g._batchs.push(b)
    };
    g._restoreBatchs = function (h) {
        for (var b = 0; b < g._batchs.length; b++) {
            g._batchs[b].restoreLostContext(h)
        }
    };
    g.WebGLBatch = function (b) {
        this.gl = b;
        this.size = 0;
        this.vertexBuffer = b.createBuffer();
        this.indexBuffer = b.createBuffer();
        this.uvBuffer = b.createBuffer();
        this.colorBuffer = b.createBuffer();
        this.blendMode = g.blendModes.NORMAL;
        this.dynamicSize = 1
    };
    g.WebGLBatch.prototype.constructor = g.WebGLBatch;
    g.WebGLBatch.prototype.clean = function () {
        this.verticies = [];
        this.uvs = [];
        this.indices = [];
        this.colors = [];
        this.dynamicSize = 1;
        this.texture = null;
        this.last = null;
        this.size = 0;
        this.head;
        this.tail
    };
    g.WebGLBatch.prototype.restoreLostContext = function (b) {
        this.gl = b;
        this.vertexBuffer = b.createBuffer();
        this.indexBuffer = b.createBuffer();
        this.uvBuffer = b.createBuffer();
        this.colorBuffer = b.createBuffer()
    };
    g.WebGLBatch.prototype.init = function (b) {
        b.batch = this;
        this.dirty = true;
        this.blendMode = b.blendMode;
        this.texture = b.texture.baseTexture;
        this.head = b;
        this.tail = b;
        this.size = 1;
        this.growBatch()
    };
    g.WebGLBatch.prototype.insertBefore = function (b, i) {
        this.size++;
        b.batch = this;
        this.dirty = true;
        var h = i.__prev;
        i.__prev = b;
        b.__next = i;
        if (h) {
            b.__prev = h;
            h.__next = b
        } else {
            this.head = b
        }
    };
    g.WebGLBatch.prototype.insertAfter = function (h, b) {
        this.size++;
        h.batch = this;
        this.dirty = true;
        var i = b.__next;
        b.__next = h;
        h.__prev = b;
        if (i) {
            h.__next = i;
            i.__prev = h
        } else {
            this.tail = h
        }
    };
    g.WebGLBatch.prototype.remove = function (b) {
        this.size--;
        if (this.size == 0) {
            b.batch = null;
            b.__prev = null;
            b.__next = null;
            return
        }
        if (b.__prev) {
            b.__prev.__next = b.__next
        } else {
            this.head = b.__next;
            this.head.__prev = null
        }
        if (b.__next) {
            b.__next.__prev = b.__prev
        } else {
            this.tail = b.__prev;
            this.tail.__next = null
        }
        b.batch = null;
        b.__next = null;
        b.__prev = null;
        this.dirty = true
    };
    g.WebGLBatch.prototype.split = function (h) {
        this.dirty = true;
        var b = new g.WebGLBatch(this.gl);
        b.init(h);
        b.texture = this.texture;
        b.tail = this.tail;
        this.tail = h.__prev;
        this.tail.__next = null;
        h.__prev = null;
        var i = 0;
        while (h) {
            i++;
            h.batch = b;
            h = h.__next
        }
        b.size = i;
        this.size -= i;
        return b
    };
    g.WebGLBatch.prototype.merge = function (b) {
        this.dirty = true;
        this.tail.__next = b.head;
        b.head.__prev = this.tail;
        this.size += b.size;
        this.tail = b.tail;
        var h = b.head;
        while (h) {
            h.batch = this;
            h = h.__next
        }
    };
    g.WebGLBatch.prototype.growBatch = function () {
        var l = this.gl;
        if (this.size == 1) {
            this.dynamicSize = 1
        } else {
            this.dynamicSize = this.size * 1.5
        }
        this.verticies = new Float32Array(this.dynamicSize * 8);
        l.bindBuffer(l.ARRAY_BUFFER, this.vertexBuffer);
        l.bufferData(l.ARRAY_BUFFER, this.verticies, l.DYNAMIC_DRAW);
        this.uvs = new Float32Array(this.dynamicSize * 8);
        l.bindBuffer(l.ARRAY_BUFFER, this.uvBuffer);
        l.bufferData(l.ARRAY_BUFFER, this.uvs, l.DYNAMIC_DRAW);
        this.dirtyUVS = true;
        this.colors = new Float32Array(this.dynamicSize * 4);
        l.bindBuffer(l.ARRAY_BUFFER, this.colorBuffer);
        l.bufferData(l.ARRAY_BUFFER, this.colors, l.DYNAMIC_DRAW);
        this.dirtyColors = true;
        this.indices = new Uint16Array(this.dynamicSize * 6);
        var h = this.indices.length / 6;
        for (var b = 0; b < h; b++) {
            var k = b * 6;
            var j = b * 4;
            this.indices[k + 0] = j + 0;
            this.indices[k + 1] = j + 1;
            this.indices[k + 2] = j + 2;
            this.indices[k + 3] = j + 0;
            this.indices[k + 4] = j + 2;
            this.indices[k + 5] = j + 3
        }
        l.bindBuffer(l.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        l.bufferData(l.ELEMENT_ARRAY_BUFFER, this.indices, l.STATIC_DRAW)
    };
    g.WebGLBatch.prototype.refresh = function () {
        var w = this.gl;
        if (this.dynamicSize < this.size) {
            this.growBatch()
        }
        var r = 0;
        var v, u, t, i, h, o, n, m, l, k;
        var D, C, A, z, E, B;
        var s = this.head;
        while (s) {
            k = r * 8;
            var q = s.texture;
            var p = q.frame;
            var F = q.baseTexture.width;
            var j = q.baseTexture.height;
            this.uvs[k + 0] = p.x / F;
            this.uvs[k + 1] = p.y / j;
            this.uvs[k + 2] = (p.x + p.width) / F;
            this.uvs[k + 3] = p.y / j;
            this.uvs[k + 4] = (p.x + p.width) / F;
            this.uvs[k + 5] = (p.y + p.height) / j;
            this.uvs[k + 6] = p.x / F;
            this.uvs[k + 7] = (p.y + p.height) / j;
            s.updateFrame = false;
            colorIndex = r * 4;
            this.colors[colorIndex] = this.colors[colorIndex + 1] = this.colors[colorIndex + 2] = this.colors[colorIndex + 3] = s.worldAlpha;
            s = s.__next;
            r++
        }
        this.dirtyUVS = true;
        this.dirtyColors = true
    };
    g.WebGLBatch.prototype.update = function () {
        var B = this.gl;
        var A, z, w, i, h, r, q, p, o, n, m, k;
        var H, F, D, C, G, E;
        var u = 0;
        var v = this.head;
        while (v) {
            if (v.vcount === g.visibleCount) {
                z = v.texture.frame.width;
                w = v.texture.frame.height;
                i = v.anchor.x;
                h = v.anchor.y;
                r = z * (1 - i);
                q = z * -i;
                p = w * (1 - h);
                o = w * -h;
                n = u * 8;
                A = v.worldTransform;
                H = A[0];
                F = A[3];
                D = A[1];
                C = A[4];
                G = A[2];
                E = A[5];
                this.verticies[n + 0] = H * q + D * o + G;
                this.verticies[n + 1] = C * o + F * q + E;
                this.verticies[n + 2] = H * r + D * o + G;
                this.verticies[n + 3] = C * o + F * r + E;
                this.verticies[n + 4] = H * r + D * p + G;
                this.verticies[n + 5] = C * p + F * r + E;
                this.verticies[n + 6] = H * q + D * p + G;
                this.verticies[n + 7] = C * p + F * q + E;
                if (v.updateFrame || v.texture.updateFrame) {
                    this.dirtyUVS = true;
                    var t = v.texture;
                    var s = t.frame;
                    var I = t.baseTexture.width;
                    var l = t.baseTexture.height;
                    this.uvs[n + 0] = s.x / I;
                    this.uvs[n + 1] = s.y / l;
                    this.uvs[n + 2] = (s.x + s.width) / I;
                    this.uvs[n + 3] = s.y / l;
                    this.uvs[n + 4] = (s.x + s.width) / I;
                    this.uvs[n + 5] = (s.y + s.height) / l;
                    this.uvs[n + 6] = s.x / I;
                    this.uvs[n + 7] = (s.y + s.height) / l;
                    v.updateFrame = false
                }
                if (v.cacheAlpha != v.worldAlpha) {
                    v.cacheAlpha = v.worldAlpha;
                    var j = u * 4;
                    this.colors[j] = this.colors[j + 1] = this.colors[j + 2] = this.colors[j + 3] = v.worldAlpha;
                    this.dirtyColors = true
                }
            } else {
                n = u * 8;
                this.verticies[n + 0] = 0;
                this.verticies[n + 1] = 0;
                this.verticies[n + 2] = 0;
                this.verticies[n + 3] = 0;
                this.verticies[n + 4] = 0;
                this.verticies[n + 5] = 0;
                this.verticies[n + 6] = 0;
                this.verticies[n + 7] = 0
            }
            u++;
            v = v.__next
        }
    };
    g.WebGLBatch.prototype.render = function (k, h) {
        k = k || 0;
        if (h == undefined) {
            h = this.size
        }
        if (this.dirty) {
            this.refresh();
            this.dirty = false
        }
        if (this.size == 0) {
            return
        }
        this.update();
        var i = this.gl;
        var j = g.shaderProgram;
        i.useProgram(j);
        i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer);
        i.bufferSubData(i.ARRAY_BUFFER, 0, this.verticies);
        i.vertexAttribPointer(j.vertexPositionAttribute, 2, i.FLOAT, false, 0, 0);
        i.bindBuffer(i.ARRAY_BUFFER, this.uvBuffer);
        if (this.dirtyUVS) {
            this.dirtyUVS = false;
            i.bufferSubData(i.ARRAY_BUFFER, 0, this.uvs)
        }
        i.vertexAttribPointer(j.textureCoordAttribute, 2, i.FLOAT, false, 0, 0);
        i.activeTexture(i.TEXTURE0);
        i.bindTexture(i.TEXTURE_2D, this.texture._glTexture);
        i.bindBuffer(i.ARRAY_BUFFER, this.colorBuffer);
        if (this.dirtyColors) {
            this.dirtyColors = false;
            i.bufferSubData(i.ARRAY_BUFFER, 0, this.colors)
        }
        i.vertexAttribPointer(j.colorAttribute, 1, i.FLOAT, false, 0, 0);
        i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        var b = h - k;
        i.drawElements(i.TRIANGLES, b * 6, i.UNSIGNED_SHORT, k * 2 * 6)
    };
    g.WebGLGraphics = function () {
    };
    g.WebGLGraphics.renderGraphics = function (i, h) {
        var j = g.gl;
        if (!i._webGL) {
            i._webGL = {points: [], indices: [], lastIndex: 0, buffer: j.createBuffer(), indexBuffer: j.createBuffer()}
        }
        if (i.dirty) {
            i.dirty = false;
            if (i.clearDirty) {
                i.clearDirty = false;
                i._webGL.lastIndex = 0;
                i._webGL.points = [];
                i._webGL.indices = []
            }
            g.WebGLGraphics.updateGraphics(i)
        }
        g.activatePrimitiveShader();
        var b = g.mat3.clone(i.worldTransform);
        g.mat3.transpose(b);
        j.blendFunc(j.ONE, j.ONE_MINUS_SRC_ALPHA);
        j.uniformMatrix3fv(g.primitiveProgram.translationMatrix, false, b);
        j.uniform2f(g.primitiveProgram.projectionVector, h.x, h.y);
        j.uniform1f(g.primitiveProgram.alpha, i.worldAlpha);
        j.bindBuffer(j.ARRAY_BUFFER, i._webGL.buffer);
        j.vertexAttribPointer(g.shaderProgram.vertexPositionAttribute, 2, j.FLOAT, false, 0, 0);
        j.vertexAttribPointer(g.primitiveProgram.vertexPositionAttribute, 2, j.FLOAT, false, 4 * 6, 0);
        j.vertexAttribPointer(g.primitiveProgram.colorAttribute, 4, j.FLOAT, false, 4 * 6, 2 * 4);
        j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, i._webGL.indexBuffer);
        j.drawElements(j.TRIANGLE_STRIP, i._webGL.indices.length, j.UNSIGNED_SHORT, 0);
        g.activateDefaultShader()
    };
    g.WebGLGraphics.updateGraphics = function (b) {
        for (var h = b._webGL.lastIndex; h < b.graphicsData.length; h++) {
            var j = b.graphicsData[h];
            if (j.type == g.Graphics.POLY) {
                if (j.fill) {
                    if (j.points.length > 3) {
                        g.WebGLGraphics.buildPoly(j, b._webGL)
                    }
                }
                if (j.lineWidth > 0) {
                    g.WebGLGraphics.buildLine(j, b._webGL)
                }
            } else {
                if (j.type == g.Graphics.RECT) {
                    g.WebGLGraphics.buildRectangle(j, b._webGL)
                } else {
                    if (j.type == g.Graphics.CIRC || j.type == g.Graphics.ELIP) {
                        g.WebGLGraphics.buildCircle(j, b._webGL)
                    }
                }
            }
        }
        b._webGL.lastIndex = b.graphicsData.length;
        var k = g.gl;
        b._webGL.glPoints = new Float32Array(b._webGL.points);
        k.bindBuffer(k.ARRAY_BUFFER, b._webGL.buffer);
        k.bufferData(k.ARRAY_BUFFER, b._webGL.glPoints, k.STATIC_DRAW);
        b._webGL.glIndicies = new Uint16Array(b._webGL.indices);
        k.bindBuffer(k.ELEMENT_ARRAY_BUFFER, b._webGL.indexBuffer);
        k.bufferData(k.ELEMENT_ARRAY_BUFFER, b._webGL.glIndicies, k.STATIC_DRAW)
    };
    g.WebGLGraphics.buildRectangle = function (w, m) {
        var k = w.points;
        var s = k[0];
        var q = k[1];
        var i = k[2];
        var v = k[3];
        if (w.fill) {
            var l = e(w.fillColor);
            var j = w.fillAlpha;
            var h = l[0] * j;
            var n = l[1] * j;
            var p = l[2] * j;
            var t = m.points;
            var u = m.indices;
            var o = t.length / 6;
            t.push(s, q);
            t.push(h, n, p, j);
            t.push(s + i, q);
            t.push(h, n, p, j);
            t.push(s, q + v);
            t.push(h, n, p, j);
            t.push(s + i, q + v);
            t.push(h, n, p, j);
            u.push(o, o, o + 1, o + 2, o + 3, o + 3)
        }
        if (w.lineWidth) {
            w.points = [s, q, s + i, q, s + i, q + v, s, q + v, s, q];
            g.WebGLGraphics.buildLine(w, m)
        }
    };
    g.WebGLGraphics.buildCircle = function (o, C) {
        var l = o.points;
        var n = l[0];
        var m = l[1];
        var t = l[2];
        var s = l[3];
        var p = 40;
        var z = (Math.PI * 2) / p;
        if (o.fill) {
            var u = e(o.fillColor);
            var j = o.fillAlpha;
            var q = u[0] * j;
            var w = u[1] * j;
            var A = u[2] * j;
            var B = C.points;
            var k = C.indices;
            var h = B.length / 6;
            k.push(h);
            for (var v = 0; v < p + 1; v++) {
                B.push(n, m, q, w, A, j);
                B.push(n + Math.sin(z * v) * t, m + Math.cos(z * v) * s, q, w, A, j);
                k.push(h++, h++)
            }
            k.push(h - 1)
        }
        if (o.lineWidth) {
            o.points = [];
            for (var v = 0; v < p + 1; v++) {
                o.points.push(n + Math.sin(z * v) * t, m + Math.cos(z * v) * s)
            }
            g.WebGLGraphics.buildLine(o, C)
        }
    };
    g.WebGLGraphics.buildLine = function (Z, I) {
        var S = true;
        var L = Z.points;
        if (L.length == 0) {
            return
        }
        var z = new g.Point(L[0], L[1]);
        var s = new g.Point(L[L.length - 2], L[L.length - 1]);
        if (z.x == s.x && z.y == s.y) {
            L.pop();
            L.pop();
            s = new g.Point(L[L.length - 2], L[L.length - 1]);
            var B = s.x + (z.x - s.x) * 0.5;
            var w = s.y + (z.y - s.y) * 0.5;
            L.unshift(B, w);
            L.push(B, w)
        }
        var W = I.points;
        var p = I.indices;
        var A = L.length / 2;
        var v = L.length;
        var Y = W.length / 6;
        var h = Z.lineWidth / 2;
        var K = e(Z.lineColor);
        var U = Z.lineAlpha;
        var Q = K[0] * U;
        var X = K[1] * U;
        var aa = K[2] * U;
        var N, M, F, E, o, n;
        var P, O, D, C, m, l;
        var k, j;
        var T, J, u, R, H, t;
        var ab, G, q;
        N = L[0];
        M = L[1];
        F = L[2];
        E = L[3];
        P = -(M - E);
        O = N - F;
        q = Math.sqrt(P * P + O * O);
        P /= q;
        O /= q;
        P *= h;
        O *= h;
        W.push(N - P, M - O, Q, X, aa, U);
        W.push(N + P, M + O, Q, X, aa, U);
        for (var V = 1; V < A - 1; V++) {
            N = L[(V - 1) * 2];
            M = L[(V - 1) * 2 + 1];
            F = L[(V) * 2];
            E = L[(V) * 2 + 1];
            o = L[(V + 1) * 2];
            n = L[(V + 1) * 2 + 1];
            P = -(M - E);
            O = N - F;
            q = Math.sqrt(P * P + O * O);
            P /= q;
            O /= q;
            P *= h;
            O *= h;
            D = -(E - n);
            C = F - o;
            q = Math.sqrt(D * D + C * C);
            D /= q;
            C /= q;
            D *= h;
            C *= h;
            T = (-O + M) - (-O + E);
            J = (-P + F) - (-P + N);
            u = (-P + N) * (-O + E) - (-P + F) * (-O + M);
            R = (-C + n) - (-C + E);
            H = (-D + F) - (-D + o);
            t = (-D + o) * (-C + E) - (-D + F) * (-C + n);
            ab = T * H - R * J;
            if (ab == 0) {
                ab += 1
            }
            px = (J * t - H * u) / ab;
            py = (R * u - T * t) / ab;
            G = (px - F) * (px - F) + (py - E) + (py - E);
            if (G > 140 * 140) {
                m = P - D;
                l = O - C;
                q = Math.sqrt(m * m + l * l);
                m /= q;
                l /= q;
                m *= h;
                l *= h;
                W.push(F - m, E - l);
                W.push(Q, X, aa, U);
                W.push(F + m, E + l);
                W.push(Q, X, aa, U);
                W.push(F - m, E - l);
                W.push(Q, X, aa, U);
                v++
            } else {
                W.push(px, py);
                W.push(Q, X, aa, U);
                W.push(F - (px - F), E - (py - E));
                W.push(Q, X, aa, U)
            }
        }
        N = L[(A - 2) * 2];
        M = L[(A - 2) * 2 + 1];
        F = L[(A - 1) * 2];
        E = L[(A - 1) * 2 + 1];
        P = -(M - E);
        O = N - F;
        q = Math.sqrt(P * P + O * O);
        P /= q;
        O /= q;
        P *= h;
        O *= h;
        W.push(F - P, E - O);
        W.push(Q, X, aa, U);
        W.push(F + P, E + O);
        W.push(Q, X, aa, U);
        p.push(Y);
        for (var V = 0; V < v; V++) {
            p.push(Y++)
        }
        p.push(Y - 1)
    };
    g.WebGLGraphics.buildPoly = function (w, o) {
        var u = w.points;
        if (u.length < 6) {
            return
        }
        var t = o.points;
        var v = o.indices;
        var j = u.length / 2;
        var m = e(w.fillColor);
        var l = w.fillAlpha;
        var h = m[0] * l;
        var p = m[1] * l;
        var s = m[2] * l;
        var k = g.PolyK.Triangulate(u);
        var q = t.length / 6;
        for (var n = 0; n < k.length; n += 3) {
            v.push(k[n] + q);
            v.push(k[n] + q);
            v.push(k[n + 1] + q);
            v.push(k[n + 2] + q);
            v.push(k[n + 2] + q)
        }
        for (var n = 0; n < j; n++) {
            t.push(u[n * 2], u[n * 2 + 1], h, p, s, l)
        }
    };
    function e(b) {
        return [(b >> 16 & 255) / 255, (b >> 8 & 255) / 255, (b & 255) / 255]
    }

    g._defaultFrame = new g.Rectangle(0, 0, 1, 1);
    g.gl;
    g.WebGLRenderer = function (k, b, i, n, h) {
        this.transparent = !!n;
        this.width = k || 800;
        this.height = b || 600;
        this.view = i || document.createElement("canvas");
        this.view.width = this.width;
        this.view.height = this.height;
        var j = this;
        this.view.addEventListener("webglcontextlost", function (o) {
            j.handleContextLost(o)
        }, false);
        this.view.addEventListener("webglcontextrestored", function (o) {
            j.handleContextRestored(o)
        }, false);
        this.batchs = [];
        try {
            g.gl = this.gl = this.view.getContext("experimental-webgl", {
                alpha: this.transparent,
                antialias: !!h,
                premultipliedAlpha: false,
                stencil: true
            })
        } catch (l) {
            throw new Error(" This browser does not support webGL. Try using the canvas renderer" + this)
        }
        g.initPrimitiveShader();
        g.initDefaultShader();
        g.initDefaultStripShader();
        g.activateDefaultShader();
        var m = this.gl;
        g.WebGLRenderer.gl = m;
        this.batch = new g.WebGLBatch(m);
        m.disable(m.DEPTH_TEST);
        m.disable(m.CULL_FACE);
        m.enable(m.BLEND);
        m.colorMask(true, true, true, this.transparent);
        g.projection = new g.Point(400, 300);
        this.resize(this.width, this.height);
        this.contextLost = false;
        this.stageRenderGroup = new g.WebGLRenderGroup(this.gl)
    };
    g.WebGLRenderer.prototype.constructor = g.WebGLRenderer;
    g.WebGLRenderer.getBatch = function () {
        if (g._batchs.length == 0) {
            return new g.WebGLBatch(g.WebGLRenderer.gl)
        } else {
            return g._batchs.pop()
        }
    };
    g.WebGLRenderer.returnBatch = function (b) {
        b.clean();
        g._batchs.push(b)
    };
    g.WebGLRenderer.prototype.render = function (b) {
        if (this.contextLost) {
            return
        }
        if (this.__stage !== b) {
            this.__stage = b;
            this.stageRenderGroup.setRenderable(b)
        }
        g.WebGLRenderer.updateTextures();
        g.visibleCount++;
        b.updateTransform();
        var j = this.gl;
        j.colorMask(true, true, true, this.transparent);
        j.viewport(0, 0, this.width, this.height);
        j.bindFramebuffer(j.FRAMEBUFFER, null);
        j.clearColor(b.backgroundColorSplit[0], b.backgroundColorSplit[1], b.backgroundColorSplit[2], !this.transparent);
        j.clear(j.COLOR_BUFFER_BIT);
        this.stageRenderGroup.backgroundColor = b.backgroundColorSplit;
        this.stageRenderGroup.render(g.projection);
        if (b.interactive) {
            if (!b._interactiveEventsAdded) {
                b._interactiveEventsAdded = true;
                b.interactionManager.setTarget(this)
            }
        }
        if (g.Texture.frameUpdates.length > 0) {
            for (var h = 0; h < g.Texture.frameUpdates.length; h++) {
                g.Texture.frameUpdates[h].updateFrame = false
            }
            g.Texture.frameUpdates = []
        }
    };
    g.WebGLRenderer.updateTextures = function () {
        for (var b = 0; b < g.texturesToUpdate.length; b++) {
            g.WebGLRenderer.updateTexture(g.texturesToUpdate[b])
        }
        for (var b = 0; b < g.texturesToDestroy.length; b++) {
            g.WebGLRenderer.destroyTexture(g.texturesToDestroy[b])
        }
        g.texturesToUpdate = [];
        g.texturesToDestroy = []
    };
    g.WebGLRenderer.updateTexture = function (b) {
        var h = g.gl;
        if (!b._glTexture) {
            b._glTexture = h.createTexture()
        }
        if (b.hasLoaded) {
            h.bindTexture(h.TEXTURE_2D, b._glTexture);
            h.pixelStorei(h.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
            h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, h.RGBA, h.UNSIGNED_BYTE, b.source);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR);
            if (!b._powerOf2) {
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE);
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE)
            } else {
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT);
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT)
            }
            h.bindTexture(h.TEXTURE_2D, null)
        }
    };
    g.WebGLRenderer.destroyTexture = function (b) {
        var h = g.gl;
        if (b._glTexture) {
            b._glTexture = h.createTexture();
            h.deleteTexture(h.TEXTURE_2D, b._glTexture)
        }
    };
    g.WebGLRenderer.prototype.resize = function (h, b) {
        this.width = h;
        this.height = b;
        this.view.width = h;
        this.view.height = b;
        this.gl.viewport(0, 0, this.width, this.height);
        g.projection.x = this.width / 2;
        g.projection.y = this.height / 2
    };
    g.WebGLRenderer.prototype.handleContextLost = function (b) {
        b.preventDefault();
        this.contextLost = true
    };
    g.WebGLRenderer.prototype.handleContextRestored = function (k) {
        this.gl = this.view.getContext("experimental-webgl", {alpha: true});
        this.initShaders();
        for (var h in g.TextureCache) {
            var j = g.TextureCache[h].baseTexture;
            j._glTexture = null;
            g.WebGLRenderer.updateTexture(j)
        }
        for (var b = 0; b < this.batchs.length; b++) {
            this.batchs[b].restoreLostContext(this.gl);
            this.batchs[b].dirty = true
        }
        g._restoreBatchs(this.gl);
        this.contextLost = false
    };
    g.WebGLRenderGroup = function (b) {
        this.gl = b;
        this.root;
        this.backgroundColor;
        this.batchs = [];
        this.toRemove = []
    };
    g.WebGLRenderGroup.prototype.constructor = g.WebGLRenderGroup;
    g.WebGLRenderGroup.prototype.setRenderable = function (b) {
        if (this.root) {
            this.removeDisplayObjectAndChildren(this.root)
        }
        b.worldVisible = b.visible;
        this.root = b;
        this.addDisplayObjectAndChildren(b)
    };
    g.WebGLRenderGroup.prototype.render = function (b) {
        g.WebGLRenderer.updateTextures();
        var l = this.gl;
        l.uniform2f(g.shaderProgram.projectionVector, b.x, b.y);
        l.blendFunc(l.ONE, l.ONE_MINUS_SRC_ALPHA);
        var k;
        for (var j = 0; j < this.batchs.length; j++) {
            k = this.batchs[j];
            if (k instanceof g.WebGLBatch) {
                this.batchs[j].render();
                continue
            }
            var h = k.vcount === g.visibleCount;
            if (k instanceof g.TilingSprite) {
                if (h) {
                    this.renderTilingSprite(k, b)
                }
            } else {
                if (k instanceof g.Strip) {
                    if (h) {
                        this.renderStrip(k, b)
                    }
                } else {
                    if (k instanceof g.Graphics) {
                        if (h && k.renderable) {
                            g.WebGLGraphics.renderGraphics(k, b)
                        }
                    } else {
                        if (k instanceof g.FilterBlock) {
                            if (k.open) {
                                l.enable(l.STENCIL_TEST);
                                l.colorMask(false, false, false, false);
                                l.stencilFunc(l.ALWAYS, 1, 255);
                                l.stencilOp(l.KEEP, l.KEEP, l.REPLACE);
                                g.WebGLGraphics.renderGraphics(k.mask, b);
                                l.colorMask(true, true, true, false);
                                l.stencilFunc(l.NOTEQUAL, 0, 255);
                                l.stencilOp(l.KEEP, l.KEEP, l.KEEP)
                            } else {
                                l.disable(l.STENCIL_TEST)
                            }
                        }
                    }
                }
            }
        }
    };
    g.WebGLRenderGroup.prototype.handleFilter = function (h, b) {
    };
    g.WebGLRenderGroup.prototype.renderSpecific = function (p, o) {
        g.WebGLRenderer.updateTextures();
        var m = this.gl;
        m.uniform2f(g.shaderProgram.projectionVector, o.x, o.y);
        var u;
        var j;
        var n;
        var v;
        var t = p.first;
        while (t._iNext) {
            t = t._iNext;
            if (t.renderable && t.__renderGroup) {
                break
            }
        }
        var r = t.batch;
        if (t instanceof g.Sprite) {
            r = t.batch;
            var q = r.head;
            var l = q;
            if (q == t) {
                u = 0
            } else {
                u = 1;
                while (q.__next != t) {
                    u++;
                    q = q.__next
                }
            }
        } else {
            r = t
        }
        var b = p;
        var h;
        var s = p;
        while (s.children.length > 0) {
            s = s.children[s.children.length - 1];
            if (s.renderable) {
                b = s
            }
        }
        if (b instanceof g.Sprite) {
            h = b.batch;
            var q = h.head;
            if (q == b) {
                n = 0
            } else {
                n = 1;
                while (q.__next != b) {
                    n++;
                    q = q.__next
                }
            }
        } else {
            h = b
        }
        if (r == h) {
            if (r instanceof g.WebGLBatch) {
                r.render(u, n + 1)
            } else {
                this.renderSpecial(r, o)
            }
            return
        }
        j = this.batchs.indexOf(r);
        v = this.batchs.indexOf(h);
        if (r instanceof g.WebGLBatch) {
            r.render(u)
        } else {
            this.renderSpecial(r, o)
        }
        for (var k = j + 1; k < v; k++) {
            renderable = this.batchs[k];
            if (renderable instanceof g.WebGLBatch) {
                this.batchs[k].render()
            } else {
                this.renderSpecial(renderable, o)
            }
        }
        if (h instanceof g.WebGLBatch) {
            h.render(0, n + 1)
        } else {
            this.renderSpecial(h, o)
        }
    };
    g.WebGLRenderGroup.prototype.renderSpecial = function (i, b) {
        var h = i.vcount === g.visibleCount;
        if (i instanceof g.TilingSprite) {
            if (h) {
                this.renderTilingSprite(i, b)
            }
        } else {
            if (i instanceof g.Strip) {
                if (h) {
                    this.renderStrip(i, b)
                }
            } else {
                if (i instanceof g.CustomRenderable) {
                    if (h) {
                        i.renderWebGL(this, b)
                    }
                } else {
                    if (i instanceof g.Graphics) {
                        if (h && i.renderable) {
                            g.WebGLGraphics.renderGraphics(i, b)
                        }
                    } else {
                        if (i instanceof g.FilterBlock) {
                            var j = g.gl;
                            if (i.open) {
                                j.enable(j.STENCIL_TEST);
                                j.colorMask(false, false, false, false);
                                j.stencilFunc(j.ALWAYS, 1, 255);
                                j.stencilOp(j.KEEP, j.KEEP, j.REPLACE);
                                g.WebGLGraphics.renderGraphics(i.mask, b);
                                j.colorMask(true, true, true, true);
                                j.stencilFunc(j.NOTEQUAL, 0, 255);
                                j.stencilOp(j.KEEP, j.KEEP, j.KEEP)
                            } else {
                                j.disable(j.STENCIL_TEST)
                            }
                        }
                    }
                }
            }
        }
    };
    g.WebGLRenderGroup.prototype.updateTexture = function (i) {
        this.removeObject(i);
        var b = i.first;
        while (b != this.root) {
            b = b._iPrev;
            if (b.renderable && b.__renderGroup) {
                break
            }
        }
        var h = i.last;
        while (h._iNext) {
            h = h._iNext;
            if (h.renderable && h.__renderGroup) {
                break
            }
        }
        this.insertObject(i, b, h)
    };
    g.WebGLRenderGroup.prototype.addFilterBlocks = function (j, h) {
        j.__renderGroup = this;
        h.__renderGroup = this;
        var b = j;
        while (b != this.root) {
            b = b._iPrev;
            if (b.renderable && b.__renderGroup) {
                break
            }
        }
        this.insertAfter(j, b);
        var i = h;
        while (i != this.root) {
            i = i._iPrev;
            if (i.renderable && i.__renderGroup) {
                break
            }
        }
        this.insertAfter(h, i)
    };
    g.WebGLRenderGroup.prototype.removeFilterBlocks = function (h, b) {
        this.removeObject(h);
        this.removeObject(b)
    };
    g.WebGLRenderGroup.prototype.addDisplayObjectAndChildren = function (k) {
        if (k.__renderGroup) {
            k.__renderGroup.removeDisplayObjectAndChildren(k)
        }
        var b = k.first;
        while (b != this.root.first) {
            b = b._iPrev;
            if (b.renderable && b.__renderGroup) {
                break
            }
        }
        var h = k.last;
        while (h._iNext) {
            h = h._iNext;
            if (h.renderable && h.__renderGroup) {
                break
            }
        }
        var j = k.first;
        var i = k.last._iNext;
        do {
            j.__renderGroup = this;
            if (j.renderable) {
                this.insertObject(j, b, h);
                b = j
            }
            j = j._iNext
        } while (j != i)
    };
    g.WebGLRenderGroup.prototype.removeDisplayObjectAndChildren = function (b) {
        if (b.__renderGroup != this) {
            return
        }
        var h = b.last;
        do {
            b.__renderGroup = null;
            if (b.renderable) {
                this.removeObject(b)
            }
            b = b._iNext
        } while (b)
    };
    g.WebGLRenderGroup.prototype.insertObject = function (m, l, n) {
        var b = l;
        var h = n;
        if (m instanceof g.Sprite) {
            var o;
            var i;
            if (b instanceof g.Sprite) {
                o = b.batch;
                if (o) {
                    if (o.texture == m.texture.baseTexture && o.blendMode == m.blendMode) {
                        o.insertAfter(m, b);
                        return
                    }
                }
            } else {
                o = b
            }
            if (h) {
                if (h instanceof g.Sprite) {
                    i = h.batch;
                    if (i) {
                        if (i.texture == m.texture.baseTexture && i.blendMode == m.blendMode) {
                            i.insertBefore(m, h);
                            return
                        } else {
                            if (i == o) {
                                var p = o.split(h);
                                var j = g.WebGLRenderer.getBatch();
                                var k = this.batchs.indexOf(o);
                                j.init(m);
                                this.batchs.splice(k + 1, 0, j, p);
                                return
                            }
                        }
                    }
                } else {
                    i = h
                }
            }
            var j = g.WebGLRenderer.getBatch();
            j.init(m);
            if (o) {
                var k = this.batchs.indexOf(o);
                this.batchs.splice(k + 1, 0, j)
            } else {
                this.batchs.push(j)
            }
            return
        } else {
            if (m instanceof g.TilingSprite) {
                this.initTilingSprite(m)
            } else {
                if (m instanceof g.Strip) {
                    this.initStrip(m)
                } else {
                    if (m) {
                    }
                }
            }
        }
        this.insertAfter(m, b)
    };
    g.WebGLRenderGroup.prototype.insertAfter = function (i, k) {
        if (k instanceof g.Sprite) {
            var j = k.batch;
            if (j) {
                if (j.tail == k) {
                    var h = this.batchs.indexOf(j);
                    this.batchs.splice(h + 1, 0, i)
                } else {
                    var b = j.split(k.__next);
                    var h = this.batchs.indexOf(j);
                    this.batchs.splice(h + 1, 0, i, b)
                }
            } else {
                this.batchs.push(i)
            }
        } else {
            var h = this.batchs.indexOf(k);
            this.batchs.splice(h + 1, 0, i)
        }
    };
    g.WebGLRenderGroup.prototype.removeObject = function (j) {
        var i;
        if (j instanceof g.Sprite) {
            var h = j.batch;
            if (!h) {
                return
            }
            h.remove(j);
            if (h.size == 0) {
                i = h
            }
        } else {
            i = j
        }
        if (i) {
            var b = this.batchs.indexOf(i);
            if (b == -1) {
                return
            }
            if (b == 0 || b == this.batchs.length - 1) {
                this.batchs.splice(b, 1);
                if (i instanceof g.WebGLBatch) {
                    g.WebGLRenderer.returnBatch(i)
                }
                return
            }
            if (this.batchs[b - 1] instanceof g.WebGLBatch && this.batchs[b + 1] instanceof g.WebGLBatch) {
                if (this.batchs[b - 1].texture == this.batchs[b + 1].texture && this.batchs[b - 1].blendMode == this.batchs[b + 1].blendMode) {
                    this.batchs[b - 1].merge(this.batchs[b + 1]);
                    if (i instanceof g.WebGLBatch) {
                        g.WebGLRenderer.returnBatch(i)
                    }
                    g.WebGLRenderer.returnBatch(this.batchs[b + 1]);
                    this.batchs.splice(b, 2);
                    return
                }
            }
            this.batchs.splice(b, 1);
            if (i instanceof g.WebGLBatch) {
                g.WebGLRenderer.returnBatch(i)
            }
        }
    };
    g.WebGLRenderGroup.prototype.initTilingSprite = function (b) {
        var h = this.gl;
        b.verticies = new Float32Array([0, 0, b.width, 0, b.width, b.height, 0, b.height]);
        b.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        b.colors = new Float32Array([1, 1, 1, 1]);
        b.indices = new Uint16Array([0, 1, 3, 2]);
        b._vertexBuffer = h.createBuffer();
        b._indexBuffer = h.createBuffer();
        b._uvBuffer = h.createBuffer();
        b._colorBuffer = h.createBuffer();
        h.bindBuffer(h.ARRAY_BUFFER, b._vertexBuffer);
        h.bufferData(h.ARRAY_BUFFER, b.verticies, h.STATIC_DRAW);
        h.bindBuffer(h.ARRAY_BUFFER, b._uvBuffer);
        h.bufferData(h.ARRAY_BUFFER, b.uvs, h.DYNAMIC_DRAW);
        h.bindBuffer(h.ARRAY_BUFFER, b._colorBuffer);
        h.bufferData(h.ARRAY_BUFFER, b.colors, h.STATIC_DRAW);
        h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, b._indexBuffer);
        h.bufferData(h.ELEMENT_ARRAY_BUFFER, b.indices, h.STATIC_DRAW);
        if (b.texture.baseTexture._glTexture) {
            h.bindTexture(h.TEXTURE_2D, b.texture.baseTexture._glTexture);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.REPEAT);
            h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.REPEAT);
            b.texture.baseTexture._powerOf2 = true
        } else {
            b.texture.baseTexture._powerOf2 = true
        }
    };
    g.WebGLRenderGroup.prototype.renderStrip = function (i, h) {
        var j = this.gl;
        var k = g.shaderProgram;
        j.useProgram(g.stripShaderProgram);
        var b = g.mat3.clone(i.worldTransform);
        g.mat3.transpose(b);
        j.uniformMatrix3fv(g.stripShaderProgram.translationMatrix, false, b);
        j.uniform2f(g.stripShaderProgram.projectionVector, h.x, h.y);
        j.uniform1f(g.stripShaderProgram.alpha, i.worldAlpha);
        if (!i.dirty) {
            j.bindBuffer(j.ARRAY_BUFFER, i._vertexBuffer);
            j.bufferSubData(j.ARRAY_BUFFER, 0, i.verticies);
            j.vertexAttribPointer(k.vertexPositionAttribute, 2, j.FLOAT, false, 0, 0);
            j.bindBuffer(j.ARRAY_BUFFER, i._uvBuffer);
            j.vertexAttribPointer(k.textureCoordAttribute, 2, j.FLOAT, false, 0, 0);
            j.activeTexture(j.TEXTURE0);
            j.bindTexture(j.TEXTURE_2D, i.texture.baseTexture._glTexture);
            j.bindBuffer(j.ARRAY_BUFFER, i._colorBuffer);
            j.vertexAttribPointer(k.colorAttribute, 1, j.FLOAT, false, 0, 0);
            j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, i._indexBuffer)
        } else {
            i.dirty = false;
            j.bindBuffer(j.ARRAY_BUFFER, i._vertexBuffer);
            j.bufferData(j.ARRAY_BUFFER, i.verticies, j.STATIC_DRAW);
            j.vertexAttribPointer(k.vertexPositionAttribute, 2, j.FLOAT, false, 0, 0);
            j.bindBuffer(j.ARRAY_BUFFER, i._uvBuffer);
            j.bufferData(j.ARRAY_BUFFER, i.uvs, j.STATIC_DRAW);
            j.vertexAttribPointer(k.textureCoordAttribute, 2, j.FLOAT, false, 0, 0);
            j.activeTexture(j.TEXTURE0);
            j.bindTexture(j.TEXTURE_2D, i.texture.baseTexture._glTexture);
            j.bindBuffer(j.ARRAY_BUFFER, i._colorBuffer);
            j.bufferData(j.ARRAY_BUFFER, i.colors, j.STATIC_DRAW);
            j.vertexAttribPointer(k.colorAttribute, 1, j.FLOAT, false, 0, 0);
            j.bindBuffer(j.ELEMENT_ARRAY_BUFFER, i._indexBuffer);
            j.bufferData(j.ELEMENT_ARRAY_BUFFER, i.indices, j.STATIC_DRAW)
        }
        j.drawElements(j.TRIANGLE_STRIP, i.indices.length, j.UNSIGNED_SHORT, 0);
        j.useProgram(g.shaderProgram)
    };
    g.WebGLRenderGroup.prototype.renderTilingSprite = function (o, l) {
        var j = this.gl;
        var b = g.shaderProgram;
        var i = o.tilePosition;
        var p = o.tileScale;
        var k = i.x / o.texture.baseTexture.width;
        var h = i.y / o.texture.baseTexture.height;
        var n = (o.width / o.texture.baseTexture.width) / p.x;
        var m = (o.height / o.texture.baseTexture.height) / p.y;
        o.uvs[0] = 0 - k;
        o.uvs[1] = 0 - h;
        o.uvs[2] = (1 * n) - k;
        o.uvs[3] = 0 - h;
        o.uvs[4] = (1 * n) - k;
        o.uvs[5] = (1 * m) - h;
        o.uvs[6] = 0 - k;
        o.uvs[7] = (1 * m) - h;
        j.bindBuffer(j.ARRAY_BUFFER, o._uvBuffer);
        j.bufferSubData(j.ARRAY_BUFFER, 0, o.uvs);
        this.renderStrip(o, l)
    };
    g.WebGLRenderGroup.prototype.initStrip = function (b) {
        var h = this.gl;
        var i = this.shaderProgram;
        b._vertexBuffer = h.createBuffer();
        b._indexBuffer = h.createBuffer();
        b._uvBuffer = h.createBuffer();
        b._colorBuffer = h.createBuffer();
        h.bindBuffer(h.ARRAY_BUFFER, b._vertexBuffer);
        h.bufferData(h.ARRAY_BUFFER, b.verticies, h.DYNAMIC_DRAW);
        h.bindBuffer(h.ARRAY_BUFFER, b._uvBuffer);
        h.bufferData(h.ARRAY_BUFFER, b.uvs, h.STATIC_DRAW);
        h.bindBuffer(h.ARRAY_BUFFER, b._colorBuffer);
        h.bufferData(h.ARRAY_BUFFER, b.colors, h.STATIC_DRAW);
        h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, b._indexBuffer);
        h.bufferData(h.ELEMENT_ARRAY_BUFFER, b.indices, h.STATIC_DRAW)
    };
    g.shaderFragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "gl_FragColor = gl_FragColor * vColor;", "}"];
    g.shaderVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "varying vec2 vTextureCoord;", "varying float vColor;", "void main(void) {", "gl_Position = vec4( aVertexPosition.x / projectionVector.x -1.0, aVertexPosition.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "vTextureCoord = aTextureCoord;", "vColor = aColor;", "}"];
    g.stripShaderFragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y));", "gl_FragColor = gl_FragColor * alpha;", "}"];
    g.stripShaderVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "varying vec2 vTextureCoord;", "varying float vColor;", "void main(void) {", "vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "vTextureCoord = aTextureCoord;", "vColor = aColor;", "}"];
    g.primitiveShaderFragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "gl_FragColor = vColor;", "}"];
    g.primitiveShaderVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform float alpha;", "varying vec4 vColor;", "void main(void) {", "vec3 v = translationMatrix * vec3(aVertexPosition, 1.0);", "gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "vColor = aColor  * alpha;", "}"];
    g.initPrimitiveShader = function () {
        var b = g.gl;
        var h = g.compileProgram(g.primitiveShaderVertexSrc, g.primitiveShaderFragmentSrc);
        b.useProgram(h);
        h.vertexPositionAttribute = b.getAttribLocation(h, "aVertexPosition");
        h.colorAttribute = b.getAttribLocation(h, "aColor");
        h.projectionVector = b.getUniformLocation(h, "projectionVector");
        h.translationMatrix = b.getUniformLocation(h, "translationMatrix");
        h.alpha = b.getUniformLocation(h, "alpha");
        g.primitiveProgram = h
    };
    g.initDefaultShader = function () {
        var b = this.gl;
        var h = g.compileProgram(g.shaderVertexSrc, g.shaderFragmentSrc);
        b.useProgram(h);
        h.vertexPositionAttribute = b.getAttribLocation(h, "aVertexPosition");
        h.projectionVector = b.getUniformLocation(h, "projectionVector");
        h.textureCoordAttribute = b.getAttribLocation(h, "aTextureCoord");
        h.colorAttribute = b.getAttribLocation(h, "aColor");
        h.samplerUniform = b.getUniformLocation(h, "uSampler");
        g.shaderProgram = h
    };
    g.initDefaultStripShader = function () {
        var b = this.gl;
        var h = g.compileProgram(g.stripShaderVertexSrc, g.stripShaderFragmentSrc);
        b.useProgram(h);
        h.vertexPositionAttribute = b.getAttribLocation(h, "aVertexPosition");
        h.projectionVector = b.getUniformLocation(h, "projectionVector");
        h.textureCoordAttribute = b.getAttribLocation(h, "aTextureCoord");
        h.translationMatrix = b.getUniformLocation(h, "translationMatrix");
        h.alpha = b.getUniformLocation(h, "alpha");
        h.colorAttribute = b.getAttribLocation(h, "aColor");
        h.projectionVector = b.getUniformLocation(h, "projectionVector");
        h.samplerUniform = b.getUniformLocation(h, "uSampler");
        g.stripShaderProgram = h
    };
    g.CompileVertexShader = function (h, b) {
        return g._CompileShader(h, b, h.VERTEX_SHADER)
    };
    g.CompileFragmentShader = function (h, b) {
        return g._CompileShader(h, b, h.FRAGMENT_SHADER)
    };
    g._CompileShader = function (k, j, i) {
        var h = j.join("\n");
        var b = k.createShader(i);
        k.shaderSource(b, h);
        k.compileShader(b);
        if (!k.getShaderParameter(b, k.COMPILE_STATUS)) {
            alert(k.getShaderInfoLog(b));
            return null
        }
        return b
    };
    g.compileProgram = function (b, i) {
        var k = g.gl;
        var h = g.CompileFragmentShader(k, i);
        var j = g.CompileVertexShader(k, b);
        var l = k.createProgram();
        k.attachShader(l, j);
        k.attachShader(l, h);
        k.linkProgram(l);
        if (!k.getProgramParameter(l, k.LINK_STATUS)) {
            alert("Could not initialise shaders")
        }
        return l
    };
    g.activateDefaultShader = function () {
        var b = g.gl;
        var h = g.shaderProgram;
        b.useProgram(h);
        b.enableVertexAttribArray(h.vertexPositionAttribute);
        b.enableVertexAttribArray(h.textureCoordAttribute);
        b.enableVertexAttribArray(h.colorAttribute)
    };
    g.activatePrimitiveShader = function () {
        var b = g.gl;
        b.disableVertexAttribArray(g.shaderProgram.textureCoordAttribute);
        b.disableVertexAttribArray(g.shaderProgram.colorAttribute);
        b.useProgram(g.primitiveProgram);
        b.enableVertexAttribArray(g.primitiveProgram.vertexPositionAttribute);
        b.enableVertexAttribArray(g.primitiveProgram.colorAttribute)
    };
    g.BitmapText = function (h, b) {
        g.DisplayObjectContainer.call(this);
        this.setText(h);
        this.setStyle(b);
        this.updateText();
        this.dirty = false
    };
    g.BitmapText.prototype = Object.create(g.DisplayObjectContainer.prototype);
    g.BitmapText.prototype.constructor = g.BitmapText;
    g.BitmapText.prototype.setText = function (b) {
        this.text = b || " ";
        this.dirty = true
    };
    g.BitmapText.prototype.setStyle = function (h) {
        h = h || {};
        h.align = h.align || "left";
        this.style = h;
        var b = h.font.split(" ");
        this.fontName = b[b.length - 1];
        this.fontSize = b.length >= 2 ? parseInt(b[b.length - 2], 10) : g.BitmapText.fonts[this.fontName].size;
        this.dirty = true
    };
    g.BitmapText.prototype.updateText = function () {
        var m = g.BitmapText.fonts[this.fontName];
        var q = new g.Point();
        var n = null;
        var p = [];
        var u = 0;
        var j = [];
        var t = 0;
        var k = this.fontSize / m.size;
        for (var l = 0; l < this.text.length; l++) {
            var s = this.text.charCodeAt(l);
            if (/(?:\r\n|\r|\n)/.test(this.text.charAt(l))) {
                j.push(q.x);
                u = Math.max(u, q.x);
                t++;
                q.x = 0;
                q.y += m.lineHeight;
                n = null;
                continue
            }
            var h = m.chars[s];
            if (!h) {
                continue
            }
            if (n && h[n]) {
                q.x += h.kerning[n]
            }
            p.push({texture: h.texture, line: t, charCode: s, position: new g.Point(q.x + h.xOffset, q.y + h.yOffset)});
            q.x += h.xAdvance;
            n = s
        }
        j.push(q.x);
        u = Math.max(u, q.x);
        var r = [];
        for (l = 0; l <= t; l++) {
            var b = 0;
            if (this.style.align == "right") {
                b = u - j[l]
            } else {
                if (this.style.align == "center") {
                    b = (u - j[l]) / 2
                }
            }
            r.push(b)
        }
        for (l = 0; l < p.length; l++) {
            var o = new g.Sprite(p[l].texture);
            o.position.x = (p[l].position.x + r[p[l].line]) * k;
            o.position.y = p[l].position.y * k;
            o.scale.x = o.scale.y = k;
            this.addChild(o)
        }
        this.width = u * k;
        this.height = (q.y + m.lineHeight) * k
    };
    g.BitmapText.prototype.updateTransform = function () {
        if (this.dirty) {
            while (this.children.length > 0) {
                this.removeChild(this.getChildAt(0))
            }
            this.updateText();
            this.dirty = false
        }
        g.DisplayObjectContainer.prototype.updateTransform.call(this)
    };
    g.BitmapText.fonts = {};
    g.Text = function (h, b) {
        this.canvas = document.createElement("canvas");
        this.context = this.canvas.getContext("2d");
        g.Sprite.call(this, g.Texture.fromCanvas(this.canvas));
        this.setText(h);
        this.setStyle(b);
        this.updateText();
        this.dirty = false
    };
    g.Text.prototype = Object.create(g.Sprite.prototype);
    g.Text.prototype.constructor = g.Text;
    g.Text.prototype.setStyle = function (b) {
        b = b || {};
        b.font = b.font || "bold 20pt Arial";
        b.fill = b.fill || "black";
        b.align = b.align || "left";
        b.stroke = b.stroke || "black";
        b.strokeThickness = b.strokeThickness || 0;
        b.wordWrap = b.wordWrap || false;
        b.wordWrapWidth = b.wordWrapWidth || 100;
        this.style = b;
        this.dirty = true
    };
    g.Sprite.prototype.setText = function (b) {
        this.text = b.toString() || " ";
        this.dirty = true
    };
    g.Text.prototype.updateText = function () {
        this.context.font = this.style.font;
        var m = this.text;
        if (this.style.wordWrap) {
            m = this.wordWrap(this.text)
        }
        var l = m.split(/(?:\r\n|\r|\n)/);
        var j = [];
        var h = 0;
        for (var n = 0; n < l.length; n++) {
            var b = this.context.measureText(l[n]).width;
            j[n] = b;
            h = Math.max(h, b)
        }
        this.canvas.width = h + this.style.strokeThickness;
        var o = this.determineFontHeight("font: " + this.style.font + ";") + this.style.strokeThickness;
        this.canvas.height = o * l.length;
        this.context.fillStyle = this.style.fill;
        this.context.font = this.style.font;
        this.context.strokeStyle = this.style.stroke;
        this.context.lineWidth = this.style.strokeThickness;
        this.context.textBaseline = "top";
        for (n = 0; n < l.length; n++) {
            var k = new g.Point(this.style.strokeThickness / 2, this.style.strokeThickness / 2 + n * o);
            if (this.style.align == "right") {
                k.x += h - j[n]
            } else {
                if (this.style.align == "center") {
                    k.x += (h - j[n]) / 2
                }
            }
            if (this.style.stroke && this.style.strokeThickness) {
                this.context.strokeText(l[n], k.x, k.y)
            }
            if (this.style.fill) {
                this.context.fillText(l[n], k.x, k.y)
            }
        }
        this.updateTexture()
    };
    g.Text.prototype.updateTexture = function () {
        this.texture.baseTexture.width = this.canvas.width;
        this.texture.baseTexture.height = this.canvas.height;
        this.texture.frame.width = this.canvas.width;
        this.texture.frame.height = this.canvas.height;
        this._width = this.canvas.width;
        this._height = this.canvas.height;
        g.texturesToUpdate.push(this.texture.baseTexture)
    };
    g.Text.prototype.updateTransform = function () {
        if (this.dirty) {
            this.updateText();
            this.dirty = false
        }
        g.Sprite.prototype.updateTransform.call(this)
    };
    g.Text.prototype.determineFontHeight = function (k) {
        var h = g.Text.heightCache[k];
        if (!h) {
            var b = document.getElementsByTagName("body")[0];
            var j = document.createElement("div");
            var i = document.createTextNode("M");
            j.appendChild(i);
            j.setAttribute("style", k + ";position:absolute;top:0;left:0");
            b.appendChild(j);
            h = j.offsetHeight;
            g.Text.heightCache[k] = h;
            b.removeChild(j)
        }
        return h
    };
    g.Text.prototype.wordWrap = function (m) {
        var k = function (n, r, s, i, o) {
            var q = Math.floor((i - s) / 2) + s;
            if (q == s) {
                return 1
            }
            if (n.measureText(r.substring(0, q)).width <= o) {
                if (n.measureText(r.substring(0, q + 1)).width > o) {
                    return q
                } else {
                    return arguments.callee(n, r, q, i, o)
                }
            } else {
                return arguments.callee(n, r, s, q, o)
            }
        };
        var l = function (i, o, n) {
            if (i.measureText(o).width <= n || o.length < 1) {
                return o
            }
            var p = k(i, o, 0, o.length, n);
            return o.substring(0, p) + "\n" + arguments.callee(i, o.substring(p), n)
        };
        var b = "";
        var h = m.split("\n");
        for (var j = 0; j < h.length; j++) {
            b += l(this.context, h[j], this.style.wordWrapWidth) + "\n"
        }
        return b
    };
    g.Text.prototype.destroy = function (b) {
        if (b) {
            this.texture.destroy()
        }
    };
    g.Text.heightCache = {};
    g.BaseTextureCache = {};
    g.texturesToUpdate = [];
    g.texturesToDestroy = [];
    g.BaseTexture = function (h) {
        g.EventTarget.call(this);
        this.width = 100;
        this.height = 100;
        this.hasLoaded = false;
        this.source = h;
        if (!h) {
            return
        }
        if (this.source instanceof Image || this.source instanceof HTMLImageElement) {
            if (this.source.complete) {
                this.hasLoaded = true;
                this.width = this.source.width;
                this.height = this.source.height;
                g.texturesToUpdate.push(this)
            } else {
                var b = this;
                this.source.onload = function () {
                    b.hasLoaded = true;
                    b.width = b.source.width;
                    b.height = b.source.height;
                    g.texturesToUpdate.push(b);
                    b.dispatchEvent({type: "loaded", content: b})
                }
            }
        } else {
            this.hasLoaded = true;
            this.width = this.source.width;
            this.height = this.source.height;
            g.texturesToUpdate.push(this)
        }
        this._powerOf2 = false
    };
    g.BaseTexture.prototype.constructor = g.BaseTexture;
    g.BaseTexture.prototype.destroy = function () {
        if (this.source instanceof Image) {
            this.source.src = null
        }
        this.source = null;
        g.texturesToDestroy.push(this)
    };
    g.BaseTexture.fromImage = function (h, b) {
        var i = g.BaseTextureCache[h];
        if (!i) {
            var j = new Image();
            if (b) {
                j.crossOrigin = ""
            }
            j.src = h;
            i = new g.BaseTexture(j);
            g.BaseTextureCache[h] = i
        }
        return i
    };
    g.TextureCache = {};
    g.FrameCache = {};
    g.Texture = function (h, i) {
        g.EventTarget.call(this);
        if (!i) {
            this.noFrame = true;
            i = new g.Rectangle(0, 0, 1, 1)
        }
        if (h instanceof g.Texture) {
            h = h.baseTexture
        }
        this.baseTexture = h;
        this.frame = i;
        this.trim = new g.Point();
        this.scope = this;
        if (h.hasLoaded) {
            if (this.noFrame) {
                i = new g.Rectangle(0, 0, h.width, h.height)
            }
            this.setFrame(i)
        } else {
            var b = this;
            h.addEventListener("loaded", function () {
                b.onBaseTextureLoaded()
            })
        }
    };
    g.Texture.prototype.constructor = g.Texture;
    g.Texture.prototype.onBaseTextureLoaded = function (h) {
        var b = this.baseTexture;
        b.removeEventListener("loaded", this.onLoaded);
        if (this.noFrame) {
            this.frame = new g.Rectangle(0, 0, b.width, b.height)
        }
        this.noFrame = false;
        this.width = this.frame.width;
        this.height = this.frame.height;
        this.scope.dispatchEvent({type: "update", content: this})
    };
    g.Texture.prototype.destroy = function (b) {
        if (b) {
            this.baseTexture.destroy()
        }
    };
    g.Texture.prototype.setFrame = function (b) {
        this.frame = b;
        this.width = b.width;
        this.height = b.height;
        if (b.x + b.width > this.baseTexture.width || b.y + b.height > this.baseTexture.height) {
            throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this)
        }
        this.updateFrame = true;
        g.Texture.frameUpdates.push(this)
    };
    g.Texture.fromImage = function (h, b) {
        var i = g.TextureCache[h];
        if (!i) {
            i = new g.Texture(g.BaseTexture.fromImage(h, b));
            g.TextureCache[h] = i
        }
        return i
    };
    g.Texture.fromFrame = function (h) {
        var b = g.TextureCache[h];
        if (!b) {
            throw new Error("The frameId '" + h + "' does not exist in the texture cache " + this)
        }
        return b
    };
    g.Texture.fromCanvas = function (b) {
        var h = new g.BaseTexture(b);
        return new g.Texture(h)
    };
    g.Texture.addTextureToCache = function (b, h) {
        g.TextureCache[h] = b
    };
    g.Texture.removeTextureFromCache = function (h) {
        var b = g.TextureCache[h];
        g.TextureCache[h] = null;
        return b
    };
    g.Texture.frameUpdates = [];
    g.RenderTexture = function (h, b) {
        g.EventTarget.call(this);
        this.width = h || 100;
        this.height = b || 100;
        this.indetityMatrix = g.mat3.create();
        this.frame = new g.Rectangle(0, 0, this.width, this.height);
        if (g.gl) {
            this.initWebGL()
        } else {
            this.initCanvas()
        }
    };
    g.RenderTexture.prototype = Object.create(g.Texture.prototype);
    g.RenderTexture.prototype.constructor = g.RenderTexture;
    g.RenderTexture.prototype.initWebGL = function () {
        var b = g.gl;
        this.glFramebuffer = b.createFramebuffer();
        b.bindFramebuffer(b.FRAMEBUFFER, this.glFramebuffer);
        this.glFramebuffer.width = this.width;
        this.glFramebuffer.height = this.height;
        this.baseTexture = new g.BaseTexture();
        this.baseTexture.width = this.width;
        this.baseTexture.height = this.height;
        this.baseTexture._glTexture = b.createTexture();
        b.bindTexture(b.TEXTURE_2D, this.baseTexture._glTexture);
        b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, this.width, this.height, 0, b.RGBA, b.UNSIGNED_BYTE, null);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE);
        this.baseTexture.isRender = true;
        b.bindFramebuffer(b.FRAMEBUFFER, this.glFramebuffer);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, this.baseTexture._glTexture, 0);
        this.projection = new g.Point(this.width / 2, this.height / 2);
        this.render = this.renderWebGL
    };
    g.RenderTexture.prototype.resize = function (h, b) {
        this.width = h;
        this.height = b;
        if (g.gl) {
            this.projection.x = this.width / 2;
            this.projection.y = this.height / 2;
            var i = g.gl;
            i.bindTexture(i.TEXTURE_2D, this.baseTexture._glTexture);
            i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, this.width, this.height, 0, i.RGBA, i.UNSIGNED_BYTE, null)
        } else {
            this.frame.width = this.width;
            this.frame.height = this.height;
            this.renderer.resize(this.width, this.height)
        }
    };
    g.RenderTexture.prototype.initCanvas = function () {
        this.renderer = new g.CanvasRenderer(this.width, this.height, null, 0);
        this.baseTexture = new g.BaseTexture(this.renderer.view);
        this.frame = new g.Rectangle(0, 0, this.width, this.height);
        this.render = this.renderCanvas
    };
    g.RenderTexture.prototype.renderWebGL = function (p, n, o) {
        var m = g.gl;
        m.colorMask(true, true, true, true);
        m.viewport(0, 0, this.width, this.height);
        m.bindFramebuffer(m.FRAMEBUFFER, this.glFramebuffer);
        if (o) {
            m.clearColor(0, 0, 0, 0);
            m.clear(m.COLOR_BUFFER_BIT)
        }
        var h = p.children;
        var b = p.worldTransform;
        p.worldTransform = g.mat3.create();
        p.worldTransform[4] = -1;
        p.worldTransform[5] = this.projection.y * 2;
        if (n) {
            p.worldTransform[2] = n.x;
            p.worldTransform[5] -= n.y
        }
        g.visibleCount++;
        p.vcount = g.visibleCount;
        for (var l = 0, k = h.length; l < k; l++) {
            h[l].updateTransform()
        }
        var q = p.__renderGroup;
        if (q) {
            if (p == q.root) {
                q.render(this.projection)
            } else {
                q.renderSpecific(p, this.projection)
            }
        } else {
            if (!this.renderGroup) {
                this.renderGroup = new g.WebGLRenderGroup(m)
            }
            this.renderGroup.setRenderable(p);
            this.renderGroup.render(this.projection)
        }
        p.worldTransform = b
    };
    g.RenderTexture.prototype.renderCanvas = function (n, h, b) {
        var m = n.children;
        n.worldTransform = g.mat3.create();
        if (h) {
            n.worldTransform[2] = h.x;
            n.worldTransform[5] = h.y
        }
        for (var l = 0, k = m.length; l < k; l++) {
            m[l].updateTransform()
        }
        if (b) {
            this.renderer.context.clearRect(0, 0, this.width, this.height)
        }
        this.renderer.renderDisplayObject(n);
        this.renderer.context.setTransform(1, 0, 0, 1, 0, 0)
    };
    g.EventTarget = function () {
        var b = {};
        this.addEventListener = this.on = function (h, i) {
            if (b[h] === undefined) {
                b[h] = []
            }
            if (b[h].indexOf(i) === -1) {
                b[h].push(i)
            }
        };
        this.dispatchEvent = this.emit = function (h) {
            for (var i in b[h.type]) {
                b[h.type][i](h)
            }
        };
        this.removeEventListener = this.off = function (i, j) {
            var h = b[i].indexOf(j);
            if (h !== -1) {
                b[i].splice(h, 1)
            }
        }
    };
    g.PolyK = {};
    g.PolyK.Triangulate = function (q) {
        var E = true;
        var r = q.length >> 1;
        if (r < 3) {
            return []
        }
        var B = [];
        var o = [];
        for (var z = 0; z < r; z++) {
            o.push(z)
        }
        var z = 0;
        var u = r;
        while (u > 3) {
            var v = o[(z + 0) % u];
            var t = o[(z + 1) % u];
            var s = o[(z + 2) % u];
            var m = q[2 * v], k = q[2 * v + 1];
            var C = q[2 * t], A = q[2 * t + 1];
            var h = q[2 * s], b = q[2 * s + 1];
            var l = false;
            if (g.PolyK._convex(m, k, C, A, h, b, E)) {
                l = true;
                for (var w = 0; w < u; w++) {
                    var D = o[w];
                    if (D == v || D == t || D == s) {
                        continue
                    }
                    if (g.PolyK._PointInTriangle(q[2 * D], q[2 * D + 1], m, k, C, A, h, b)) {
                        l = false;
                        break
                    }
                }
            }
            if (l) {
                B.push(v, t, s);
                o.splice((z + 1) % u, 1);
                u--;
                z = 0
            } else {
                if (z++ > 3 * u) {
                    if (E) {
                        var B = [];
                        o = [];
                        for (var z = 0; z < r; z++) {
                            o.push(z)
                        }
                        z = 0;
                        u = r;
                        E = false
                    } else {
                        console.log("PIXI Warning: shape too complex to fill");
                        return []
                    }
                }
            }
        }
        B.push(o[0], o[1], o[2]);
        return B
    };
    g.PolyK._PointInTriangle = function (w, t, q, p, F, E, m, k) {
        var j = m - q;
        var i = k - p;
        var o = F - q;
        var n = E - p;
        var D = w - q;
        var B = t - p;
        var C = j * j + i * i;
        var A = j * o + i * n;
        var z = j * D + i * B;
        var h = o * o + n * n;
        var b = o * D + n * B;
        var l = 1 / (C * h - A * A);
        var s = (h * z - A * b) * l;
        var r = (C * b - A * z) * l;
        return (s >= 0) && (r >= 0) && (s + r < 1)
    };
    g.PolyK._convex = function (j, i, l, k, b, m, h) {
        return ((i - k) * (b - l) + (l - j) * (m - k) >= 0) == h
    };
    d.Camera = function (i, l, h, k, j, b) {
        this.game = i;
        this.world = i.world;
        this.id = 0;
        this.view = new d.Rectangle(h, k, j, b);
        this.screenView = new d.Rectangle(h, k, j, b);
        this.bounds = new d.Rectangle(h, k, j, b);
        this.deadzone = null;
        this.visible = true;
        this.atLimit = {x: false, y: false};
        this.target = null;
        this._edge = 0;
        this.displayObject = null
    };
    d.Camera.FOLLOW_LOCKON = 0;
    d.Camera.FOLLOW_PLATFORMER = 1;
    d.Camera.FOLLOW_TOPDOWN = 2;
    d.Camera.FOLLOW_TOPDOWN_TIGHT = 3;
    d.Camera.prototype = {
        follow: function (l, j) {
            if (typeof j === "undefined") {
                j = d.Camera.FOLLOW_LOCKON
            }
            this.target = l;
            var k;
            switch (j) {
                case d.Camera.FOLLOW_PLATFORMER:
                    var b = this.width / 8;
                    var i = this.height / 3;
                    this.deadzone = new d.Rectangle((this.width - b) / 2, (this.height - i) / 2 - i * 0.25, b, i);
                    break;
                case d.Camera.FOLLOW_TOPDOWN:
                    k = Math.max(this.width, this.height) / 4;
                    this.deadzone = new d.Rectangle((this.width - k) / 2, (this.height - k) / 2, k, k);
                    break;
                case d.Camera.FOLLOW_TOPDOWN_TIGHT:
                    k = Math.max(this.width, this.height) / 8;
                    this.deadzone = new d.Rectangle((this.width - k) / 2, (this.height - k) / 2, k, k);
                    break;
                case d.Camera.FOLLOW_LOCKON:
                default:
                    this.deadzone = null;
                    break
            }
        }, focusOn: function (b) {
            this.setPosition(Math.round(b.x - this.view.halfWidth), Math.round(b.y - this.view.halfHeight))
        }, focusOnXY: function (b, h) {
            this.setPosition(Math.round(b - this.view.halfWidth), Math.round(h - this.view.halfHeight))
        }, update: function () {
            if (this.target) {
                this.updateTarget()
            }
            if (this.bounds) {
                this.checkBounds()
            }
            this.displayObject.position.x = -this.view.x;
            this.displayObject.position.y = -this.view.y
        }, updateTarget: function () {
            if (this.deadzone) {
                this._edge = this.target.x - this.deadzone.x;
                if (this.view.x > this._edge) {
                    this.view.x = this._edge
                }
                this._edge = this.target.x + this.target.width - this.deadzone.x - this.deadzone.width;
                if (this.view.x < this._edge) {
                    this.view.x = this._edge
                }
                this._edge = this.target.y - this.deadzone.y;
                if (this.view.y > this._edge) {
                    this.view.y = this._edge
                }
                this._edge = this.target.y + this.target.height - this.deadzone.y - this.deadzone.height;
                if (this.view.y < this._edge) {
                    this.view.y = this._edge
                }
            } else {
                this.focusOnXY(this.target.x, this.target.y)
            }
        }, setBoundsToWorld: function () {
            this.bounds.setTo(this.game.world.x, this.game.world.y, this.game.world.width, this.game.world.height)
        }, checkBounds: function () {
            this.atLimit.x = false;
            this.atLimit.y = false;
            if (this.view.x < this.bounds.x) {
                this.atLimit.x = true;
                this.view.x = this.bounds.x
            }
            if (this.view.x > this.bounds.right - this.width) {
                this.atLimit.x = true;
                this.view.x = (this.bounds.right - this.width) + 1
            }
            if (this.view.y < this.bounds.top) {
                this.atLimit.y = true;
                this.view.y = this.bounds.top
            }
            if (this.view.y > this.bounds.bottom - this.height) {
                this.atLimit.y = true;
                this.view.y = (this.bounds.bottom - this.height) + 1
            }
            this.view.floor()
        }, setPosition: function (b, h) {
            this.view.x = b;
            this.view.y = h;
            if (this.bounds) {
                this.checkBounds()
            }
        }, setSize: function (h, b) {
            this.view.width = h;
            this.view.height = b
        }
    };
    Object.defineProperty(d.Camera.prototype, "x", {
        get: function () {
            return this.view.x
        }, set: function (b) {
            this.view.x = b;
            if (this.bounds) {
                this.checkBounds()
            }
        }
    });
    Object.defineProperty(d.Camera.prototype, "y", {
        get: function () {
            return this.view.y
        }, set: function (b) {
            this.view.y = b;
            if (this.bounds) {
                this.checkBounds()
            }
        }
    });
    Object.defineProperty(d.Camera.prototype, "width", {
        get: function () {
            return this.view.width
        }, set: function (b) {
            this.view.width = b
        }
    });
    Object.defineProperty(d.Camera.prototype, "height", {
        get: function () {
            return this.view.height
        }, set: function (b) {
            this.view.height = b
        }
    });
    d.State = function () {
        this.game = null;
        this.add = null;
        this.camera = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.sound = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.particles = null;
        this.physics = null
    };
    d.State.prototype = {
        preload: function () {
        }, loadUpdate: function () {
        }, loadRender: function () {
        }, create: function () {
        }, update: function () {
        }, render: function () {
        }, paused: function () {
        }, destroy: function () {
        }
    };
    d.StateManager = function (h, b) {
        this.game = h;
        this.states = {};
        if (b !== null) {
            this._pendingState = b
        }
    };
    d.StateManager.prototype = {
        game: null,
        _pendingState: null,
        _created: false,
        states: {},
        current: "",
        onInitCallback: null,
        onPreloadCallback: null,
        onCreateCallback: null,
        onUpdateCallback: null,
        onRenderCallback: null,
        onPreRenderCallback: null,
        onLoadUpdateCallback: null,
        onLoadRenderCallback: null,
        onPausedCallback: null,
        onShutDownCallback: null,
        boot: function () {
            if (this._pendingState !== null) {
                if (typeof this._pendingState === "string") {
                    this.start(this._pendingState, false, false)
                } else {
                    this.add("default", this._pendingState, true)
                }
            }
        },
        add: function (h, i, b) {
            if (typeof b === "undefined") {
                b = false
            }
            var j;
            if (i instanceof d.State) {
                j = i
            } else {
                if (typeof i === "object") {
                    j = i;
                    j.game = this.game
                } else {
                    if (typeof i === "function") {
                        j = new i(this.game)
                    }
                }
            }
            this.states[h] = j;
            if (b) {
                if (this.game.isBooted) {
                    this.start(h)
                } else {
                    this._pendingState = h
                }
            }
            return j
        },
        remove: function (b) {
            if (this.current == b) {
                this.callbackContext = null;
                this.onInitCallback = null;
                this.onShutDownCallback = null;
                this.onPreloadCallback = null;
                this.onLoadRenderCallback = null;
                this.onLoadUpdateCallback = null;
                this.onCreateCallback = null;
                this.onUpdateCallback = null;
                this.onRenderCallback = null;
                this.onPausedCallback = null;
                this.onDestroyCallback = null
            }
            delete this.states[b]
        },
        start: function (h, b, i) {
            if (typeof b === "undefined") {
                b = true
            }
            if (typeof i === "undefined") {
                i = false
            }
            if (this.game.isBooted == false) {
                this._pendingState = h;
                return
            }
            if (this.checkState(h) == false) {
                return
            } else {
                if (this.current) {
                    this.onShutDownCallback.call(this.callbackContext, this.game)
                }
                if (b) {
                    this.game.tweens.removeAll();
                    this.game.world.destroy();
                    if (i == true) {
                        this.game.cache.destroy()
                    }
                }
                this.setCurrentState(h)
            }
            if (this.onPreloadCallback) {
                this.game.load.reset();
                this.onPreloadCallback.call(this.callbackContext, this.game);
                if (this.game.load.queueSize == 0) {
                    this.game.loadComplete()
                } else {
                    this.game.load.start()
                }
            } else {
                this.game.loadComplete()
            }
        },
        dummy: function () {
        },
        checkState: function (b) {
            if (this.states[b]) {
                var h = false;
                if (this.states[b]["preload"]) {
                    h = true
                }
                if (h == false && this.states[b]["loadRender"]) {
                    h = true
                }
                if (h == false && this.states[b]["loadUpdate"]) {
                    h = true
                }
                if (h == false && this.states[b]["create"]) {
                    h = true
                }
                if (h == false && this.states[b]["update"]) {
                    h = true
                }
                if (h == false && this.states[b]["preRender"]) {
                    h = true
                }
                if (h == false && this.states[b]["render"]) {
                    h = true
                }
                if (h == false && this.states[b]["paused"]) {
                    h = true
                }
                if (h == false) {
                    console.warn("Invalid Phaser State object given. Must contain at least a one of the required functions.");
                    return false
                }
                return true
            } else {
                console.warn("Phaser.StateManager - No state found with the key: " + b);
                return false
            }
        },
        link: function (b) {
            this.states[b].game = this.game;
            this.states[b].add = this.game.add;
            this.states[b].camera = this.game.camera;
            this.states[b].cache = this.game.cache;
            this.states[b].input = this.game.input;
            this.states[b].load = this.game.load;
            this.states[b].math = this.game.math;
            this.states[b].sound = this.game.sound;
            this.states[b].stage = this.game.stage;
            this.states[b].time = this.game.time;
            this.states[b].tweens = this.game.tweens;
            this.states[b].world = this.game.world;
            this.states[b].particles = this.game.particles;
            this.states[b].physics = this.game.physics;
            this.states[b].rnd = this.game.rnd
        },
        setCurrentState: function (b) {
            this.callbackContext = this.states[b];
            this.link(b);
            this.onInitCallback = this.states[b]["init"] || this.dummy;
            this.onPreloadCallback = this.states[b]["preload"] || null;
            this.onLoadRenderCallback = this.states[b]["loadRender"] || null;
            this.onLoadUpdateCallback = this.states[b]["loadUpdate"] || null;
            this.onCreateCallback = this.states[b]["create"] || null;
            this.onUpdateCallback = this.states[b]["update"] || null;
            this.onPreRenderCallback = this.states[b]["preRender"] || null;
            this.onRenderCallback = this.states[b]["render"] || null;
            this.onPausedCallback = this.states[b]["paused"] || null;
            this.onShutDownCallback = this.states[b]["shutdown"] || this.dummy;
            this.current = b;
            this._created = false;
            this.onInitCallback.call(this.callbackContext, this.game)
        },
        loadComplete: function () {
            if (this._created == false && this.onCreateCallback) {
                this._created = true;
                this.onCreateCallback.call(this.callbackContext, this.game)
            } else {
                this._created = true
            }
        },
        update: function () {
            if (this._created && this.onUpdateCallback) {
                this.onUpdateCallback.call(this.callbackContext, this.game)
            } else {
                if (this.onLoadUpdateCallback) {
                    this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                }
            }
        },
        preRender: function () {
            if (this.onPreRenderCallback) {
                this.onPreRenderCallback.call(this.callbackContext, this.game)
            }
        },
        render: function () {
            if (this._created && this.onRenderCallback) {
                this.onRenderCallback.call(this.callbackContext, this.game)
            } else {
                if (this.onLoadRenderCallback) {
                    this.onLoadRenderCallback.call(this.callbackContext, this.game)
                }
            }
        },
        destroy: function () {
            this.callbackContext = null;
            this.onInitCallback = null;
            this.onShutDownCallback = null;
            this.onPreloadCallback = null;
            this.onLoadRenderCallback = null;
            this.onLoadUpdateCallback = null;
            this.onCreateCallback = null;
            this.onUpdateCallback = null;
            this.onRenderCallback = null;
            this.onPausedCallback = null;
            this.onDestroyCallback = null;
            this.game = null;
            this.states = {};
            this._pendingState = null
        }
    };
    d.LinkedList = function () {
        this.next = null;
        this.prev = null;
        this.first = null;
        this.last = null;
        this.total = 0
    };
    d.LinkedList.prototype = {
        add: function (b) {
            if (this.total == 0 && this.first == null && this.last == null) {
                this.first = b;
                this.last = b;
                this.next = b;
                b.prev = this;
                this.total++;
                return b
            }
            this.last.next = b;
            b.prev = this.last;
            this.last = b;
            this.total++;
            return b
        }, remove: function (b) {
            if (b == this.first) {
                this.first = this.first.next
            } else {
                if (b == this.last) {
                    this.last = this.last.prev
                }
            }
            if (b.prev) {
                b.prev.next = b.next
            }
            if (b.next) {
                b.next.prev = b.prev
            }
            b.next = b.prev = null;
            if (this.first == null) {
                this.last = null
            }
            this.total--
        }, callAll: function (h) {
            if (!this.first || !this.last) {
                return
            }
            var b = this.first;
            do {
                if (b && b[h]) {
                    b[h].call(b)
                }
                b = b.next
            } while (b != this.last.next)
        }
    };
    d.Signal = function () {
        this._bindings = [];
        this._prevParams = null;
        var b = this;
        this.dispatch = function () {
            d.Signal.prototype.dispatch.apply(b, arguments)
        }
    };
    d.Signal.prototype = {
        memorize: false, _shouldPropagate: true, active: true, validateListener: function (b, h) {
            if (typeof b !== "function") {
                throw new Error("listener is a required param of {fn}() and should be a Function.".replace("{fn}", h))
            }
        }, _registerListener: function (k, i, j, h) {
            var b = this._indexOfListener(k, j), l;
            if (b !== -1) {
                l = this._bindings[b];
                if (l.isOnce() !== i) {
                    throw new Error("You cannot add" + (i ? "" : "Once") + "() then add" + (!i ? "" : "Once") + "() the same listener without removing the relationship first.")
                }
            } else {
                l = new d.SignalBinding(this, k, i, j, h);
                this._addBinding(l)
            }
            if (this.memorize && this._prevParams) {
                l.execute(this._prevParams)
            }
            return l
        }, _addBinding: function (b) {
            var h = this._bindings.length;
            do {
                --h
            } while (this._bindings[h] && b._priority <= this._bindings[h]._priority);
            this._bindings.splice(h + 1, 0, b)
        }, _indexOfListener: function (h, b) {
            var j = this._bindings.length, i;
            while (j--) {
                i = this._bindings[j];
                if (i._listener === h && i.context === b) {
                    return j
                }
            }
            return -1
        }, has: function (h, b) {
            return this._indexOfListener(h, b) !== -1
        }, add: function (i, h, b) {
            this.validateListener(i, "add");
            return this._registerListener(i, false, h, b)
        }, addOnce: function (i, h, b) {
            this.validateListener(i, "addOnce");
            return this._registerListener(i, true, h, b)
        }, remove: function (j, h) {
            this.validateListener(j, "remove");
            var b = this._indexOfListener(j, h);
            if (b !== -1) {
                this._bindings[b]._destroy();
                this._bindings.splice(b, 1)
            }
            return j
        }, removeAll: function () {
            var b = this._bindings.length;
            while (b--) {
                this._bindings[b]._destroy()
            }
            this._bindings.length = 0
        }, getNumListeners: function () {
            return this._bindings.length
        }, halt: function () {
            this._shouldPropagate = false
        }, dispatch: function (h) {
            if (!this.active) {
                return
            }
            var b = Array.prototype.slice.call(arguments), j = this._bindings.length, i;
            if (this.memorize) {
                this._prevParams = b
            }
            if (!j) {
                return
            }
            i = this._bindings.slice();
            this._shouldPropagate = true;
            do {
                j--
            } while (i[j] && this._shouldPropagate && i[j].execute(b) !== false)
        }, forget: function () {
            this._prevParams = null
        }, dispose: function () {
            this.removeAll();
            delete this._bindings;
            delete this._prevParams
        }, toString: function () {
            return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
        }
    };
    d.SignalBinding = function (k, j, h, i, b) {
        this._listener = j;
        this._isOnce = h;
        this.context = i;
        this._signal = k;
        this._priority = b || 0
    };
    d.SignalBinding.prototype = {
        active: true, params: null, execute: function (b) {
            var i, h;
            if (this.active && !!this._listener) {
                h = this.params ? this.params.concat(b) : b;
                i = this._listener.apply(this.context, h);
                if (this._isOnce) {
                    this.detach()
                }
            }
            return i
        }, detach: function () {
            return this.isBound() ? this._signal.remove(this._listener, this.context) : null
        }, isBound: function () {
            return (!!this._signal && !!this._listener)
        }, isOnce: function () {
            return this._isOnce
        }, getListener: function () {
            return this._listener
        }, getSignal: function () {
            return this._signal
        }, _destroy: function () {
            delete this._signal;
            delete this._listener;
            delete this.context
        }, toString: function () {
            return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
        }
    };
    d.Plugin = function (b, h) {
        if (typeof h === "undefined") {
            h = null
        }
        this.game = b;
        this.parent = h;
        this.active = false;
        this.visible = false;
        this.hasPreUpdate = false;
        this.hasUpdate = false;
        this.hasRender = false;
        this.hasPostRender = false
    };
    d.Plugin.prototype = {
        preUpdate: function () {
        }, update: function () {
        }, render: function () {
        }, postRender: function () {
        }, destroy: function () {
            this.game = null;
            this.parent = null;
            this.active = false;
            this.visible = false
        }
    };
    d.PluginManager = function (b, h) {
        this.game = b;
        this._parent = h;
        this.plugins = [];
        this._pluginsLength = 0
    };
    d.PluginManager.prototype = {
        add: function (h) {
            var b = false;
            if (typeof h === "function") {
                h = new h(this.game, this._parent)
            } else {
                h.game = this.game;
                h.parent = this._parent
            }
            if (typeof h.preUpdate === "function") {
                h.hasPreUpdate = true;
                b = true
            }
            if (typeof h.update === "function") {
                h.hasUpdate = true;
                b = true
            }
            if (typeof h.render === "function") {
                h.hasRender = true;
                b = true
            }
            if (typeof h.postRender === "function") {
                h.hasPostRender = true;
                b = true
            }
            if (b) {
                if (h.hasPreUpdate || h.hasUpdate) {
                    h.active = true
                }
                if (h.hasRender || h.hasPostRender) {
                    h.visible = true
                }
                this._pluginsLength = this.plugins.push(h);
                if (typeof h.init === "function") {
                    h.init()
                }
                return h
            } else {
                return null
            }
        }, remove: function (b) {
            this._pluginsLength--
        }, preUpdate: function () {
            if (this._pluginsLength == 0) {
                return
            }
            for (this._p = 0; this._p < this._pluginsLength; this._p++) {
                if (this.plugins[this._p].active && this.plugins[this._p].hasPreUpdate) {
                    this.plugins[this._p].preUpdate()
                }
            }
        }, update: function () {
            if (this._pluginsLength == 0) {
                return
            }
            for (this._p = 0; this._p < this._pluginsLength; this._p++) {
                if (this.plugins[this._p].active && this.plugins[this._p].hasUpdate) {
                    this.plugins[this._p].update()
                }
            }
        }, render: function () {
            if (this._pluginsLength == 0) {
                return
            }
            for (this._p = 0; this._p < this._pluginsLength; this._p++) {
                if (this.plugins[this._p].visible && this.plugins[this._p].hasRender) {
                    this.plugins[this._p].render()
                }
            }
        }, postRender: function () {
            if (this._pluginsLength == 0) {
                return
            }
            for (this._p = 0; this._p < this._pluginsLength; this._p++) {
                if (this.plugins[this._p].visible && this.plugins[this._p].hasPostRender) {
                    this.plugins[this._p].postRender()
                }
            }
        }, destroy: function () {
            this.plugins.length = 0;
            this._pluginsLength = 0;
            this.game = null;
            this._parent = null
        }
    };
    d.Stage = function (h, i, b) {
        this.game = h;
        this._backgroundColor = "rgb(0,0,0)";
        this.offset = new d.Point;
        this.canvas = d.Canvas.create(i, b);
        this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%";
        this._stage = new g.Stage(0, false);
        this._stage.name = "_stage_root";
        this.scaleMode = d.StageScaleMode.NO_SCALE;
        this.scale = new d.StageScaleMode(this.game, i, b);
        this.aspectRatio = i / b;
        this._nextOffsetCheck = 0;
        this.checkOffsetInterval = 2500
    };
    d.Stage.prototype = {
        boot: function () {
            d.Canvas.getOffset(this.canvas, this.offset);
            this.bounds = new d.Rectangle(this.offset.x, this.offset.y, this.game.width, this.game.height);
            var b = this;
            this._onChange = function (h) {
                return b.visibilityChange(h)
            };
            d.Canvas.setUserSelect(this.canvas, "none");
            d.Canvas.setTouchAction(this.canvas, "none");
            document.addEventListener("visibilitychange", this._onChange, false);
            document.addEventListener("webkitvisibilitychange", this._onChange, false);
            document.addEventListener("pagehide", this._onChange, false);
            document.addEventListener("pageshow", this._onChange, false);
            window.onblur = this._onChange;
            window.onfocus = this._onChange
        }, update: function () {
            if (this.checkOffsetInterval !== false) {
                if (this.game.time.now > this._nextOffsetCheck) {
                    d.Canvas.getOffset(this.canvas, this.offset);
                    this._nextOffsetCheck = this.game.time.now + this.checkOffsetInterval
                }
            }
        }, visibilityChange: function (b) {
            if (this.disableVisibilityChange) {
                return
            }
            if (b.type == "pagehide" || b.type == "blur" || document.hidden == true || document.webkitHidden == true) {
                this.game.paused = true
            } else {
                this.game.paused = false
            }
        }
    };
    Object.defineProperty(d.Stage.prototype, "backgroundColor", {
        get: function () {
            return this._backgroundColor
        }, set: function (b) {
            this._backgroundColor = b;
            if (this.game.renderType == d.CANVAS) {
                this._stage.backgroundColorString = b
            } else {
                if (typeof b === "string") {
                    b = d.Color.hexToRGB(b)
                }
                this._stage.setBackgroundColor(b)
            }
        }
    });
    d.Group = function (b, j, i, h) {
        if (typeof j === "undefined") {
            j = b.world
        }
        if (typeof h === "undefined") {
            h = false
        }
        this.game = b;
        this.name = i || "group";
        if (h) {
            this._container = this.game.stage._stage
        } else {
            this._container = new g.DisplayObjectContainer();
            this._container.name = this.name;
            if (j) {
                if (j instanceof d.Group) {
                    j._container.addChild(this._container);
                    j._container.updateTransform()
                } else {
                    j.addChild(this._container);
                    j.updateTransform()
                }
            } else {
                this.game.stage._stage.addChild(this._container);
                this.game.stage._stage.updateTransform()
            }
        }
        this.type = d.GROUP;
        this.exists = true;
        this.scale = new d.Point(1, 1);
        this.cursor = null
    };
    d.Group.prototype = {
        add: function (b) {
            if (b.group !== this) {
                b.group = this;
                if (b.events) {
                    b.events.onAddedToGroup.dispatch(b, this)
                }
                this._container.addChild(b);
                b.updateTransform();
                if (this.cursor === null) {
                    this.cursor = b
                }
            }
            return b
        }, addAt: function (h, b) {
            if (h.group !== this) {
                h.group = this;
                if (h.events) {
                    h.events.onAddedToGroup.dispatch(h, this)
                }
                this._container.addChildAt(h, b);
                h.updateTransform();
                if (this.cursor === null) {
                    this.cursor = h
                }
            }
            return h
        }, getAt: function (b) {
            return this._container.getChildAt(b)
        }, create: function (b, l, h, j, i) {
            if (typeof i == "undefined") {
                i = true
            }
            var k = new d.Sprite(this.game, b, l, h, j);
            k.group = this;
            k.exists = i;
            k.visible = i;
            k.alive = i;
            if (k.events) {
                k.events.onAddedToGroup.dispatch(k, this)
            }
            this._container.addChild(k);
            k.updateTransform();
            if (this.cursor === null) {
                this.cursor = k
            }
            return k
        }, createMultiple: function (k, h, l, j) {
            if (typeof j == "undefined") {
                j = false
            }
            for (var b = 0; b < k; b++) {
                var m = new d.Sprite(this.game, 0, 0, h, l);
                m.group = this;
                m.exists = j;
                m.visible = j;
                m.alive = j;
                if (m.events) {
                    m.events.onAddedToGroup.dispatch(m, this)
                }
                this._container.addChild(m);
                m.updateTransform();
                if (this.cursor === null) {
                    this.cursor = m
                }
            }
        }, next: function () {
            if (this.cursor) {
                if (this.cursor == this._container.last) {
                    this.cursor = this._container._iNext
                } else {
                    this.cursor = this.cursor._iNext
                }
            }
        }, previous: function () {
            if (this.cursor) {
                if (this.cursor == this._container._iNext) {
                    this.cursor = this._container.last
                } else {
                    this.cursor = this.cursor._iPrev
                }
            }
        }, swap: function (n, l) {
            if (n === l || !n.parent || !l.parent) {
                console.warn("You cannot swap a child with itself or swap un-parented children");
                return false
            }
            var i = n._iPrev;
            var h = n._iNext;
            var m = l._iPrev;
            var k = l._iNext;
            var b = this._container.last._iNext;
            var j = this.game.stage._stage;
            do {
                if (j !== n && j !== l) {
                    if (j.first === n) {
                        j.first = l
                    } else {
                        if (j.first === l) {
                            j.first = n
                        }
                    }
                    if (j.last === n) {
                        j.last = l
                    } else {
                        if (j.last === l) {
                            j.last = n
                        }
                    }
                }
                j = j._iNext
            } while (j != b);
            if (n._iNext == l) {
                n._iNext = k;
                n._iPrev = l;
                l._iNext = n;
                l._iPrev = i;
                if (i) {
                    i._iNext = l
                }
                if (k) {
                    k._iPrev = n
                }
                if (n.__renderGroup) {
                    n.__renderGroup.updateTexture(n)
                }
                if (l.__renderGroup) {
                    l.__renderGroup.updateTexture(l)
                }
                return true
            } else {
                if (l._iNext == n) {
                    n._iNext = l;
                    n._iPrev = m;
                    l._iNext = h;
                    l._iPrev = n;
                    if (m) {
                        m._iNext = n
                    }
                    if (h) {
                        k._iPrev = l
                    }
                    if (n.__renderGroup) {
                        n.__renderGroup.updateTexture(n)
                    }
                    if (l.__renderGroup) {
                        l.__renderGroup.updateTexture(l)
                    }
                    return true
                } else {
                    n._iNext = k;
                    n._iPrev = m;
                    l._iNext = h;
                    l._iPrev = i;
                    if (i) {
                        i._iNext = l
                    }
                    if (h) {
                        h._iPrev = l
                    }
                    if (m) {
                        m._iNext = n
                    }
                    if (k) {
                        k._iPrev = n
                    }
                    if (n.__renderGroup) {
                        n.__renderGroup.updateTexture(n)
                    }
                    if (l.__renderGroup) {
                        l.__renderGroup.updateTexture(l)
                    }
                    return true
                }
            }
            return false
        }, bringToTop: function (b) {
            if (b.group === this) {
                this.remove(b);
                this.add(b)
            }
            return b
        }, getIndex: function (b) {
            return this._container.children.indexOf(b)
        }, replace: function (i, b) {
            if (!this._container.first._iNext) {
                return
            }
            var h = this.getIndex(i);
            if (h != -1) {
                if (b.parent != undefined) {
                    b.events.onRemovedFromGroup.dispatch(b, this);
                    b.parent.removeChild(b)
                }
                this._container.removeChild(i);
                this._container.addChildAt(b, h);
                b.events.onAddedToGroup.dispatch(b, this);
                b.updateTransform();
                if (this.cursor == i) {
                    this.cursor = this._container._iNext
                }
            }
        }, setProperty: function (j, h, i, b) {
            b = b || 0;
            if (h.length == 1) {
                if (b == 0) {
                    j[h[0]] = i
                } else {
                    if (b == 1) {
                        j[h[0]] += i
                    } else {
                        if (b == 2) {
                            j[h[0]] -= i
                        } else {
                            if (b == 3) {
                                j[h[0]] *= i
                            } else {
                                if (b == 4) {
                                    j[h[0]] /= i
                                }
                            }
                        }
                    }
                }
            } else {
                if (h.length == 2) {
                    if (b == 0) {
                        j[h[0]][h[1]] = i
                    } else {
                        if (b == 1) {
                            j[h[0]][h[1]] += i
                        } else {
                            if (b == 2) {
                                j[h[0]][h[1]] -= i
                            } else {
                                if (b == 3) {
                                    j[h[0]][h[1]] *= i
                                } else {
                                    if (b == 4) {
                                        j[h[0]][h[1]] /= i
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (h.length == 3) {
                        if (b == 0) {
                            j[h[0]][h[1]][h[2]] = i
                        } else {
                            if (b == 1) {
                                j[h[0]][h[1]][h[2]] += i
                            } else {
                                if (b == 2) {
                                    j[h[0]][h[1]][h[2]] -= i
                                } else {
                                    if (b == 3) {
                                        j[h[0]][h[1]][h[2]] *= i
                                    } else {
                                        if (b == 4) {
                                            j[h[0]][h[1]][h[2]] /= i
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        if (h.length == 4) {
                            if (b == 0) {
                                j[h[0]][h[1]][h[2]][h[3]] = i
                            } else {
                                if (b == 1) {
                                    j[h[0]][h[1]][h[2]][h[3]] += i
                                } else {
                                    if (b == 2) {
                                        j[h[0]][h[1]][h[2]][h[3]] -= i
                                    } else {
                                        if (b == 3) {
                                            j[h[0]][h[1]][h[2]][h[3]] *= i
                                        } else {
                                            if (b == 4) {
                                                j[h[0]][h[1]][h[2]][h[3]] /= i
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                        }
                    }
                }
            }
        }, setAll: function (j, k, h, l, b) {
            j = j.split(".");
            if (typeof h === "undefined") {
                h = false
            }
            if (typeof l === "undefined") {
                l = false
            }
            b = b || 0;
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var i = this._container.first._iNext;
                do {
                    if ((h == false || (h && i.alive)) && (l == false || (l && i.visible))) {
                        this.setProperty(i, j, k, b)
                    }
                    i = i._iNext
                } while (i != this._container.last._iNext)
            }
        }, addAll: function (i, h, b, j) {
            this.setAll(i, h, b, j, 1)
        }, subAll: function (i, h, b, j) {
            this.setAll(i, h, b, j, 2)
        }, multiplyAll: function (i, h, b, j) {
            this.setAll(i, h, b, j, 3)
        }, divideAll: function (i, h, b, j) {
            this.setAll(i, h, b, j, 4)
        }, callAllExists: function (j, i) {
            var b = Array.prototype.splice.call(arguments, 2);
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var h = this._container.first._iNext;
                do {
                    if (h.exists == i && h[j]) {
                        h[j].apply(h, b)
                    }
                    h = h._iNext
                } while (h != this._container.last._iNext)
            }
        }, callAll: function (i) {
            var b = Array.prototype.splice.call(arguments, 1);
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var h = this._container.first._iNext;
                do {
                    if (h[i]) {
                        h[i].apply(h, b)
                    }
                    h = h._iNext
                } while (h != this._container.last._iNext)
            }
        }, forEach: function (k, b, j) {
            if (typeof j === "undefined") {
                j = false
            }
            var h = Array.prototype.splice.call(arguments, 3);
            h.unshift(null);
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var i = this._container.first._iNext;
                do {
                    if (j == false || (j && i.exists)) {
                        h[0] = i;
                        k.apply(b, h)
                    }
                    i = i._iNext
                } while (i != this._container.last._iNext)
            }
        }, forEachAlive: function (j, b) {
            var h = Array.prototype.splice.call(arguments, 2);
            h.unshift(null);
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var i = this._container.first._iNext;
                do {
                    if (i.alive) {
                        h[0] = i;
                        j.apply(b, h)
                    }
                    i = i._iNext
                } while (i != this._container.last._iNext)
            }
        }, forEachDead: function (j, b) {
            var h = Array.prototype.splice.call(arguments, 2);
            h.unshift(null);
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var i = this._container.first._iNext;
                do {
                    if (i.alive == false) {
                        h[0] = i;
                        j.apply(b, h)
                    }
                    i = i._iNext
                } while (i != this._container.last._iNext)
            }
        }, getFirstExists: function (h) {
            if (typeof h !== "boolean") {
                h = true
            }
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var b = this._container.first._iNext;
                do {
                    if (b.exists === h) {
                        return b
                    }
                    b = b._iNext
                } while (b != this._container.last._iNext)
            }
            return null
        }, getFirstAlive: function () {
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var b = this._container.first._iNext;
                do {
                    if (b.alive) {
                        return b
                    }
                    b = b._iNext
                } while (b != this._container.last._iNext)
            }
            return null
        }, getFirstDead: function () {
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var b = this._container.first._iNext;
                do {
                    if (!b.alive) {
                        return b
                    }
                    b = b._iNext
                } while (b != this._container.last._iNext)
            }
            return null
        }, countLiving: function () {
            var h = 0;
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var b = this._container.first._iNext;
                do {
                    if (b.alive) {
                        h++
                    }
                    b = b._iNext
                } while (b != this._container.last._iNext)
            } else {
                h = -1
            }
            return h
        }, countDead: function () {
            var h = 0;
            if (this._container.children.length > 0 && this._container.first._iNext) {
                var b = this._container.first._iNext;
                do {
                    if (!b.alive) {
                        h++
                    }
                    b = b._iNext
                } while (b != this._container.last._iNext)
            } else {
                h = -1
            }
            return h
        }, getRandom: function (h, b) {
            if (this._container.children.length == 0) {
                return null
            }
            h = h || 0;
            b = b || this._container.children.length;
            return this.game.math.getRandom(this._container.children, h, b)
        }, remove: function (b) {
            if (b.events) {
                b.events.onRemovedFromGroup.dispatch(b, this)
            }
            this._container.removeChild(b);
            if (this.cursor == b) {
                if (this._container._iNext) {
                    this.cursor = this._container._iNext
                } else {
                    this.cursor = null
                }
            }
            b.group = null
        }, removeAll: function () {
            if (this._container.children.length == 0) {
                return
            }
            do {
                if (this._container.children[0].events) {
                    this._container.children[0].events.onRemovedFromGroup.dispatch(this._container.children[0], this)
                }
                this._container.removeChild(this._container.children[0])
            } while (this._container.children.length > 0);
            this.cursor = null
        }, removeBetween: function (j, h) {
            if (this._container.children.length == 0) {
                return
            }
            if (j > h || j < 0 || h > this._container.children.length) {
                return false
            }
            for (var b = j; b < h; b++) {
                var k = this._container.children[b];
                k.events.onRemovedFromGroup.dispatch(k, this);
                this._container.removeChild(k);
                if (this.cursor == k) {
                    if (this._container._iNext) {
                        this.cursor = this._container._iNext
                    } else {
                        this.cursor = null
                    }
                }
            }
        }, destroy: function () {
            this.removeAll();
            this._container.parent.removeChild(this._container);
            this._container = null;
            this.game = null;
            this.exists = false;
            this.cursor = null
        }, dump: function (m) {
            if (typeof m == "undefined") {
                m = false
            }
            var o = 20;
            var j = "\n" + d.Utils.pad("Node", o) + "|" + d.Utils.pad("Next", o) + "|" + d.Utils.pad("Previous", o) + "|" + d.Utils.pad("First", o) + "|" + d.Utils.pad("Last", o);
            console.log(j);
            var j = d.Utils.pad("----------", o) + "|" + d.Utils.pad("----------", o) + "|" + d.Utils.pad("----------", o) + "|" + d.Utils.pad("----------", o) + "|" + d.Utils.pad("----------", o);
            console.log(j);
            if (m) {
                var h = this.game.stage._stage.last._iNext;
                var p = this.game.stage._stage
            } else {
                var h = this._container.last._iNext;
                var p = this._container
            }
            do {
                var i = p.name || "*";
                if (this.cursor == p) {
                    var i = "> " + i
                }
                var k = "-";
                var b = "-";
                var l = "-";
                var n = "-";
                if (p._iNext) {
                    k = p._iNext.name
                }
                if (p._iPrev) {
                    b = p._iPrev.name
                }
                if (p.first) {
                    l = p.first.name
                }
                if (p.last) {
                    n = p.last.name
                }
                if (typeof k === "undefined") {
                    k = "-"
                }
                if (typeof b === "undefined") {
                    b = "-"
                }
                if (typeof l === "undefined") {
                    l = "-"
                }
                if (typeof n === "undefined") {
                    n = "-"
                }
                var j = d.Utils.pad(i, o) + "|" + d.Utils.pad(k, o) + "|" + d.Utils.pad(b, o) + "|" + d.Utils.pad(l, o) + "|" + d.Utils.pad(n, o);
                console.log(j);
                p = p._iNext
            } while (p != h)
        }
    };
    Object.defineProperty(d.Group.prototype, "total", {
        get: function () {
            return this._container.children.length
        }
    });
    Object.defineProperty(d.Group.prototype, "length", {
        get: function () {
            return this._container.children.length
        }
    });
    Object.defineProperty(d.Group.prototype, "x", {
        get: function () {
            return this._container.position.x
        }, set: function (b) {
            this._container.position.x = b
        }
    });
    Object.defineProperty(d.Group.prototype, "y", {
        get: function () {
            return this._container.position.y
        }, set: function (b) {
            this._container.position.y = b
        }
    });
    Object.defineProperty(d.Group.prototype, "angle", {
        get: function () {
            return d.Math.radToDeg(this._container.rotation)
        }, set: function (b) {
            this._container.rotation = d.Math.degToRad(b)
        }
    });
    Object.defineProperty(d.Group.prototype, "rotation", {
        get: function () {
            return this._container.rotation
        }, set: function (b) {
            this._container.rotation = b
        }
    });
    Object.defineProperty(d.Group.prototype, "visible", {
        get: function () {
            return this._container.visible
        }, set: function (b) {
            this._container.visible = b
        }
    });
    Object.defineProperty(d.Group.prototype, "alpha", {
        get: function () {
            return this._container.alpha
        }, set: function (b) {
            this._container.alpha = b
        }
    });
    d.World = function (b) {
        d.Group.call(this, b, null, "__world", false);
        this.scale = new d.Point(1, 1);
        this.bounds = new d.Rectangle(0, 0, b.width, b.height);
        this.camera = null;
        this.currentRenderOrderID = 0
    };
    d.World.prototype = Object.create(d.Group.prototype);
    d.World.prototype.constructor = d.World;
    d.World.prototype.boot = function () {
        this.camera = new d.Camera(this.game, 0, 0, 0, this.game.width, this.game.height);
        this.camera.displayObject = this._container;
        this.game.camera = this.camera
    };
    d.World.prototype.update = function () {
        this.currentRenderOrderID = 0;
        if (this.game.stage._stage.first._iNext) {
            var b = this.game.stage._stage.first._iNext;
            do {
                if (b.preUpdate) {
                    b.preUpdate()
                }
                if (b.update) {
                    b.update()
                }
                b = b._iNext
            } while (b != this.game.stage._stage.last._iNext)
        }
    };
    d.World.prototype.postUpdate = function () {
        this.camera.update();
        if (this.game.stage._stage.first._iNext) {
            var b = this.game.stage._stage.first._iNext;
            do {
                if (b.postUpdate) {
                    b.postUpdate()
                }
                b = b._iNext
            } while (b != this.game.stage._stage.last._iNext)
        }
    };
    d.World.prototype.setBounds = function (h, j, i, b) {
        this.bounds.setTo(h, j, i, b);
        if (this.camera.bounds) {
            this.camera.bounds.setTo(h, j, i, b)
        }
    };
    d.World.prototype.destroy = function () {
        this.camera.x = 0;
        this.camera.y = 0;
        this.game.input.reset(true);
        this.removeAll()
    };
    Object.defineProperty(d.World.prototype, "width", {
        get: function () {
            return this.bounds.width
        }, set: function (b) {
            this.bounds.width = b
        }
    });
    Object.defineProperty(d.World.prototype, "height", {
        get: function () {
            return this.bounds.height
        }, set: function (b) {
            this.bounds.height = b
        }
    });
    Object.defineProperty(d.World.prototype, "centerX", {
        get: function () {
            return this.bounds.halfWidth
        }
    });
    Object.defineProperty(d.World.prototype, "centerY", {
        get: function () {
            return this.bounds.halfHeight
        }
    });
    Object.defineProperty(d.World.prototype, "randomX", {
        get: function () {
            if (this.bounds.x < 0) {
                return this.game.rnd.integerInRange(this.bounds.x, (this.bounds.width - Math.abs(this.bounds.x)))
            } else {
                return this.game.rnd.integerInRange(this.bounds.x, this.bounds.width)
            }
        }
    });
    Object.defineProperty(d.World.prototype, "randomY", {
        get: function () {
            if (this.bounds.y < 0) {
                return this.game.rnd.integerInRange(this.bounds.y, (this.bounds.height - Math.abs(this.bounds.y)))
            } else {
                return this.game.rnd.integerInRange(this.bounds.y, this.bounds.height)
            }
        }
    });
    d.Game = function (j, b, l, i, k, m, h) {
        j = j || 800;
        b = b || 600;
        l = l || d.AUTO;
        i = i || "";
        k = k || null;
        if (typeof m == "undefined") {
            m = false
        }
        if (typeof h == "undefined") {
            h = true
        }
        this.id = d.GAMES.push(this) - 1;
        this.parent = i;
        this.width = j;
        this.height = b;
        this.transparent = m;
        this.antialias = h;
        this.renderer = null;
        this.state = new d.StateManager(this, k);
        this._paused = false;
        this.renderType = l;
        this._loadComplete = false;
        this.isBooted = false;
        this.isRunning = false;
        this.raf = null;
        this.add = null;
        this.cache = null;
        this.input = null;
        this.load = null;
        this.math = null;
        this.net = null;
        this.sound = null;
        this.stage = null;
        this.time = null;
        this.tweens = null;
        this.world = null;
        this.physics = null;
        this.rnd = null;
        this.device = null;
        this.camera = null;
        this.canvas = null;
        this.context = null;
        this.debug = null;
        this.particles = null;
        var n = this;
        this._onBoot = function () {
            return n.boot()
        };
        if (document.readyState === "complete" || document.readyState === "interactive") {
            window.setTimeout(this._onBoot, 0)
        } else {
            document.addEventListener("DOMContentLoaded", this._onBoot, false);
            window.addEventListener("load", this._onBoot, false)
        }
        return this
    };
    d.Game.prototype = {
        boot: function () {
            if (this.isBooted) {
                return
            }
            if (!document.body) {
                window.setTimeout(this._onBoot, 20)
            } else {
                document.removeEventListener("DOMContentLoaded", this._onBoot);
                window.removeEventListener("load", this._onBoot);
                this.onPause = new d.Signal;
                this.onResume = new d.Signal;
                this.isBooted = true;
                this.device = new d.Device();
                this.math = d.Math;
                this.rnd = new d.RandomDataGenerator([(Date.now() * Math.random()).toString()]);
                this.stage = new d.Stage(this, this.width, this.height);
                this.setUpRenderer();
                this.world = new d.World(this);
                this.add = new d.GameObjectFactory(this);
                this.cache = new d.Cache(this);
                this.load = new d.Loader(this);
                this.time = new d.Time(this);
                this.tweens = new d.TweenManager(this);
                this.input = new d.Input(this);
                this.sound = new d.SoundManager(this);
                this.physics = new d.Physics.Arcade(this);
                this.particles = new d.Particles(this);
                this.plugins = new d.PluginManager(this, this);
                this.net = new d.Net(this);
                this.debug = new d.Utils.Debug(this);
                this.stage.boot();
                this.world.boot();
                this.input.boot();
                this.sound.boot();
                this.state.boot();
                this.load.onLoadComplete.add(this.loadComplete, this);
                this.showDebugHeader();
                this.isRunning = true;
                this._loadComplete = false;
                this.raf = new d.RequestAnimationFrame(this);
                this.raf.start()
            }
        }, showDebugHeader: function () {
            var h = d.DEV_VERSION;
            var j = "Canvas";
            var b = "HTML Audio";
            if (this.renderType == d.WEBGL) {
                j = "WebGL"
            }
            if (this.device.webAudio) {
                b = "WebAudio"
            }
            if (this.device.chrome) {
                var i = ["%c %c %c  Phaser v" + h + " - Renderer: " + j + " - Audio: " + b + "  %c %c ", "background: #00bff3", "background: #0072bc", "color: #ffffff; background: #003471", "background: #0072bc", "background: #00bff3"];
                console.log.apply(console, i)
            } else {
                console.log("Phaser v" + h + " - Renderer: " + j + " - Audio: " + b)
            }
        }, setUpRenderer: function () {
            if (this.renderType === d.CANVAS || (this.renderType === d.AUTO && this.device.webGL == false)) {
                if (this.device.canvas) {
                    this.renderType = d.CANVAS;
                    this.renderer = new g.CanvasRenderer(this.width, this.height, this.stage.canvas, this.transparent);
                    d.Canvas.setSmoothingEnabled(this.renderer.context, this.antialias);
                    this.canvas = this.renderer.view;
                    this.context = this.renderer.context
                } else {
                    throw new Error("Phaser.Game - cannot create Canvas or WebGL context, aborting.")
                }
            } else {
                this.renderType = d.WEBGL;
                this.renderer = new g.WebGLRenderer(this.width, this.height, this.stage.canvas, this.transparent, this.antialias);
                this.canvas = this.renderer.view;
                this.context = null
            }
            d.Canvas.addToDOM(this.renderer.view, this.parent, true);
            d.Canvas.setTouchAction(this.renderer.view)
        }, loadComplete: function () {
            this._loadComplete = true;
            this.state.loadComplete()
        }, update: function (b) {
            this.time.update(b);
            if (!this._paused) {
                this.plugins.preUpdate();
                this.physics.preUpdate();
                this.stage.update();
                this.input.update();
                this.tweens.update();
                this.sound.update();
                this.world.update();
                this.particles.update();
                this.state.update();
                this.plugins.update();
                this.world.postUpdate();
                this.renderer.render(this.stage._stage);
                this.plugins.render();
                this.state.render();
                this.plugins.postRender()
            }
        }, destroy: function () {
            this.raf.stop();
            this.input.destroy();
            this.state.destroy();
            this.state = null;
            this.cache = null;
            this.input = null;
            this.load = null;
            this.sound = null;
            this.stage = null;
            this.time = null;
            this.world = null;
            this.isBooted = false
        }
    };
    Object.defineProperty(d.Game.prototype, "paused", {
        get: function () {
            return this._paused
        }, set: function (b) {
            if (b === true) {
                if (this._paused == false) {
                    this._paused = true;
                    this.onPause.dispatch(this)
                }
            } else {
                if (this._paused) {
                    this._paused = false;
                    this.onResume.dispatch(this)
                }
            }
        }
    });
    d.Input = function (b) {
        this.game = b;
        this.hitCanvas = null;
        this.hitContext = null
    };
    d.Input.MOUSE_OVERRIDES_TOUCH = 0;
    d.Input.TOUCH_OVERRIDES_MOUSE = 1;
    d.Input.MOUSE_TOUCH_COMBINE = 2;
    d.Input.prototype = {
        game: null,
        pollRate: 0,
        _pollCounter: 0,
        _oldPosition: null,
        _x: 0,
        _y: 0,
        disabled: false,
        multiInputOverride: d.Input.MOUSE_TOUCH_COMBINE,
        position: null,
        speed: null,
        circle: null,
        scale: null,
        maxPointers: 10,
        currentPointers: 0,
        tapRate: 200,
        doubleTapRate: 300,
        holdRate: 2000,
        justPressedRate: 200,
        justReleasedRate: 200,
        recordPointerHistory: false,
        recordRate: 100,
        recordLimit: 100,
        pointer1: null,
        pointer2: null,
        pointer3: null,
        pointer4: null,
        pointer5: null,
        pointer6: null,
        pointer7: null,
        pointer8: null,
        pointer9: null,
        pointer10: null,
        activePointer: null,
        mousePointer: null,
        mouse: null,
        keyboard: null,
        touch: null,
        mspointer: null,
        onDown: null,
        onUp: null,
        onTap: null,
        onHold: null,
        interactiveItems: new d.LinkedList(),
        boot: function () {
            this.mousePointer = new d.Pointer(this.game, 0);
            this.pointer1 = new d.Pointer(this.game, 1);
            this.pointer2 = new d.Pointer(this.game, 2);
            this.mouse = new d.Mouse(this.game);
            this.keyboard = new d.Keyboard(this.game);
            this.touch = new d.Touch(this.game);
            this.mspointer = new d.MSPointer(this.game);
            this.onDown = new d.Signal();
            this.onUp = new d.Signal();
            this.onTap = new d.Signal();
            this.onHold = new d.Signal();
            this.scale = new d.Point(1, 1);
            this.speed = new d.Point();
            this.position = new d.Point();
            this._oldPosition = new d.Point();
            this.circle = new d.Circle(0, 0, 44);
            this.activePointer = this.mousePointer;
            this.currentPointers = 0;
            this.hitCanvas = document.createElement("canvas");
            this.hitCanvas.width = 1;
            this.hitCanvas.height = 1;
            this.hitContext = this.hitCanvas.getContext("2d");
            this.mouse.start();
            this.keyboard.start();
            this.touch.start();
            this.mspointer.start();
            this.mousePointer.active = true
        },
        destroy: function () {
            this.mouse.stop();
            this.keyboard.stop();
            this.touch.stop();
            this.mspointer.stop()
        },
        addPointer: function () {
            var h = 0;
            for (var b = 10; b > 0; b--) {
                if (this["pointer" + b] === null) {
                    h = b
                }
            }
            if (h == 0) {
                console.warn("You can only have 10 Pointer objects");
                return null
            } else {
                this["pointer" + h] = new d.Pointer(this.game, h);
                return this["pointer" + h]
            }
        },
        update: function () {
            if (this.pollRate > 0 && this._pollCounter < this.pollRate) {
                this._pollCounter++;
                return
            }
            this.speed.x = this.position.x - this._oldPosition.x;
            this.speed.y = this.position.y - this._oldPosition.y;
            this._oldPosition.copyFrom(this.position);
            this.mousePointer.update();
            this.pointer1.update();
            this.pointer2.update();
            if (this.pointer3) {
                this.pointer3.update()
            }
            if (this.pointer4) {
                this.pointer4.update()
            }
            if (this.pointer5) {
                this.pointer5.update()
            }
            if (this.pointer6) {
                this.pointer6.update()
            }
            if (this.pointer7) {
                this.pointer7.update()
            }
            if (this.pointer8) {
                this.pointer8.update()
            }
            if (this.pointer9) {
                this.pointer9.update()
            }
            if (this.pointer10) {
                this.pointer10.update()
            }
            this._pollCounter = 0
        },
        reset: function (h) {
            if (this.game.isBooted == false) {
                return
            }
            if (typeof h == "undefined") {
                h = false
            }
            this.keyboard.reset();
            this.mousePointer.reset();
            for (var b = 1; b <= 10; b++) {
                if (this["pointer" + b]) {
                    this["pointer" + b].reset()
                }
            }
            this.currentPointers = 0;
            this.game.stage.canvas.style.cursor = "default";
            if (h == true) {
                this.onDown.dispose();
                this.onUp.dispose();
                this.onTap.dispose();
                this.onHold.dispose();
                this.onDown = new d.Signal();
                this.onUp = new d.Signal();
                this.onTap = new d.Signal();
                this.onHold = new d.Signal();
                this.interactiveItems.callAll("reset")
            }
            this._pollCounter = 0
        },
        resetSpeed: function (b, h) {
            this._oldPosition.setTo(b, h);
            this.speed.setTo(0, 0)
        },
        startPointer: function (h) {
            if (this.maxPointers < 10 && this.totalActivePointers == this.maxPointers) {
                return null
            }
            if (this.pointer1.active == false) {
                return this.pointer1.start(h)
            } else {
                if (this.pointer2.active == false) {
                    return this.pointer2.start(h)
                } else {
                    for (var b = 3; b <= 10; b++) {
                        if (this["pointer" + b] && this["pointer" + b].active == false) {
                            return this["pointer" + b].start(h)
                        }
                    }
                }
            }
            return null
        },
        updatePointer: function (h) {
            if (this.pointer1.active && this.pointer1.identifier == h.identifier) {
                return this.pointer1.move(h)
            } else {
                if (this.pointer2.active && this.pointer2.identifier == h.identifier) {
                    return this.pointer2.move(h)
                } else {
                    for (var b = 3; b <= 10; b++) {
                        if (this["pointer" + b] && this["pointer" + b].active && this["pointer" + b].identifier == h.identifier) {
                            return this["pointer" + b].move(h)
                        }
                    }
                }
            }
            return null
        },
        stopPointer: function (h) {
            if (this.pointer1.active && this.pointer1.identifier == h.identifier) {
                return this.pointer1.stop(h)
            } else {
                if (this.pointer2.active && this.pointer2.identifier == h.identifier) {
                    return this.pointer2.stop(h)
                } else {
                    for (var b = 3; b <= 10; b++) {
                        if (this["pointer" + b] && this["pointer" + b].active && this["pointer" + b].identifier == h.identifier) {
                            return this["pointer" + b].stop(h)
                        }
                    }
                }
            }
            return null
        },
        getPointer: function (h) {
            h = h || false;
            if (this.pointer1.active == h) {
                return this.pointer1
            } else {
                if (this.pointer2.active == h) {
                    return this.pointer2
                } else {
                    for (var b = 3; b <= 10; b++) {
                        if (this["pointer" + b] && this["pointer" + b].active == h) {
                            return this["pointer" + b]
                        }
                    }
                }
            }
            return null
        },
        getPointerFromIdentifier: function (b) {
            if (this.pointer1.identifier == b) {
                return this.pointer1
            } else {
                if (this.pointer2.identifier == b) {
                    return this.pointer2
                } else {
                    for (var h = 3; h <= 10; h++) {
                        if (this["pointer" + h] && this["pointer" + h].identifier == b) {
                            return this["pointer" + h]
                        }
                    }
                }
            }
            return null
        }
    };
    Object.defineProperty(d.Input.prototype, "x", {
        get: function () {
            return this._x
        }, set: function (b) {
            this._x = Math.floor(b)
        }
    });
    Object.defineProperty(d.Input.prototype, "y", {
        get: function () {
            return this._y
        }, set: function (b) {
            this._y = Math.floor(b)
        }
    });
    Object.defineProperty(d.Input.prototype, "pollLocked", {
        get: function () {
            return (this.pollRate > 0 && this._pollCounter < this.pollRate)
        }
    });
    Object.defineProperty(d.Input.prototype, "totalInactivePointers", {
        get: function () {
            return 10 - this.currentPointers
        }
    });
    Object.defineProperty(d.Input.prototype, "totalActivePointers", {
        get: function () {
            this.currentPointers = 0;
            for (var b = 1; b <= 10; b++) {
                if (this["pointer" + b] && this["pointer" + b].active) {
                    this.currentPointers++
                }
            }
            return this.currentPointers
        }
    });
    Object.defineProperty(d.Input.prototype, "worldX", {
        get: function () {
            return this.game.camera.view.x + this.x
        }
    });
    Object.defineProperty(d.Input.prototype, "worldY", {
        get: function () {
            return this.game.camera.view.y + this.y
        }
    });
    d.Key = function (h, b) {
        this.game = h;
        this.isDown = false;
        this.isUp = false;
        this.altKey = false;
        this.ctrlKey = false;
        this.shiftKey = false;
        this.timeDown = 0;
        this.duration = 0;
        this.timeUp = 0;
        this.repeats = 0;
        this.keyCode = b;
        this.onDown = new d.Signal();
        this.onUp = new d.Signal()
    };
    d.Key.prototype = {
        processKeyDown: function (b) {
            this.altKey = b.altKey;
            this.ctrlKey = b.ctrlKey;
            this.shiftKey = b.shiftKey;
            if (this.isDown) {
                this.duration = b.timeStamp - this.timeDown;
                this.repeats++
            } else {
                this.isDown = true;
                this.isUp = false;
                this.timeDown = b.timeStamp;
                this.duration = 0;
                this.repeats = 0;
                this.onDown.dispatch(this)
            }
        }, processKeyUp: function (b) {
            this.isDown = false;
            this.isUp = true;
            this.timeUp = b.timeStamp;
            this.onUp.dispatch(this)
        }, justPressed: function (b) {
            if (typeof b === "undefined") {
                b = 250
            }
            return (this.isDown && this.duration < b)
        }, justReleased: function (b) {
            if (typeof b === "undefined") {
                b = 250
            }
            return (this.isDown == false && (this.game.time.now - this.timeUp < b))
        }
    };
    d.Keyboard = function (b) {
        this.game = b;
        this._keys = {};
        this._hotkeys = {};
        this._capture = {};
        this.disabled = false;
        this._onKeyDown = null;
        this._onKeyUp = null;
        this.callbackContext = this;
        this.onDownCallback = null;
        this.onUpCallback = null
    };
    d.Keyboard.prototype = {
        addCallbacks: function (b, h, i) {
            this.callbackContext = b;
            this.onDownCallback = h;
            if (typeof i !== "undefined") {
                this.onUpCallback = i
            }
        }, addKey: function (b) {
            this._hotkeys[b] = new d.Key(this.game, b);
            this.addKeyCapture(b);
            return this._hotkeys[b]
        }, removeKey: function (b) {
            delete (this._hotkeys[b])
        }, createCursorKeys: function () {
            return {
                up: this.addKey(d.Keyboard.UP),
                down: this.addKey(d.Keyboard.DOWN),
                left: this.addKey(d.Keyboard.LEFT),
                right: this.addKey(d.Keyboard.RIGHT)
            }
        }, start: function () {
            var b = this;
            this._onKeyDown = function (h) {
                return b.processKeyDown(h)
            };
            this._onKeyUp = function (h) {
                return b.processKeyUp(h)
            };
            document.body.addEventListener("keydown", this._onKeyDown, false);
            document.body.addEventListener("keyup", this._onKeyUp, false)
        }, stop: function () {
            document.body.removeEventListener("keydown", this._onKeyDown);
            document.body.removeEventListener("keyup", this._onKeyUp)
        }, addKeyCapture: function (b) {
            if (typeof b === "object") {
                for (var h in b) {
                    this._capture[b[h]] = true
                }
            } else {
                this._capture[b] = true
            }
        }, removeKeyCapture: function (b) {
            delete this._capture[b]
        }, clearCaptures: function () {
            this._capture = {}
        }, processKeyDown: function (b) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this._capture[b.keyCode]) {
                b.preventDefault()
            }
            if (this.onDownCallback) {
                this.onDownCallback.call(this.callbackContext, b)
            }
            if (this._keys[b.keyCode] && this._keys[b.keyCode].isDown) {
                this._keys[b.keyCode].duration = this.game.time.now - this._keys[b.keyCode].timeDown
            } else {
                if (!this._keys[b.keyCode]) {
                    this._keys[b.keyCode] = {isDown: true, timeDown: this.game.time.now, timeUp: 0, duration: 0}
                } else {
                    this._keys[b.keyCode].isDown = true;
                    this._keys[b.keyCode].timeDown = this.game.time.now;
                    this._keys[b.keyCode].duration = 0
                }
            }
            if (this._hotkeys[b.keyCode]) {
                this._hotkeys[b.keyCode].processKeyDown(b)
            }
        }, processKeyUp: function (b) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this._capture[b.keyCode]) {
                b.preventDefault()
            }
            if (this.onUpCallback) {
                this.onUpCallback.call(this.callbackContext, b)
            }
            if (this._hotkeys[b.keyCode]) {
                this._hotkeys[b.keyCode].processKeyUp(b)
            }
            if (this._keys[b.keyCode]) {
                this._keys[b.keyCode].isDown = false;
                this._keys[b.keyCode].timeUp = this.game.time.now
            } else {
                this._keys[b.keyCode] = {
                    isDown: false,
                    timeDown: this.game.time.now,
                    timeUp: this.game.time.now,
                    duration: 0
                }
            }
        }, reset: function () {
            for (var b in this._keys) {
                this._keys[b].isDown = false
            }
        }, justPressed: function (b, h) {
            if (typeof h === "undefined") {
                h = 250
            }
            if (this._keys[b] && this._keys[b].isDown && this._keys[b].duration < h) {
                return true
            }
            return false
        }, justReleased: function (b, h) {
            if (typeof h === "undefined") {
                h = 250
            }
            if (this._keys[b] && this._keys[b].isDown === false && (this.game.time.now - this._keys[b].timeUp < h)) {
                return true
            }
            return false
        }, isDown: function (b) {
            if (this._keys[b]) {
                return this._keys[b].isDown
            }
            return false
        }
    };
    d.Keyboard.A = "A".charCodeAt(0);
    d.Keyboard.B = "B".charCodeAt(0);
    d.Keyboard.C = "C".charCodeAt(0);
    d.Keyboard.D = "D".charCodeAt(0);
    d.Keyboard.E = "E".charCodeAt(0);
    d.Keyboard.F = "F".charCodeAt(0);
    d.Keyboard.G = "G".charCodeAt(0);
    d.Keyboard.H = "H".charCodeAt(0);
    d.Keyboard.I = "I".charCodeAt(0);
    d.Keyboard.J = "J".charCodeAt(0);
    d.Keyboard.K = "K".charCodeAt(0);
    d.Keyboard.L = "L".charCodeAt(0);
    d.Keyboard.M = "M".charCodeAt(0);
    d.Keyboard.N = "N".charCodeAt(0);
    d.Keyboard.O = "O".charCodeAt(0);
    d.Keyboard.P = "P".charCodeAt(0);
    d.Keyboard.Q = "Q".charCodeAt(0);
    d.Keyboard.R = "R".charCodeAt(0);
    d.Keyboard.S = "S".charCodeAt(0);
    d.Keyboard.T = "T".charCodeAt(0);
    d.Keyboard.U = "U".charCodeAt(0);
    d.Keyboard.V = "V".charCodeAt(0);
    d.Keyboard.W = "W".charCodeAt(0);
    d.Keyboard.X = "X".charCodeAt(0);
    d.Keyboard.Y = "Y".charCodeAt(0);
    d.Keyboard.Z = "Z".charCodeAt(0);
    d.Keyboard.ZERO = "0".charCodeAt(0);
    d.Keyboard.ONE = "1".charCodeAt(0);
    d.Keyboard.TWO = "2".charCodeAt(0);
    d.Keyboard.THREE = "3".charCodeAt(0);
    d.Keyboard.FOUR = "4".charCodeAt(0);
    d.Keyboard.FIVE = "5".charCodeAt(0);
    d.Keyboard.SIX = "6".charCodeAt(0);
    d.Keyboard.SEVEN = "7".charCodeAt(0);
    d.Keyboard.EIGHT = "8".charCodeAt(0);
    d.Keyboard.NINE = "9".charCodeAt(0);
    d.Keyboard.NUMPAD_0 = 96;
    d.Keyboard.NUMPAD_1 = 97;
    d.Keyboard.NUMPAD_2 = 98;
    d.Keyboard.NUMPAD_3 = 99;
    d.Keyboard.NUMPAD_4 = 100;
    d.Keyboard.NUMPAD_5 = 101;
    d.Keyboard.NUMPAD_6 = 102;
    d.Keyboard.NUMPAD_7 = 103;
    d.Keyboard.NUMPAD_8 = 104;
    d.Keyboard.NUMPAD_9 = 105;
    d.Keyboard.NUMPAD_MULTIPLY = 106;
    d.Keyboard.NUMPAD_ADD = 107;
    d.Keyboard.NUMPAD_ENTER = 108;
    d.Keyboard.NUMPAD_SUBTRACT = 109;
    d.Keyboard.NUMPAD_DECIMAL = 110;
    d.Keyboard.NUMPAD_DIVIDE = 111;
    d.Keyboard.F1 = 112;
    d.Keyboard.F2 = 113;
    d.Keyboard.F3 = 114;
    d.Keyboard.F4 = 115;
    d.Keyboard.F5 = 116;
    d.Keyboard.F6 = 117;
    d.Keyboard.F7 = 118;
    d.Keyboard.F8 = 119;
    d.Keyboard.F9 = 120;
    d.Keyboard.F10 = 121;
    d.Keyboard.F11 = 122;
    d.Keyboard.F12 = 123;
    d.Keyboard.F13 = 124;
    d.Keyboard.F14 = 125;
    d.Keyboard.F15 = 126;
    d.Keyboard.COLON = 186;
    d.Keyboard.EQUALS = 187;
    d.Keyboard.UNDERSCORE = 189;
    d.Keyboard.QUESTION_MARK = 191;
    d.Keyboard.TILDE = 192;
    d.Keyboard.OPEN_BRACKET = 219;
    d.Keyboard.BACKWARD_SLASH = 220;
    d.Keyboard.CLOSED_BRACKET = 221;
    d.Keyboard.QUOTES = 222;
    d.Keyboard.BACKSPACE = 8;
    d.Keyboard.TAB = 9;
    d.Keyboard.CLEAR = 12;
    d.Keyboard.ENTER = 13;
    d.Keyboard.SHIFT = 16;
    d.Keyboard.CONTROL = 17;
    d.Keyboard.ALT = 18;
    d.Keyboard.CAPS_LOCK = 20;
    d.Keyboard.ESC = 27;
    d.Keyboard.SPACEBAR = 32;
    d.Keyboard.PAGE_UP = 33;
    d.Keyboard.PAGE_DOWN = 34;
    d.Keyboard.END = 35;
    d.Keyboard.HOME = 36;
    d.Keyboard.LEFT = 37;
    d.Keyboard.UP = 38;
    d.Keyboard.RIGHT = 39;
    d.Keyboard.DOWN = 40;
    d.Keyboard.INSERT = 45;
    d.Keyboard.DELETE = 46;
    d.Keyboard.HELP = 47;
    d.Keyboard.NUM_LOCK = 144;
    d.Mouse = function (b) {
        this.game = b;
        this.callbackContext = this.game;
        this.mouseDownCallback = null;
        this.mouseMoveCallback = null;
        this.mouseUpCallback = null;
        this.disabled = false;
        this.locked = false
    };
    d.Mouse.LEFT_BUTTON = 0;
    d.Mouse.MIDDLE_BUTTON = 1;
    d.Mouse.RIGHT_BUTTON = 2;
    d.Mouse.prototype = {
        start: function () {
            var b = this;
            if (this.game.device.android && this.game.device.chrome == false) {
                return
            }
            this._onMouseDown = function (h) {
                return b.onMouseDown(h)
            };
            this._onMouseMove = function (h) {
                return b.onMouseMove(h)
            };
            this._onMouseUp = function (h) {
                return b.onMouseUp(h)
            };
            this.game.renderer.view.addEventListener("mousedown", this._onMouseDown, true);
            this.game.renderer.view.addEventListener("mousemove", this._onMouseMove, true);
            this.game.renderer.view.addEventListener("mouseup", this._onMouseUp, true)
        }, onMouseDown: function (b) {
            b.preventDefault();
            if (this.mouseDownCallback) {
                this.mouseDownCallback.call(this.callbackContext, b)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            b.identifier = 0;
            this.game.input.mousePointer.start(b)
        }, onMouseMove: function (b) {
            b.preventDefault();
            if (this.mouseMoveCallback) {
                this.mouseMoveCallback.call(this.callbackContext, b)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            b.identifier = 0;
            this.game.input.mousePointer.move(b)
        }, onMouseUp: function (b) {
            b.preventDefault();
            if (this.mouseUpCallback) {
                this.mouseUpCallback.call(this.callbackContext, b)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            b.identifier = 0;
            this.game.input.mousePointer.stop(b)
        }, requestPointerLock: function () {
            if (this.game.device.pointerLock) {
                var b = this.game.stage.canvas;
                b.requestPointerLock = b.requestPointerLock || b.mozRequestPointerLock || b.webkitRequestPointerLock;
                b.requestPointerLock();
                var h = this;
                this._pointerLockChange = function (i) {
                    return h.pointerLockChange(i)
                };
                document.addEventListener("pointerlockchange", this._pointerLockChange, false);
                document.addEventListener("mozpointerlockchange", this._pointerLockChange, false);
                document.addEventListener("webkitpointerlockchange", this._pointerLockChange, false)
            }
        }, pointerLockChange: function (h) {
            var b = this.game.stage.canvas;
            if (document.pointerLockElement === b || document.mozPointerLockElement === b || document.webkitPointerLockElement === b) {
                this.locked = true
            } else {
                this.locked = false
            }
        }, releasePointerLock: function () {
            document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
            document.exitPointerLock();
            document.removeEventListener("pointerlockchange", this._pointerLockChange);
            document.removeEventListener("mozpointerlockchange", this._pointerLockChange);
            document.removeEventListener("webkitpointerlockchange", this._pointerLockChange)
        }, stop: function () {
            this.game.stage.canvas.removeEventListener("mousedown", this._onMouseDown);
            this.game.stage.canvas.removeEventListener("mousemove", this._onMouseMove);
            this.game.stage.canvas.removeEventListener("mouseup", this._onMouseUp)
        }
    };
    d.MSPointer = function (b) {
        this.game = b;
        this.callbackContext = this.game;
        this.mouseDownCallback = null;
        this.mouseMoveCallback = null;
        this.mouseUpCallback = null;
        this.disabled = false;
        this._onMSPointerDown = null;
        this._onMSPointerMove = null;
        this._onMSPointerUp = null
    };
    d.MSPointer.prototype = {
        start: function () {
            var b = this;
            if (this.game.device.mspointer == true) {
                this._onMSPointerDown = function (h) {
                    return b.onPointerDown(h)
                };
                this._onMSPointerMove = function (h) {
                    return b.onPointerMove(h)
                };
                this._onMSPointerUp = function (h) {
                    return b.onPointerUp(h)
                };
                this.game.renderer.view.addEventListener("MSPointerDown", this._onMSPointerDown, false);
                this.game.renderer.view.addEventListener("MSPointerMove", this._onMSPointerMove, false);
                this.game.renderer.view.addEventListener("MSPointerUp", this._onMSPointerUp, false);
                this.game.renderer.view.style["-ms-content-zooming"] = "none";
                this.game.renderer.view.style["-ms-touch-action"] = "none"
            }
        }, onPointerDown: function (b) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            b.preventDefault();
            b.identifier = b.pointerId;
            this.game.input.startPointer(b)
        }, onPointerMove: function (b) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            b.preventDefault();
            b.identifier = b.pointerId;
            this.game.input.updatePointer(b)
        }, onPointerUp: function (b) {
            if (this.game.input.disabled || this.disabled) {
                return
            }
            b.preventDefault();
            b.identifier = b.pointerId;
            this.game.input.stopPointer(b)
        }, stop: function () {
            this.game.stage.canvas.removeEventListener("MSPointerDown", this._onMSPointerDown);
            this.game.stage.canvas.removeEventListener("MSPointerMove", this._onMSPointerMove);
            this.game.stage.canvas.removeEventListener("MSPointerUp", this._onMSPointerUp)
        }
    };
    d.Pointer = function (b, h) {
        this.game = b;
        this.id = h;
        this._holdSent = false;
        this._history = [];
        this._nextDrop = 0;
        this._stateReset = false;
        this.positionDown = null;
        this.position = null;
        this.circle = null;
        this.withinGame = false;
        this.clientX = -1;
        this.clientY = -1;
        this.pageX = -1;
        this.pageY = -1;
        this.screenX = -1;
        this.screenY = -1;
        this.x = -1;
        this.y = -1;
        this.isMouse = false;
        this.isDown = false;
        this.isUp = true;
        this.timeDown = 0;
        this.timeUp = 0;
        this.previousTapTime = 0;
        this.totalTouches = 0;
        this.msSinceLastClick = Number.MAX_VALUE;
        this.targetObject = null;
        this.active = false;
        this.position = new d.Point();
        this.positionDown = new d.Point();
        this.circle = new d.Circle(0, 0, 44);
        if (h == 0) {
            this.isMouse = true
        }
    };
    d.Pointer.prototype = {
        start: function (b) {
            this.identifier = b.identifier;
            this.target = b.target;
            if (typeof b.button !== "undefined") {
                this.button = b.button
            }
            if (this.game.paused == true && this.game.stage.scale.incorrectOrientation == false) {
                this.game.paused = false;
                return this
            }
            this._history.length = 0;
            this.active = true;
            this.withinGame = true;
            this.isDown = true;
            this.isUp = false;
            this.msSinceLastClick = this.game.time.now - this.timeDown;
            this.timeDown = this.game.time.now;
            this._holdSent = false;
            this.move(b);
            this.positionDown.setTo(this.x, this.y);
            if (this.game.input.multiInputOverride == d.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == d.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == d.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers == 0)) {
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.x, this.y);
                this.game.input.onDown.dispatch(this, b);
                this.game.input.resetSpeed(this.x, this.y)
            }
            this._stateReset = false;
            this.totalTouches++;
            if (this.isMouse == false) {
                this.game.input.currentPointers++
            }
            if (this.targetObject !== null) {
                this.targetObject._touchedHandler(this)
            }
            return this
        }, update: function () {
            if (this.active) {
                if (this._holdSent == false && this.duration >= this.game.input.holdRate) {
                    if (this.game.input.multiInputOverride == d.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == d.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == d.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers == 0)) {
                        this.game.input.onHold.dispatch(this)
                    }
                    this._holdSent = true
                }
                if (this.game.input.recordPointerHistory && this.game.time.now >= this._nextDrop) {
                    this._nextDrop = this.game.time.now + this.game.input.recordRate;
                    this._history.push({x: this.position.x, y: this.position.y});
                    if (this._history.length > this.game.input.recordLimit) {
                        this._history.shift()
                    }
                }
            }
        }, move: function (h) {
            if (this.game.input.pollLocked) {
                return
            }
            if (typeof h.button !== "undefined") {
                this.button = h.button
            }
            this.clientX = h.clientX;
            this.clientY = h.clientY;
            this.pageX = h.pageX;
            this.pageY = h.pageY;
            this.screenX = h.screenX;
            this.screenY = h.screenY;
            this.x = (this.pageX - this.game.stage.offset.x) * this.game.input.scale.x;
            this.y = (this.pageY - this.game.stage.offset.y) * this.game.input.scale.y;
            this.position.setTo(this.x, this.y);
            this.circle.x = this.x;
            this.circle.y = this.y;
            if (this.game.input.multiInputOverride == d.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == d.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == d.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers == 0)) {
                this.game.input.activePointer = this;
                this.game.input.x = this.x;
                this.game.input.y = this.y;
                this.game.input.position.setTo(this.game.input.x, this.game.input.y);
                this.game.input.circle.x = this.game.input.x;
                this.game.input.circle.y = this.game.input.y
            }
            if (this.game.paused) {
                return this
            }
            if (this.targetObject !== null && this.targetObject.isDragged == true) {
                if (this.targetObject.update(this) == false) {
                    this.targetObject = null
                }
                return this
            }
            this._highestRenderOrderID = -1;
            this._highestRenderObject = null;
            this._highestInputPriorityID = -1;
            if (this.game.input.interactiveItems.total > 0) {
                var b = this.game.input.interactiveItems.next;
                do {
                    if (b.pixelPerfect || b.priorityID > this._highestInputPriorityID || (b.priorityID == this._highestInputPriorityID && b.sprite.renderOrderID > this._highestRenderOrderID)) {
                        if (b.checkPointerOver(this)) {
                            this._highestRenderOrderID = b.sprite.renderOrderID;
                            this._highestInputPriorityID = b.priorityID;
                            this._highestRenderObject = b
                        }
                    }
                    b = b.next
                } while (b != null)
            }
            if (this._highestRenderObject == null) {
                if (this.targetObject) {
                    this.targetObject._pointerOutHandler(this);
                    this.targetObject = null
                }
            } else {
                if (this.targetObject == null) {
                    this.targetObject = this._highestRenderObject;
                    this._highestRenderObject._pointerOverHandler(this)
                } else {
                    if (this.targetObject == this._highestRenderObject) {
                        if (this._highestRenderObject.update(this) == false) {
                            this.targetObject = null
                        }
                    } else {
                        this.targetObject._pointerOutHandler(this);
                        this.targetObject = this._highestRenderObject;
                        this.targetObject._pointerOverHandler(this)
                    }
                }
            }
            return this
        }, leave: function (b) {
            this.withinGame = false;
            this.move(b)
        }, stop: function (h) {
            if (this._stateReset) {
                h.preventDefault();
                return
            }
            this.timeUp = this.game.time.now;
            if (this.game.input.multiInputOverride == d.Input.MOUSE_OVERRIDES_TOUCH || this.game.input.multiInputOverride == d.Input.MOUSE_TOUCH_COMBINE || (this.game.input.multiInputOverride == d.Input.TOUCH_OVERRIDES_MOUSE && this.game.input.currentPointers == 0)) {
                this.game.input.onUp.dispatch(this, h);
                if (this.duration >= 0 && this.duration <= this.game.input.tapRate) {
                    if (this.timeUp - this.previousTapTime < this.game.input.doubleTapRate) {
                        this.game.input.onTap.dispatch(this, true)
                    } else {
                        this.game.input.onTap.dispatch(this, false)
                    }
                    this.previousTapTime = this.timeUp
                }
            }
            if (this.id > 0) {
                this.active = false
            }
            this.withinGame = false;
            this.isDown = false;
            this.isUp = true;
            if (this.isMouse == false) {
                this.game.input.currentPointers--
            }
            if (this.game.input.interactiveItems.total > 0) {
                var b = this.game.input.interactiveItems.next;
                do {
                    if (b) {
                        b._releasedHandler(this)
                    }
                    b = b.next
                } while (b != null)
            }
            if (this.targetObject) {
                this.targetObject._releasedHandler(this)
            }
            this.targetObject = null;
            return this
        }, justPressed: function (b) {
            b = b || this.game.input.justPressedRate;
            return (this.isDown === true && (this.timeDown + b) > this.game.time.now)
        }, justReleased: function (b) {
            b = b || this.game.input.justReleasedRate;
            return (this.isUp === true && (this.timeUp + b) > this.game.time.now)
        }, reset: function () {
            if (this.isMouse == false) {
                this.active = false
            }
            this.identifier = null;
            this.isDown = false;
            this.isUp = true;
            this.totalTouches = 0;
            this._holdSent = false;
            this._history.length = 0;
            this._stateReset = true;
            if (this.targetObject) {
                this.targetObject._releasedHandler(this)
            }
            this.targetObject = null
        }, toString: function () {
            return "[{Pointer (id=" + this.id + " identifer=" + this.identifier + " active=" + this.active + " duration=" + this.duration + " withinGame=" + this.withinGame + " x=" + this.x + " y=" + this.y + " clientX=" + this.clientX + " clientY=" + this.clientY + " screenX=" + this.screenX + " screenY=" + this.screenY + " pageX=" + this.pageX + " pageY=" + this.pageY + ")}]"
        }
    };
    Object.defineProperty(d.Pointer.prototype, "duration", {
        get: function () {
            if (this.isUp) {
                return -1
            }
            return this.game.time.now - this.timeDown
        }
    });
    Object.defineProperty(d.Pointer.prototype, "worldX", {
        get: function () {
            return this.game.world.camera.x + this.x
        }
    });
    Object.defineProperty(d.Pointer.prototype, "worldY", {
        get: function () {
            return this.game.world.camera.y + this.y
        }
    });
    d.Touch = function (b) {
        this.game = b;
        this.disabled = false;
        this.callbackContext = this.game;
        this.touchStartCallback = null;
        this.touchMoveCallback = null;
        this.touchEndCallback = null;
        this.touchEnterCallback = null;
        this.touchLeaveCallback = null;
        this.touchCancelCallback = null;
        this.preventDefault = true;
        this._onTouchStart = null;
        this._onTouchMove = null;
        this._onTouchEnd = null;
        this._onTouchEnter = null;
        this._onTouchLeave = null;
        this._onTouchCancel = null;
        this._onTouchMove = null
    };
    d.Touch.prototype = {
        start: function () {
            var b = this;
            if (this.game.device.touch) {
                this._onTouchStart = function (h) {
                    return b.onTouchStart(h)
                };
                this._onTouchMove = function (h) {
                    return b.onTouchMove(h)
                };
                this._onTouchEnd = function (h) {
                    return b.onTouchEnd(h)
                };
                this._onTouchEnter = function (h) {
                    return b.onTouchEnter(h)
                };
                this._onTouchLeave = function (h) {
                    return b.onTouchLeave(h)
                };
                this._onTouchCancel = function (h) {
                    return b.onTouchCancel(h)
                };
                this.game.renderer.view.addEventListener("touchstart", this._onTouchStart, false);
                this.game.renderer.view.addEventListener("touchmove", this._onTouchMove, false);
                this.game.renderer.view.addEventListener("touchend", this._onTouchEnd, false);
                this.game.renderer.view.addEventListener("touchenter", this._onTouchEnter, false);
                this.game.renderer.view.addEventListener("touchleave", this._onTouchLeave, false);
                this.game.renderer.view.addEventListener("touchcancel", this._onTouchCancel, false)
            }
        }, consumeDocumentTouches: function () {
            this._documentTouchMove = function (b) {
                b.preventDefault()
            };
            document.addEventListener("touchmove", this._documentTouchMove, false)
        }, onTouchStart: function (h) {
            if (this.touchStartCallback) {
                this.touchStartCallback.call(this.callbackContext, h)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this.preventDefault) {
                h.preventDefault()
            }
            for (var b = 0; b < h.changedTouches.length; b++) {
                this.game.input.startPointer(h.changedTouches[b])
            }
        }, onTouchCancel: function (h) {
            if (this.touchCancelCallback) {
                this.touchCancelCallback.call(this.callbackContext, h)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this.preventDefault) {
                h.preventDefault()
            }
            for (var b = 0; b < h.changedTouches.length; b++) {
                this.game.input.stopPointer(h.changedTouches[b])
            }
        }, onTouchEnter: function (h) {
            if (this.touchEnterCallback) {
                this.touchEnterCallback.call(this.callbackContext, h)
            }
            if (this.game.input.disabled || this.disabled) {
                return
            }
            if (this.preventDefault) {
                h.preventDefault()
            }
            for (var b = 0; b < h.changedTouches.length; b++) {
            }
        }, onTouchLeave: function (h) {
            if (this.touchLeaveCallback) {
                this.touchLeaveCallback.call(this.callbackContext, h)
            }
            if (this.preventDefault) {
                h.preventDefault()
            }
            for (var b = 0; b < h.changedTouches.length; b++) {
            }
        }, onTouchMove: function (h) {
            if (this.touchMoveCallback) {
                this.touchMoveCallback.call(this.callbackContext, h)
            }
            if (this.preventDefault) {
                h.preventDefault()
            }
            for (var b = 0; b < h.changedTouches.length; b++) {
                this.game.input.updatePointer(h.changedTouches[b])
            }
        }, onTouchEnd: function (h) {
            if (this.touchEndCallback) {
                this.touchEndCallback.call(this.callbackContext, h)
            }
            if (this.preventDefault) {
                h.preventDefault()
            }
            for (var b = 0; b < h.changedTouches.length; b++) {
                this.game.input.stopPointer(h.changedTouches[b])
            }
        }, stop: function () {
            if (this.game.device.touch) {
                this.game.stage.canvas.removeEventListener("touchstart", this._onTouchStart);
                this.game.stage.canvas.removeEventListener("touchmove", this._onTouchMove);
                this.game.stage.canvas.removeEventListener("touchend", this._onTouchEnd);
                this.game.stage.canvas.removeEventListener("touchenter", this._onTouchEnter);
                this.game.stage.canvas.removeEventListener("touchleave", this._onTouchLeave);
                this.game.stage.canvas.removeEventListener("touchcancel", this._onTouchCancel)
            }
        }
    };
    d.InputHandler = function (b) {
        this.sprite = b;
        this.game = b.game;
        this.enabled = false;
        this.parent = null;
        this.next = null;
        this.prev = null;
        this.last = this;
        this.first = this;
        this.priorityID = 0;
        this.useHandCursor = false;
        this.isDragged = false;
        this.allowHorizontalDrag = true;
        this.allowVerticalDrag = true;
        this.bringToTop = false;
        this.snapOffset = null;
        this.snapOnDrag = false;
        this.snapOnRelease = false;
        this.snapX = 0;
        this.snapY = 0;
        this.pixelPerfect = false;
        this.pixelPerfectAlpha = 255;
        this.draggable = false;
        this.boundsRect = null;
        this.boundsSprite = null;
        this.consumePointerEvent = false;
        this._tempPoint = new d.Point;
        this._pointerData = [];
        this._pointerData.push({
            id: 0,
            x: 0,
            y: 0,
            isDown: false,
            isUp: false,
            isOver: false,
            isOut: false,
            timeOver: 0,
            timeOut: 0,
            timeDown: 0,
            timeUp: 0,
            downDuration: 0,
            isDragged: false
        })
    };
    d.InputHandler.prototype = {
        start: function (j, b) {
            j = j || 0;
            if (typeof b == "undefined") {
                b = false
            }
            if (this.enabled == false) {
                this.game.input.interactiveItems.add(this);
                this.useHandCursor = b;
                this.priorityID = j;
                for (var h = 0; h < 10; h++) {
                    this._pointerData[h] = {
                        id: h,
                        x: 0,
                        y: 0,
                        isDown: false,
                        isUp: false,
                        isOver: false,
                        isOut: false,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: false
                    }
                }
                this.snapOffset = new d.Point;
                this.enabled = true;
                if (this.sprite.events && this.sprite.events.onInputOver == null) {
                    this.sprite.events.onInputOver = new d.Signal;
                    this.sprite.events.onInputOut = new d.Signal;
                    this.sprite.events.onInputDown = new d.Signal;
                    this.sprite.events.onInputUp = new d.Signal;
                    this.sprite.events.onDragStart = new d.Signal;
                    this.sprite.events.onDragStop = new d.Signal
                }
            }
            return this.sprite
        }, reset: function () {
            this.enabled = false;
            for (var b = 0; b < 10; b++) {
                this._pointerData[b] = {
                    id: b,
                    x: 0,
                    y: 0,
                    isDown: false,
                    isUp: false,
                    isOver: false,
                    isOut: false,
                    timeOver: 0,
                    timeOut: 0,
                    timeDown: 0,
                    timeUp: 0,
                    downDuration: 0,
                    isDragged: false
                }
            }
        }, stop: function () {
            if (this.enabled == false) {
                return
            } else {
                this.enabled = false;
                this.game.input.interactiveItems.remove(this)
            }
        }, destroy: function () {
            if (this.enabled) {
                this.enabled = false;
                this.game.input.interactiveItems.remove(this);
                this.stop();
                this.sprite = null
            }
        }, pointerX: function (b) {
            b = b || 0;
            return this._pointerData[b].x
        }, pointerY: function (b) {
            b = b || 0;
            return this._pointerData[b].y
        }, pointerDown: function (b) {
            b = b || 0;
            return this._pointerData[b].isDown
        }, pointerUp: function (b) {
            b = b || 0;
            return this._pointerData[b].isUp
        }, pointerTimeDown: function (b) {
            b = b || 0;
            return this._pointerData[b].timeDown
        }, pointerTimeUp: function (b) {
            b = b || 0;
            return this._pointerData[b].timeUp
        }, pointerOver: function (b) {
            b = b || 0;
            return this._pointerData[b].isOver
        }, pointerOut: function (b) {
            b = b || 0;
            return this._pointerData[b].isOut
        }, pointerTimeOver: function (b) {
            b = b || 0;
            return this._pointerData[b].timeOver
        }, pointerTimeOut: function (b) {
            b = b || 0;
            return this._pointerData[b].timeOut
        }, pointerDragged: function (b) {
            b = b || 0;
            return this._pointerData[b].isDragged
        }, checkPointerOver: function (b) {
            if (this.enabled && this.sprite.visible) {
                this.sprite.getLocalUnmodifiedPosition(this._tempPoint, b.x, b.y);
                if (this._tempPoint.x >= 0 && this._tempPoint.x <= this.sprite.currentFrame.width && this._tempPoint.y >= 0 && this._tempPoint.y <= this.sprite.currentFrame.height) {
                    if (this.pixelPerfect) {
                        return this.checkPixel(this._tempPoint.x, this._tempPoint.y)
                    } else {
                        return true
                    }
                }
            }
            return false
        }, checkPixel: function (b, i) {
            if (this.sprite.texture.baseTexture.source) {
                this.game.input.hitContext.clearRect(0, 0, 1, 1);
                b += this.sprite.texture.frame.x;
                i += this.sprite.texture.frame.y;
                this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, b, i, 1, 1, 0, 0, 1, 1);
                var h = this.game.input.hitContext.getImageData(0, 0, 1, 1);
                if (h.data[3] >= this.pixelPerfectAlpha) {
                    return true
                }
            }
            return false
        }, update: function (b) {
            if (this.enabled == false || this.sprite.visible == false || (this.sprite.group && this.sprite.group.visible == false)) {
                this._pointerOutHandler(b);
                return false
            }
            if (this.draggable && this._draggedPointerID == b.id) {
                return this.updateDrag(b)
            } else {
                if (this._pointerData[b.id].isOver == true) {
                    if (this.checkPointerOver(b)) {
                        this._pointerData[b.id].x = b.x - this.sprite.x;
                        this._pointerData[b.id].y = b.y - this.sprite.y;
                        return true
                    } else {
                        this._pointerOutHandler(b);
                        return false
                    }
                }
            }
        }, _pointerOverHandler: function (b) {
            if (this._pointerData[b.id].isOver == false) {
                this._pointerData[b.id].isOver = true;
                this._pointerData[b.id].isOut = false;
                this._pointerData[b.id].timeOver = this.game.time.now;
                this._pointerData[b.id].x = b.x - this.sprite.x;
                this._pointerData[b.id].y = b.y - this.sprite.y;
                if (this.useHandCursor && this._pointerData[b.id].isDragged == false) {
                    this.game.stage.canvas.style.cursor = "pointer"
                }
                this.sprite.events.onInputOver.dispatch(this.sprite, b)
            }
        }, _pointerOutHandler: function (b) {
            this._pointerData[b.id].isOver = false;
            this._pointerData[b.id].isOut = true;
            this._pointerData[b.id].timeOut = this.game.time.now;
            if (this.useHandCursor && this._pointerData[b.id].isDragged == false) {
                this.game.stage.canvas.style.cursor = "default"
            }
            if (this.sprite && this.sprite.events) {
                this.sprite.events.onInputOut.dispatch(this.sprite, b)
            }
        }, _touchedHandler: function (b) {
            if (this._pointerData[b.id].isDown == false && this._pointerData[b.id].isOver == true) {
                this._pointerData[b.id].isDown = true;
                this._pointerData[b.id].isUp = false;
                this._pointerData[b.id].timeDown = this.game.time.now;
                this.sprite.events.onInputDown.dispatch(this.sprite, b);
                if (this.draggable && this.isDragged == false) {
                    this.startDrag(b)
                }
                if (this.bringToTop) {
                    this.sprite.bringToTop()
                }
            }
            return this.consumePointerEvent
        }, _releasedHandler: function (b) {
            if (this._pointerData[b.id].isDown && b.isUp) {
                this._pointerData[b.id].isDown = false;
                this._pointerData[b.id].isUp = true;
                this._pointerData[b.id].timeUp = this.game.time.now;
                this._pointerData[b.id].downDuration = this._pointerData[b.id].timeUp - this._pointerData[b.id].timeDown;
                if (this.checkPointerOver(b)) {
                    this.sprite.events.onInputUp.dispatch(this.sprite, b)
                } else {
                    if (this.useHandCursor) {
                        this.game.stage.canvas.style.cursor = "default"
                    }
                }
                if (this.draggable && this.isDragged && this._draggedPointerID == b.id) {
                    this.stopDrag(b)
                }
            }
        }, updateDrag: function (b) {
            if (b.isUp) {
                this.stopDrag(b);
                return false
            }
            if (this.allowHorizontalDrag) {
                this.sprite.x = b.x + this._dragPoint.x + this.dragOffset.x
            }
            if (this.allowVerticalDrag) {
                this.sprite.y = b.y + this._dragPoint.y + this.dragOffset.y
            }
            if (this.boundsRect) {
                this.checkBoundsRect()
            }
            if (this.boundsSprite) {
                this.checkBoundsSprite()
            }
            if (this.snapOnDrag) {
                this.sprite.x = Math.round(this.sprite.x / this.snapX) * this.snapX;
                this.sprite.y = Math.round(this.sprite.y / this.snapY) * this.snapY
            }
            return true
        }, justOver: function (h, b) {
            h = h || 0;
            b = b || 500;
            return (this._pointerData[h].isOver && this.overDuration(h) < b)
        }, justOut: function (h, b) {
            h = h || 0;
            b = b || 500;
            return (this._pointerData[h].isOut && (this.game.time.now - this._pointerData[h].timeOut < b))
        }, justPressed: function (h, b) {
            h = h || 0;
            b = b || 500;
            return (this._pointerData[h].isDown && this.downDuration(h) < b)
        }, justReleased: function (h, b) {
            h = h || 0;
            b = b || 500;
            return (this._pointerData[h].isUp && (this.game.time.now - this._pointerData[h].timeUp < b))
        }, overDuration: function (b) {
            b = b || 0;
            if (this._pointerData[b].isOver) {
                return this.game.time.now - this._pointerData[b].timeOver
            }
            return -1
        }, downDuration: function (b) {
            b = b || 0;
            if (this._pointerData[b].isDown) {
                return this.game.time.now - this._pointerData[b].timeDown
            }
            return -1
        }, enableDrag: function (h, k, b, j, l, i) {
            if (typeof h == "undefined") {
                h = false
            }
            if (typeof k == "undefined") {
                k = false
            }
            if (typeof b == "undefined") {
                b = false
            }
            j = j || 255;
            l = l || null;
            i = i || null;
            this._dragPoint = new d.Point();
            this.draggable = true;
            this.bringToTop = k;
            this.dragOffset = new d.Point();
            this.dragFromCenter = h;
            this.pixelPerfect = b;
            this.pixelPerfectAlpha = j;
            if (l) {
                this.boundsRect = l
            }
            if (i) {
                this.boundsSprite = i
            }
        }, disableDrag: function () {
            if (this._pointerData) {
                for (var b = 0; b < 10; b++) {
                    this._pointerData[b].isDragged = false
                }
            }
            this.draggable = false;
            this.isDragged = false;
            this._draggedPointerID = -1
        }, startDrag: function (b) {
            this.isDragged = true;
            this._draggedPointerID = b.id;
            this._pointerData[b.id].isDragged = true;
            if (this.dragFromCenter) {
                this.sprite.centerOn(b.x, b.y);
                this._dragPoint.setTo(this.sprite.x - b.x, this.sprite.y - b.y)
            } else {
                this._dragPoint.setTo(this.sprite.x - b.x, this.sprite.y - b.y)
            }
            this.updateDrag(b);
            if (this.bringToTop) {
                this.sprite.bringToTop()
            }
            this.sprite.events.onDragStart.dispatch(this.sprite, b)
        }, stopDrag: function (b) {
            this.isDragged = false;
            this._draggedPointerID = -1;
            this._pointerData[b.id].isDragged = false;
            if (this.snapOnRelease) {
                this.sprite.x = Math.round(this.sprite.x / this.snapX) * this.snapX;
                this.sprite.y = Math.round(this.sprite.y / this.snapY) * this.snapY
            }
            this.sprite.events.onDragStop.dispatch(this.sprite, b);
            this.sprite.events.onInputUp.dispatch(this.sprite, b);
            if (this.checkPointerOver(b) == false) {
                this._pointerOutHandler(b)
            }
        }, setDragLock: function (b, h) {
            if (typeof b == "undefined") {
                b = true
            }
            if (typeof h == "undefined") {
                h = true
            }
            this.allowHorizontalDrag = b;
            this.allowVerticalDrag = h
        }, enableSnap: function (j, i, h, b) {
            if (typeof h == "undefined") {
                h = true
            }
            if (typeof b == "undefined") {
                b = false
            }
            this.snapX = j;
            this.snapY = i;
            this.snapOnDrag = h;
            this.snapOnRelease = b
        }, disableSnap: function () {
            this.snapOnDrag = false;
            this.snapOnRelease = false
        }, checkBoundsRect: function () {
            if (this.sprite.x < this.boundsRect.left) {
                this.sprite.x = this.boundsRect.x
            } else {
                if ((this.sprite.x + this.sprite.width) > this.boundsRect.right) {
                    this.sprite.x = this.boundsRect.right - this.sprite.width
                }
            }
            if (this.sprite.y < this.boundsRect.top) {
                this.sprite.y = this.boundsRect.top
            } else {
                if ((this.sprite.y + this.sprite.height) > this.boundsRect.bottom) {
                    this.sprite.y = this.boundsRect.bottom - this.sprite.height
                }
            }
        }, checkBoundsSprite: function () {
            if (this.sprite.x < this.boundsSprite.x) {
                this.sprite.x = this.boundsSprite.x
            } else {
                if ((this.sprite.x + this.sprite.width) > (this.boundsSprite.x + this.boundsSprite.width)) {
                    this.sprite.x = (this.boundsSprite.x + this.boundsSprite.width) - this.sprite.width
                }
            }
            if (this.sprite.y < this.boundsSprite.y) {
                this.sprite.y = this.boundsSprite.y
            } else {
                if ((this.sprite.y + this.sprite.height) > (this.boundsSprite.y + this.boundsSprite.height)) {
                    this.sprite.y = (this.boundsSprite.y + this.boundsSprite.height) - this.sprite.height
                }
            }
        }
    };
    d.Events = function (b) {
        this.parent = b;
        this.onAddedToGroup = new d.Signal;
        this.onRemovedFromGroup = new d.Signal;
        this.onKilled = new d.Signal;
        this.onRevived = new d.Signal;
        this.onOutOfBounds = new d.Signal;
        this.onInputOver = null;
        this.onInputOut = null;
        this.onInputDown = null;
        this.onInputUp = null;
        this.onDragStart = null;
        this.onDragStop = null;
        this.onAnimationStart = null;
        this.onAnimationComplete = null;
        this.onAnimationLoop = null
    };
    d.Events.prototype = {
        destroy: function () {
            this.parent = null;
            this.onAddedToGroup.dispose();
            this.onRemovedFromGroup.dispose();
            this.onKilled.dispose();
            this.onRevived.dispose();
            this.onOutOfBounds.dispose();
            if (this.onInputOver) {
                this.onInputOver.dispose();
                this.onInputOut.dispose();
                this.onInputDown.dispose();
                this.onInputUp.dispose();
                this.onDragStart.dispose();
                this.onDragStop.dispose()
            }
            if (this.onAnimationStart) {
                this.onAnimationStart.dispose();
                this.onAnimationComplete.dispose();
                this.onAnimationLoop.dispose()
            }
        }
    };
    d.GameObjectFactory = function (b) {
        this.game = b;
        this.world = this.game.world
    };
    d.GameObjectFactory.prototype = {
        existing: function (b) {
            return this.world.add(b)
        }, sprite: function (b, j, h, i) {
            return this.world.create(b, j, h, i)
        }, child: function (i, b, k, h, j) {
            return i.create(b, k, h, j)
        }, tween: function (b) {
            return this.game.tweens.create(b)
        }, group: function (h, b) {
            return new d.Group(this.game, h, b)
        }, audio: function (h, i, b) {
            return this.game.sound.add(h, i, b)
        }, tileSprite: function (h, l, j, b, i, k) {
            return this.world.add(new d.TileSprite(this.game, h, l, j, b, i, k))
        }, text: function (b, j, i, h) {
            return this.world.add(new d.Text(this.game, b, j, i, h))
        }, button: function (b, n, l, m, j, i, k, h) {
            return this.world.add(new d.Button(this.game, b, n, l, m, j, i, k, h))
        }, graphics: function (b, h) {
            return this.world.add(new d.Graphics(this.game, b, h))
        }, emitter: function (b, i, h) {
            return this.game.particles.add(new d.Particles.Arcade.Emitter(this.game, b, i, h))
        }, bitmapText: function (b, j, i, h) {
            return this.world.add(new d.BitmapText(this.game, b, j, i, h))
        }, tilemap: function (b) {
            return new d.Tilemap(this.game, b)
        }, tileset: function (b) {
            return this.game.cache.getTileset(b)
        }, tilemapLayer: function (h, m, j, b, l, k, i) {
            return this.world.add(new d.TilemapLayer(this.game, h, m, j, b, l, k, i))
        }, renderTexture: function (h, i, b) {
            var j = new d.RenderTexture(this.game, h, i, b);
            this.game.cache.addRenderTexture(h, j);
            return j
        }
    };
    d.Sprite = function (h, b, k, i, j) {
        b = b || 0;
        k = k || 0;
        i = i || null;
        j = j || null;
        this.game = h;
        this.exists = true;
        this.alive = true;
        this.group = null;
        this.name = "";
        this.type = d.SPRITE;
        this.renderOrderID = -1;
        this.lifespan = 0;
        this.events = new d.Events(this);
        this.animations = new d.AnimationManager(this);
        this.input = new d.InputHandler(this);
        this.key = i;
        this.currentFrame = null;
        if (i instanceof d.RenderTexture) {
            g.Sprite.call(this, i);
            this.currentFrame = this.game.cache.getTextureFrame(i.name)
        } else {
            if (i instanceof g.Texture) {
                g.Sprite.call(this, i);
                this.currentFrame = j
            } else {
                if (i == null || this.game.cache.checkImageKey(i) == false) {
                    i = "__default";
                    this.key = i
                }
                g.Sprite.call(this, g.TextureCache[i]);
                if (this.game.cache.isSpriteSheet(i)) {
                    this.animations.loadFrameData(this.game.cache.getFrameData(i));
                    if (j !== null) {
                        if (typeof j === "string") {
                            this.frameName = j
                        } else {
                            this.frame = j
                        }
                    }
                } else {
                    this.currentFrame = this.game.cache.getFrame(i)
                }
            }
        }
        this.textureRegion = new d.Rectangle(this.texture.frame.x, this.texture.frame.y, this.texture.frame.width, this.texture.frame.height);
        this.anchor = new d.Point();
        this.x = b;
        this.y = k;
        this.position.x = b;
        this.position.y = k;
        this.world = new d.Point(b, k);
        this.autoCull = false;
        this.scale = new d.Point(1, 1);
        this._cache = {
            dirty: false,
            a00: -1,
            a01: -1,
            a02: -1,
            a10: -1,
            a11: -1,
            a12: -1,
            id: -1,
            i01: -1,
            i10: -1,
            idi: -1,
            left: null,
            right: null,
            top: null,
            bottom: null,
            prevX: b,
            prevY: k,
            x: -1,
            y: -1,
            scaleX: 1,
            scaleY: 1,
            width: this.currentFrame.sourceSizeW,
            height: this.currentFrame.sourceSizeH,
            halfWidth: Math.floor(this.currentFrame.sourceSizeW / 2),
            halfHeight: Math.floor(this.currentFrame.sourceSizeH / 2),
            calcWidth: -1,
            calcHeight: -1,
            frameID: -1,
            frameWidth: this.currentFrame.width,
            frameHeight: this.currentFrame.height,
            cameraVisible: true,
            cropX: 0,
            cropY: 0,
            cropWidth: this.currentFrame.sourceSizeW,
            cropHeight: this.currentFrame.sourceSizeH
        };
        this.offset = new d.Point;
        this.center = new d.Point(b + Math.floor(this._cache.width / 2), k + Math.floor(this._cache.height / 2));
        this.topLeft = new d.Point(b, k);
        this.topRight = new d.Point(b + this._cache.width, k);
        this.bottomRight = new d.Point(b + this._cache.width, k + this._cache.height);
        this.bottomLeft = new d.Point(b, k + this._cache.height);
        this.bounds = new d.Rectangle(b, k, this._cache.width, this._cache.height);
        this.body = new d.Physics.Arcade.Body(this);
        this.health = 1;
        this.inWorld = d.Rectangle.intersects(this.bounds, this.game.world.bounds);
        this.inWorldThreshold = 0;
        this.outOfBoundsKill = false;
        this._outOfBoundsFired = false;
        this.fixedToCamera = false;
        this.cameraOffset = new d.Point;
        this.crop = new d.Rectangle(0, 0, this._cache.width, this._cache.height);
        this.cropEnabled = false;
        this.updateCache();
        this.updateBounds()
    };
    d.Sprite.prototype = Object.create(g.Sprite.prototype);
    d.Sprite.prototype.constructor = d.Sprite;
    d.Sprite.prototype.preUpdate = function () {
        if (!this.exists) {
            this.renderOrderID = -1;
            return
        }
        if (this.lifespan > 0) {
            this.lifespan -= this.game.time.elapsed;
            if (this.lifespan <= 0) {
                this.kill();
                return
            }
        }
        this._cache.dirty = false;
        if (this.visible) {
            this.renderOrderID = this.game.world.currentRenderOrderID++
        }
        this.updateCache();
        this.updateAnimation();
        this.updateCrop();
        if (this._cache.dirty || this.world.x !== this._cache.prevX || this.world.y !== this._cache.prevY) {
            this.updateBounds()
        }
        if (this.body) {
            this.body.preUpdate()
        }
    };
    d.Sprite.prototype.updateCache = function () {
        this._cache.prevX = this.world.x;
        this._cache.prevY = this.world.y;
        if (this.fixedToCamera) {
            this.x = this.game.camera.view.x + this.cameraOffset.x;
            this.y = this.game.camera.view.y + this.cameraOffset.y
        }
        this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
        if (this.worldTransform[1] != this._cache.i01 || this.worldTransform[3] != this._cache.i10 || this.worldTransform[0] != this._cache.a00 || this.worldTransform[41] != this._cache.a11) {
            this._cache.a00 = this.worldTransform[0];
            this._cache.a01 = this.worldTransform[1];
            this._cache.a10 = this.worldTransform[3];
            this._cache.a11 = this.worldTransform[4];
            this._cache.i01 = this.worldTransform[1];
            this._cache.i10 = this.worldTransform[3];
            this._cache.scaleX = Math.sqrt((this._cache.a00 * this._cache.a00) + (this._cache.a01 * this._cache.a01));
            this._cache.scaleY = Math.sqrt((this._cache.a10 * this._cache.a10) + (this._cache.a11 * this._cache.a11));
            this._cache.a01 *= -1;
            this._cache.a10 *= -1;
            this._cache.id = 1 / (this._cache.a00 * this._cache.a11 + this._cache.a01 * -this._cache.a10);
            this._cache.idi = 1 / (this._cache.a00 * this._cache.a11 + this._cache.i01 * -this._cache.i10);
            this._cache.dirty = true
        }
        this._cache.a02 = this.worldTransform[2];
        this._cache.a12 = this.worldTransform[5]
    };
    d.Sprite.prototype.updateAnimation = function () {
        if (this.animations.update() || (this.currentFrame && this.currentFrame.uuid != this._cache.frameID)) {
            this._cache.frameID = this.currentFrame.uuid;
            this._cache.frameWidth = this.texture.frame.width;
            this._cache.frameHeight = this.texture.frame.height;
            this._cache.width = this.currentFrame.width;
            this._cache.height = this.currentFrame.height;
            this._cache.halfWidth = Math.floor(this._cache.width / 2);
            this._cache.halfHeight = Math.floor(this._cache.height / 2);
            this._cache.dirty = true
        }
    };
    d.Sprite.prototype.updateCrop = function () {
        if (this.cropEnabled && (this.crop.width != this._cache.cropWidth || this.crop.height != this._cache.cropHeight || this.crop.x != this._cache.cropX || this.crop.y != this._cache.cropY)) {
            this.crop.floorAll();
            this._cache.cropX = this.crop.x;
            this._cache.cropY = this.crop.y;
            this._cache.cropWidth = this.crop.width;
            this._cache.cropHeight = this.crop.height;
            this.texture.frame = this.crop;
            this.texture.width = this.crop.width;
            this.texture.height = this.crop.height;
            this.texture.updateFrame = true;
            g.Texture.frameUpdates.push(this.texture)
        }
    };
    d.Sprite.prototype.updateBounds = function () {
        this.offset.setTo(this._cache.a02 - (this.anchor.x * this.width), this._cache.a12 - (this.anchor.y * this.height));
        this.getLocalPosition(this.center, this.offset.x + (this.width / 2), this.offset.y + (this.height / 2));
        this.getLocalPosition(this.topLeft, this.offset.x, this.offset.y);
        this.getLocalPosition(this.topRight, this.offset.x + this.width, this.offset.y);
        this.getLocalPosition(this.bottomLeft, this.offset.x, this.offset.y + this.height);
        this.getLocalPosition(this.bottomRight, this.offset.x + this.width, this.offset.y + this.height);
        this._cache.left = d.Math.min(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
        this._cache.right = d.Math.max(this.topLeft.x, this.topRight.x, this.bottomLeft.x, this.bottomRight.x);
        this._cache.top = d.Math.min(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
        this._cache.bottom = d.Math.max(this.topLeft.y, this.topRight.y, this.bottomLeft.y, this.bottomRight.y);
        this.bounds.setTo(this._cache.left, this._cache.top, this._cache.right - this._cache.left, this._cache.bottom - this._cache.top);
        this.updateFrame = true;
        if (this.inWorld == false) {
            this.inWorld = d.Rectangle.intersects(this.bounds, this.game.world.bounds, this.inWorldThreshold);
            if (this.inWorld) {
                this._outOfBoundsFired = false
            }
        } else {
            this.inWorld = d.Rectangle.intersects(this.bounds, this.game.world.bounds, this.inWorldThreshold);
            if (this.inWorld == false) {
                this.events.onOutOfBounds.dispatch(this);
                this._outOfBoundsFired = true;
                if (this.outOfBoundsKill) {
                    this.kill()
                }
            }
        }
        this._cache.cameraVisible = d.Rectangle.intersects(this.game.world.camera.screenView, this.bounds, 0);
        if (this.autoCull) {
            this.renderable = this._cache.cameraVisible
        }
        if (this.body) {
            this.body.updateBounds(this.center.x, this.center.y, this._cache.scaleX, this._cache.scaleY)
        }
    };
    d.Sprite.prototype.getLocalPosition = function (h, b, i) {
        h.x = ((this._cache.a11 * this._cache.id * b + -this._cache.a01 * this._cache.id * i + (this._cache.a12 * this._cache.a01 - this._cache.a02 * this._cache.a11) * this._cache.id) * this.scale.x) + this._cache.a02;
        h.y = ((this._cache.a00 * this._cache.id * i + -this._cache.a10 * this._cache.id * b + (-this._cache.a12 * this._cache.a00 + this._cache.a02 * this._cache.a10) * this._cache.id) * this.scale.y) + this._cache.a12;
        return h
    };
    d.Sprite.prototype.getLocalUnmodifiedPosition = function (i, h, b) {
        i.x = (this._cache.a11 * this._cache.idi * h + -this._cache.i01 * this._cache.idi * b + (this._cache.a12 * this._cache.i01 - this._cache.a02 * this._cache.a11) * this._cache.idi) + (this.anchor.x * this._cache.width);
        i.y = (this._cache.a00 * this._cache.idi * b + -this._cache.i10 * this._cache.idi * h + (-this._cache.a12 * this._cache.a00 + this._cache.a02 * this._cache.i10) * this._cache.idi) + (this.anchor.y * this._cache.height);
        return i
    };
    d.Sprite.prototype.resetCrop = function () {
        this.crop = new d.Rectangle(0, 0, this._cache.width, this._cache.height);
        this.texture.setFrame(this.crop);
        this.cropEnabled = false
    };
    d.Sprite.prototype.postUpdate = function () {
        if (this.exists) {
            if (this.body) {
                this.body.postUpdate()
            }
            if (this.fixedToCamera) {
                this._cache.x = this.game.camera.view.x + this.cameraOffset.x;
                this._cache.y = this.game.camera.view.y + this.cameraOffset.y
            } else {
                this._cache.x = this.x;
                this._cache.y = this.y
            }
            this.world.setTo(this.game.camera.x + this.worldTransform[2], this.game.camera.y + this.worldTransform[5]);
            this.position.x = this._cache.x;
            this.position.y = this._cache.y
        }
    };
    d.Sprite.prototype.loadTexture = function (b, h) {
        this.key = b;
        if (b instanceof d.RenderTexture) {
            this.currentFrame = this.game.cache.getTextureFrame(b.name)
        } else {
            if (b instanceof g.Texture) {
                this.currentFrame = h
            } else {
                if (typeof b === "undefined" || this.game.cache.checkImageKey(b) === false) {
                    b = "__default";
                    this.key = b
                }
                if (this.game.cache.isSpriteSheet(b)) {
                    this.animations.loadFrameData(this.game.cache.getFrameData(b));
                    if (typeof h !== "undefined") {
                        if (typeof h === "string") {
                            this.frameName = h
                        } else {
                            this.frame = h
                        }
                    }
                } else {
                    this.currentFrame = this.game.cache.getFrame(b);
                    this.setTexture(g.TextureCache[b])
                }
            }
        }
    };
    d.Sprite.prototype.centerOn = function (b, h) {
        this.x = b + (this.x - this.center.x);
        this.y = h + (this.y - this.center.y);
        return this
    };
    d.Sprite.prototype.revive = function (b) {
        if (typeof b === "undefined") {
            b = 1
        }
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.health = b;
        if (this.events) {
            this.events.onRevived.dispatch(this)
        }
        return this
    };
    d.Sprite.prototype.kill = function () {
        this.alive = false;
        this.exists = false;
        this.visible = false;
        if (this.events) {
            this.events.onKilled.dispatch(this)
        }
        return this
    };
    d.Sprite.prototype.destroy = function () {
        if (this.group) {
            this.group.remove(this)
        }
        if (this.input) {
            this.input.destroy()
        }
        if (this.events) {
            this.events.destroy()
        }
        if (this.animations) {
            this.animations.destroy()
        }
        this.alive = false;
        this.exists = false;
        this.visible = false;
        this.game = null
    };
    d.Sprite.prototype.damage = function (b) {
        if (this.alive) {
            this.health -= b;
            if (this.health < 0) {
                this.kill()
            }
        }
        return this
    };
    d.Sprite.prototype.reset = function (b, i, h) {
        if (typeof h === "undefined") {
            h = 1
        }
        this.x = b;
        this.y = i;
        this.position.x = this.x;
        this.position.y = this.y;
        this.alive = true;
        this.exists = true;
        this.visible = true;
        this.renderable = true;
        this._outOfBoundsFired = false;
        this.health = h;
        if (this.body) {
            this.body.reset()
        }
        return this
    };
    d.Sprite.prototype.bringToTop = function () {
        if (this.group) {
            this.group.bringToTop(this)
        } else {
            this.game.world.bringToTop(this)
        }
        return this
    };
    d.Sprite.prototype.play = function (j, i, h, b) {
        if (this.animations) {
            return this.animations.play(j, i, h, b)
        }
    };
    Object.defineProperty(d.Sprite.prototype, "angle", {
        get: function () {
            return d.Math.wrapAngle(d.Math.radToDeg(this.rotation))
        }, set: function (b) {
            this.rotation = d.Math.degToRad(d.Math.wrapAngle(b))
        }
    });
    Object.defineProperty(d.Sprite.prototype, "frame", {
        get: function () {
            return this.animations.frame
        }, set: function (b) {
            this.animations.frame = b
        }
    });
    Object.defineProperty(d.Sprite.prototype, "frameName", {
        get: function () {
            return this.animations.frameName
        }, set: function (b) {
            this.animations.frameName = b
        }
    });
    Object.defineProperty(d.Sprite.prototype, "inCamera", {
        get: function () {
            return this._cache.cameraVisible
        }
    });
    Object.defineProperty(d.Sprite.prototype, "width", {
        get: function () {
            return this.scale.x * this.currentFrame.width
        }, set: function (b) {
            this.scale.x = b / this.currentFrame.width;
            this._cache.scaleX = b / this.currentFrame.width;
            this._width = b
        }
    });
    Object.defineProperty(d.Sprite.prototype, "height", {
        get: function () {
            return this.scale.y * this.currentFrame.height
        }, set: function (b) {
            this.scale.y = b / this.currentFrame.height;
            this._cache.scaleY = b / this.currentFrame.height;
            this._height = b
        }
    });
    Object.defineProperty(d.Sprite.prototype, "inputEnabled", {
        get: function () {
            return (this.input.enabled)
        }, set: function (b) {
            if (b) {
                if (this.input.enabled == false) {
                    this.input.start()
                }
            } else {
                if (this.input.enabled) {
                    this.input.stop()
                }
            }
        }
    });
    d.TileSprite = function (i, h, m, k, b, j, l) {
        h = h || 0;
        m = m || 0;
        k = k || 256;
        b = b || 256;
        j = j || null;
        l = l || null;
        d.Sprite.call(this, i, h, m, j, l);
        this.texture = g.TextureCache[j];
        g.TilingSprite.call(this, this.texture, k, b);
        this.type = d.TILESPRITE;
        this.tileScale = new d.Point(1, 1);
        this.tilePosition = new d.Point(0, 0)
    };
    d.TileSprite.prototype = d.Utils.extend(true, g.TilingSprite.prototype, d.Sprite.prototype);
    d.TileSprite.prototype.constructor = d.TileSprite;
    d.Text = function (h, b, k, j, i) {
        b = b || 0;
        k = k || 0;
        j = j || "";
        i = i || "";
        this.exists = true;
        this.alive = true;
        this.group = null;
        this.name = "";
        this.game = h;
        this._text = j;
        this._style = i;
        g.Text.call(this, j, i);
        this.type = d.TEXT;
        this.position.x = this.x = b;
        this.position.y = this.y = k;
        this.anchor = new d.Point();
        this.scale = new d.Point(1, 1);
        this._cache = {
            dirty: false,
            a00: 1,
            a01: 0,
            a02: b,
            a10: 0,
            a11: 1,
            a12: k,
            id: 1,
            x: -1,
            y: -1,
            scaleX: 1,
            scaleY: 1
        };
        this._cache.x = this.x;
        this._cache.y = this.y;
        this.renderable = true
    };
    d.Text.prototype = Object.create(g.Text.prototype);
    d.Text.prototype.constructor = d.Text;
    d.Text.prototype.update = function () {
        if (!this.exists) {
            return
        }
        this._cache.dirty = false;
        this._cache.x = this.x;
        this._cache.y = this.y;
        if (this.position.x != this._cache.x || this.position.y != this._cache.y) {
            this.position.x = this._cache.x;
            this.position.y = this._cache.y;
            this._cache.dirty = true
        }
    };
    d.Text.prototype.destroy = function () {
        if (this.group) {
            this.group.remove(this)
        }
        if (this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas)
        } else {
            this.canvas = null;
            this.context = null
        }
        this.exists = false;
        this.group = null
    };
    Object.defineProperty(d.Text.prototype, "angle", {
        get: function () {
            return d.Math.radToDeg(this.rotation)
        }, set: function (b) {
            this.rotation = d.Math.degToRad(b)
        }
    });
    Object.defineProperty(d.Text.prototype, "content", {
        get: function () {
            return this._text
        }, set: function (b) {
            if (b !== this._text) {
                this._text = b;
                this.setText(b)
            }
        }
    });
    Object.defineProperty(d.Text.prototype, "font", {
        get: function () {
            return this._style
        }, set: function (b) {
            if (b !== this._style) {
                this._style = b;
                this.setStyle(b)
            }
        }
    });
    d.BitmapText = function (h, b, k, j, i) {
        b = b || 0;
        k = k || 0;
        j = j || "";
        i = i || "";
        this.exists = true;
        this.alive = true;
        this.group = null;
        this.name = "";
        this.game = h;
        g.BitmapText.call(this, j, i);
        this.type = d.BITMAPTEXT;
        this.position.x = b;
        this.position.y = k;
        this.anchor = new d.Point();
        this.scale = new d.Point(1, 1);
        this._cache = {
            dirty: false,
            a00: 1,
            a01: 0,
            a02: b,
            a10: 0,
            a11: 1,
            a12: k,
            id: 1,
            x: -1,
            y: -1,
            scaleX: 1,
            scaleY: 1
        };
        this._cache.x = this.x;
        this._cache.y = this.y;
        this.renderable = true
    };
    d.BitmapText.prototype = Object.create(g.BitmapText.prototype);
    d.BitmapText.prototype.constructor = d.BitmapText;
    d.BitmapText.prototype.update = function () {
        if (!this.exists) {
            return
        }
        this._cache.dirty = false;
        this._cache.x = this.x;
        this._cache.y = this.y;
        if (this.position.x != this._cache.x || this.position.y != this._cache.y) {
            this.position.x = this._cache.x;
            this.position.y = this._cache.y;
            this._cache.dirty = true
        }
        this.pivot.x = this.anchor.x * this.width;
        this.pivot.y = this.anchor.y * this.height
    };
    d.BitmapText.prototype.destroy = function () {
        if (this.group) {
            this.group.remove(this)
        }
        if (this.canvas.parentNode) {
            this.canvas.parentNode.removeChild(this.canvas)
        } else {
            this.canvas = null;
            this.context = null
        }
        this.exists = false;
        this.group = null
    };
    Object.defineProperty(d.BitmapText.prototype, "angle", {
        get: function () {
            return d.Math.radToDeg(this.rotation)
        }, set: function (b) {
            this.rotation = d.Math.degToRad(b)
        }
    });
    Object.defineProperty(d.BitmapText.prototype, "x", {
        get: function () {
            return this.position.x
        }, set: function (b) {
            this.position.x = b
        }
    });
    Object.defineProperty(d.BitmapText.prototype, "y", {
        get: function () {
            return this.position.y
        }, set: function (b) {
            this.position.y = b
        }
    });
    d.Button = function (o, l, k, m, n, h, i, b, j) {
        l = l || 0;
        k = k || 0;
        m = m || null;
        n = n || null;
        h = h || this;
        d.Sprite.call(this, o, l, k, m, b);
        this.type = d.BUTTON;
        this._onOverFrameName = null;
        this._onOutFrameName = null;
        this._onDownFrameName = null;
        this._onUpFrameName = null;
        this._onOverFrameID = null;
        this._onOutFrameID = null;
        this._onDownFrameID = null;
        this._onUpFrameID = null;
        this.onOverSound = null;
        this.onOutSound = null;
        this.onDownSound = null;
        this.onUpSound = null;
        this.onOverSoundMarker = "";
        this.onOutSoundMarker = "";
        this.onDownSoundMarker = "";
        this.onUpSoundMarker = "";
        this.onInputOver = new d.Signal;
        this.onInputOut = new d.Signal;
        this.onInputDown = new d.Signal;
        this.onInputUp = new d.Signal;
        this.freezeFrames = false;
        this.setFrames(i, b, j);
        if (n !== null) {
            this.onInputUp.add(n, h)
        }
        this.input.start(0, true);
        this.events.onInputOver.add(this.onInputOverHandler, this);
        this.events.onInputOut.add(this.onInputOutHandler, this);
        this.events.onInputDown.add(this.onInputDownHandler, this);
        this.events.onInputUp.add(this.onInputUpHandler, this)
    };
    d.Button.prototype = Object.create(d.Sprite.prototype);
    d.Button.prototype = d.Utils.extend(true, d.Button.prototype, d.Sprite.prototype, g.Sprite.prototype);
    d.Button.prototype.constructor = d.Button;
    d.Button.prototype.setFrames = function (h, i, b) {
        if (h !== null) {
            if (typeof h === "string") {
                this._onOverFrameName = h;
                if (this.input.pointerOver()) {
                    this.frameName = h
                }
            } else {
                this._onOverFrameID = h;
                if (this.input.pointerOver()) {
                    this.frame = h
                }
            }
        }
        if (i !== null) {
            if (typeof i === "string") {
                this._onOutFrameName = i;
                this._onUpFrameName = i;
                if (this.input.pointerOver() == false) {
                    this.frameName = i
                }
            } else {
                this._onOutFrameID = i;
                this._onUpFrameID = i;
                if (this.input.pointerOver() == false) {
                    this.frame = i
                }
            }
        }
        if (b !== null) {
            if (typeof b === "string") {
                this._onDownFrameName = b;
                if (this.input.pointerOver()) {
                    this.frameName = b
                }
            } else {
                this._onDownFrameID = b;
                if (this.input.pointerOver()) {
                    this.frame = b
                }
            }
        }
    };
    d.Button.prototype.setSounds = function (h, l, b, k, j, n, i, m) {
        this.setOverSound(h, l);
        this.setOutSound(j, n);
        this.setUpSound(i, m);
        this.setDownSound(b, k)
    };
    d.Button.prototype.setOverSound = function (h, b) {
        this.onOverSound = null;
        this.onOverSoundMarker = "";
        if (h instanceof d.Sound) {
            this.onOverSound = h
        }
        if (typeof b === "string") {
            this.onOverSoundMarker = b
        }
    };
    d.Button.prototype.setOutSound = function (h, b) {
        this.onOutSound = null;
        this.onOutSoundMarker = "";
        if (h instanceof d.Sound) {
            this.onOutSound = h
        }
        if (typeof b === "string") {
            this.onOutSoundMarker = b
        }
    };
    d.Button.prototype.setUpSound = function (h, b) {
        this.onUpSound = null;
        this.onUpSoundMarker = "";
        if (h instanceof d.Sound) {
            this.onUpSound = h
        }
        if (typeof b === "string") {
            this.onUpSoundMarker = b
        }
    };
    d.Button.prototype.setDownSound = function (h, b) {
        this.onDownSound = null;
        this.onDownSoundMarker = "";
        if (h instanceof d.Sound) {
            this.onDownSound = h
        }
        if (typeof b === "string") {
            this.onDownSoundMarker = b
        }
    };
    d.Button.prototype.onInputOverHandler = function (b) {
        if (this.freezeFrames == false) {
            if (this._onOverFrameName != null) {
                this.frameName = this._onOverFrameName
            } else {
                if (this._onOverFrameID != null) {
                    this.frame = this._onOverFrameID
                }
            }
        }
        if (this.onOverSound) {
            this.onOverSound.play(this.onOverSoundMarker)
        }
        if (this.onInputOver) {
            this.onInputOver.dispatch(this, b)
        }
    };
    d.Button.prototype.onInputOutHandler = function (b) {
        if (this.freezeFrames == false) {
            if (this._onOutFrameName != null) {
                this.frameName = this._onOutFrameName
            } else {
                if (this._onOutFrameID != null) {
                    this.frame = this._onOutFrameID
                }
            }
        }
        if (this.onOutSound) {
            this.onOutSound.play(this.onOutSoundMarker)
        }
        if (this.onInputOut) {
            this.onInputOut.dispatch(this, b)
        }
    };
    d.Button.prototype.onInputDownHandler = function (b) {
        if (this.freezeFrames == false) {
            if (this._onDownFrameName != null) {
                this.frameName = this._onDownFrameName
            } else {
                if (this._onDownFrameID != null) {
                    this.frame = this._onDownFrameID
                }
            }
        }
        if (this.onDownSound) {
            this.onDownSound.play(this.onDownSoundMarker)
        }
        if (this.onInputDown) {
            this.onInputDown.dispatch(this, b)
        }
    };
    d.Button.prototype.onInputUpHandler = function (b) {
        if (this.freezeFrames == false) {
            if (this._onUpFrameName != null) {
                this.frameName = this._onUpFrameName
            } else {
                if (this._onUpFrameID != null) {
                    this.frame = this._onUpFrameID
                }
            }
        }
        if (this.onUpSound) {
            this.onUpSound.play(this.onUpSoundMarker)
        }
        if (this.onInputUp) {
            this.onInputUp.dispatch(this, b)
        }
    };
    d.Graphics = function (h, b, i) {
        this.game = h;
        g.Graphics.call(this);
        this.type = d.GRAPHICS
    };
    d.Graphics.prototype = Object.create(g.Graphics.prototype);
    d.Graphics.prototype.constructor = d.Graphics;
    d.Graphics.prototype.destroy = function () {
        this.clear();
        if (this.group) {
            this.group.remove(this)
        }
        this.game = null
    };
    Object.defineProperty(d.Graphics.prototype, "angle", {
        get: function () {
            return d.Math.wrapAngle(d.Math.radToDeg(this.rotation))
        }, set: function (b) {
            this.rotation = d.Math.degToRad(d.Math.wrapAngle(b))
        }
    });
    Object.defineProperty(d.Graphics.prototype, "x", {
        get: function () {
            return this.position.x
        }, set: function (b) {
            this.position.x = b
        }
    });
    Object.defineProperty(d.Graphics.prototype, "y", {
        get: function () {
            return this.position.y
        }, set: function (b) {
            this.position.y = b
        }
    });
    d.RenderTexture = function (h, i, j, b) {
        this.game = h;
        this.name = i;
        g.EventTarget.call(this);
        this.width = j || 100;
        this.height = b || 100;
        this.indetityMatrix = g.mat3.create();
        this.frame = new g.Rectangle(0, 0, this.width, this.height);
        this.type = d.RENDERTEXTURE;
        if (g.gl) {
            this.initWebGL()
        } else {
            this.initCanvas()
        }
    };
    d.RenderTexture.prototype = d.Utils.extend(true, g.RenderTexture.prototype);
    d.RenderTexture.prototype.constructor = d.RenderTexture;
    d.Canvas = {
        create: function (i, b) {
            i = i || 256;
            b = b || 256;
            var h = document.createElement("canvas");
            h.width = i;
            h.height = b;
            h.style.display = "block";
            return h
        }, getOffset: function (h, b) {
            b = b || new d.Point;
            var i = h.getBoundingClientRect();
            var m = h.clientTop || document.body.clientTop || 0;
            var l = h.clientLeft || document.body.clientLeft || 0;
            var j = window.pageYOffset || h.scrollTop || document.body.scrollTop;
            var k = window.pageXOffset || h.scrollLeft || document.body.scrollLeft;
            b.x = i.left + k - l;
            b.y = i.top + j - m;
            return b
        }, getAspectRatio: function (b) {
            return b.width / b.height
        }, setBackgroundColor: function (h, b) {
            b = b || "rgb(0,0,0)";
            h.style.backgroundColor = b;
            return h
        }, setTouchAction: function (b, h) {
            h = h || "none";
            b.style.msTouchAction = h;
            b.style["ms-touch-action"] = h;
            b.style["touch-action"] = h;
            return b
        }, setUserSelect: function (b, h) {
            h = h || "none";
            b.style["-webkit-touch-callout"] = h;
            b.style["-webkit-user-select"] = h;
            b.style["-khtml-user-select"] = h;
            b.style["-moz-user-select"] = h;
            b.style["-ms-user-select"] = h;
            b.style["user-select"] = h;
            b.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
            return b
        }, addToDOM: function (b, h, i) {
            h = h || "";
            if (typeof i === "undefined") {
                i = true
            }
            if (h !== "") {
                if (document.getElementById(h)) {
                    document.getElementById(h).appendChild(b);
                    if (i) {
                        document.getElementById(h).style.overflow = "hidden"
                    }
                } else {
                    document.body.appendChild(b)
                }
            } else {
                document.body.appendChild(b)
            }
            return b
        }, setTransform: function (k, m, l, i, b, j, h) {
            k.setTransform(i, j, h, b, m, l);
            return k
        }, setSmoothingEnabled: function (b, h) {
            b.imageSmoothingEnabled = h;
            b.mozImageSmoothingEnabled = h;
            b.oImageSmoothingEnabled = h;
            b.webkitImageSmoothingEnabled = h;
            b.msImageSmoothingEnabled = h;
            return b
        }, setImageRenderingCrisp: function (b) {
            b.style["image-rendering"] = "crisp-edges";
            b.style["image-rendering"] = "-moz-crisp-edges";
            b.style["image-rendering"] = "-webkit-optimize-contrast";
            b.style.msInterpolationMode = "nearest-neighbor";
            return b
        }, setImageRenderingBicubic: function (b) {
            b.style["image-rendering"] = "auto";
            b.style.msInterpolationMode = "bicubic";
            return b
        }
    };
    d.StageScaleMode = function (h, i, b) {
        this._startHeight = 0;
        this.forceLandscape = false;
        this.forcePortrait = false;
        this.incorrectOrientation = false;
        this.pageAlignHorizontally = false;
        this.pageAlignVertically = false;
        this.minWidth = null;
        this.maxWidth = null;
        this.minHeight = null;
        this.maxHeight = null;
        this.width = i;
        this.height = b;
        this._width = 0;
        this._height = 0;
        this.maxIterations = 5;
        this.game = h;
        this.enterLandscape = new d.Signal();
        this.enterPortrait = new d.Signal();
        if (window.orientation) {
            this.orientation = window.orientation
        } else {
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90
            } else {
                this.orientation = 0
            }
        }
        this.scaleFactor = new d.Point(1, 1);
        this.aspectRatio = 0;
        var j = this;
        window.addEventListener("orientationchange", function (k) {
            return j.checkOrientation(k)
        }, false);
        window.addEventListener("resize", function (k) {
            return j.checkResize(k)
        }, false);
        document.addEventListener("webkitfullscreenchange", function (k) {
            return j.fullScreenChange(k)
        }, false);
        document.addEventListener("mozfullscreenchange", function (k) {
            return j.fullScreenChange(k)
        }, false);
        document.addEventListener("fullscreenchange", function (k) {
            return j.fullScreenChange(k)
        }, false)
    };
    d.StageScaleMode.EXACT_FIT = 0;
    d.StageScaleMode.NO_SCALE = 1;
    d.StageScaleMode.SHOW_ALL = 2;
    d.StageScaleMode.prototype = {
        startFullScreen: function (b) {
            if (this.isFullScreen) {
                return
            }
            if (typeof b !== "undefined") {
                d.Canvas.setSmoothingEnabled(this.game.context, b)
            }
            var h = this.game.canvas;
            this._width = this.width;
            this._height = this.height;
            console.log("startFullScreen", this._width, this._height);
            if (h.requestFullScreen) {
                h.requestFullScreen()
            } else {
                if (h.mozRequestFullScreen) {
                    h.mozRequestFullScreen()
                } else {
                    if (h.webkitRequestFullScreen) {
                        h.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT)
                    }
                }
            }
        }, stopFullScreen: function () {
            if (document.cancelFullScreen) {
                document.cancelFullScreen()
            } else {
                if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen()
                } else {
                    if (document.webkitCancelFullScreen) {
                        document.webkitCancelFullScreen()
                    }
                }
            }
        }, fullScreenChange: function (b) {
            if (this.isFullScreen) {
                this.game.stage.canvas.style.width = "100%";
                this.game.stage.canvas.style.height = "100%";
                this.setMaximum();
                this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                this.aspectRatio = this.width / this.height;
                this.scaleFactor.x = this.game.width / this.width;
                this.scaleFactor.y = this.game.height / this.height
            } else {
                this.game.stage.canvas.style.width = this.game.width + "px";
                this.game.stage.canvas.style.height = this.game.height + "px";
                this.width = this._width;
                this.height = this._height;
                this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
                this.aspectRatio = this.width / this.height;
                this.scaleFactor.x = this.game.width / this.width;
                this.scaleFactor.y = this.game.height / this.height
            }
        }, checkOrientationState: function () {
            if (this.incorrectOrientation) {
                if ((this.forceLandscape && window.innerWidth > window.innerHeight) || (this.forcePortrait && window.innerHeight > window.innerWidth)) {
                    this.game.paused = false;
                    this.incorrectOrientation = false;
                    this.refresh()
                }
            } else {
                if ((this.forceLandscape && window.innerWidth < window.innerHeight) || (this.forcePortrait && window.innerHeight < window.innerWidth)) {
                    this.game.paused = true;
                    this.incorrectOrientation = true;
                    this.refresh()
                }
            }
        }, checkOrientation: function (b) {
            this.orientation = window.orientation;
            if (this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false)
            } else {
                this.enterPortrait.dispatch(this.orientation, false, true)
            }
            if (this.game.stage.scaleMode !== d.StageScaleMode.NO_SCALE) {
                this.refresh()
            }
        }, checkResize: function (b) {
            if (window.outerWidth > window.outerHeight) {
                this.orientation = 90
            } else {
                this.orientation = 0
            }
            if (this.isLandscape) {
                this.enterLandscape.dispatch(this.orientation, true, false)
            } else {
                this.enterPortrait.dispatch(this.orientation, false, true)
            }
            if (this.game.stage.scaleMode !== d.StageScaleMode.NO_SCALE) {
                this.refresh()
            }
        }, refresh: function () {
            var b = this;
            if (this.game.device.iPad == false && this.game.device.webApp == false && this.game.device.desktop == false) {
                if (this.game.device.android && this.game.device.chrome == false) {
                    window.scrollTo(0, 1)
                } else {
                    window.scrollTo(0, 0)
                }
            }
            if (this._check == null && this.maxIterations > 0) {
                this._iterations = this.maxIterations;
                this._check = window.setInterval(function () {
                    return b.setScreenSize()
                }, 10);
                this.setScreenSize()
            }
        }, setScreenSize: function (b) {
            if (typeof b == "undefined") {
                b = false
            }
            if (this.game.device.iPad == false && this.game.device.webApp == false && this.game.device.desktop == false) {
                if (this.game.device.android && this.game.device.chrome == false) {
                    window.scrollTo(0, 1)
                } else {
                    window.scrollTo(0, 0)
                }
            }
            this._iterations--;
            if (b || window.innerHeight > this._startHeight || this._iterations < 0) {
                document.documentElement.style.minHeight = window.innerHeight + "px";
                if (this.incorrectOrientation == true) {
                    this.setMaximum()
                } else {
                    if (this.game.stage.scaleMode == d.StageScaleMode.EXACT_FIT) {
                        this.setExactFit()
                    } else {
                        if (this.game.stage.scaleMode == d.StageScaleMode.SHOW_ALL) {
                            this.setShowAll()
                        }
                    }
                }
                this.setSize();
                clearInterval(this._check);
                this._check = null
            }
        }, setSize: function () {
            if (this.incorrectOrientation == false) {
                if (this.maxWidth && this.width > this.maxWidth) {
                    this.width = this.maxWidth
                }
                if (this.maxHeight && this.height > this.maxHeight) {
                    this.height = this.maxHeight
                }
                if (this.minWidth && this.width < this.minWidth) {
                    this.width = this.minWidth
                }
                if (this.minHeight && this.height < this.minHeight) {
                    this.height = this.minHeight
                }
            }
            this.game.canvas.style.width = this.width + "px";
            this.game.canvas.style.height = this.height + "px";
            this.game.input.scale.setTo(this.game.width / this.width, this.game.height / this.height);
            if (this.pageAlignHorizontally) {
                if (this.width < window.innerWidth && this.incorrectOrientation == false) {
                    this.game.canvas.style.marginLeft = Math.round((window.innerWidth - this.width) / 2) + "px"
                } else {
                    this.game.canvas.style.marginLeft = "0px"
                }
            }
            if (this.pageAlignVertically) {
                if (this.height < window.innerHeight && this.incorrectOrientation == false) {
                    this.game.canvas.style.marginTop = Math.round((window.innerHeight - this.height) / 2) + "px"
                } else {
                    this.game.canvas.style.marginTop = "0px"
                }
            }
            d.Canvas.getOffset(this.game.canvas, this.game.stage.offset);
            this.aspectRatio = this.width / this.height;
            this.scaleFactor.x = this.game.width / this.width;
            this.scaleFactor.y = this.game.height / this.height
        }, setMaximum: function () {
            this.width = window.innerWidth;
            this.height = window.innerHeight
        }, setShowAll: function () {
            var b = Math.min((window.innerHeight / this.game.height), (window.innerWidth / this.game.width));
            this.width = Math.round(this.game.width * b);
            this.height = Math.round(this.game.height * b)
        }, setExactFit: function () {
            var b = window.innerWidth;
            var h = window.innerHeight;
            if (this.maxWidth && b > this.maxWidth) {
                this.width = this.maxWidth
            } else {
                this.width = b
            }
            if (this.maxHeight && h > this.maxHeight) {
                this.height = this.maxHeight
            } else {
                this.height = h
            }
        }
    };
    Object.defineProperty(d.StageScaleMode.prototype, "isFullScreen", {
        get: function () {
            return (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement)
        }
    });
    Object.defineProperty(d.StageScaleMode.prototype, "isPortrait", {
        get: function () {
            return this.orientation == 0 || this.orientation == 180
        }
    });
    Object.defineProperty(d.StageScaleMode.prototype, "isLandscape", {
        get: function () {
            return this.orientation === 90 || this.orientation === -90
        }
    });
    d.Device = function () {
        this.patchAndroidClearRectBug = false;
        this.desktop = false;
        this.iOS = false;
        this.android = false;
        this.chromeOS = false;
        this.linux = false;
        this.macOS = false;
        this.windows = false;
        this.canvas = false;
        this.file = false;
        this.fileSystem = false;
        this.localStorage = false;
        this.webGL = false;
        this.worker = false;
        this.touch = false;
        this.mspointer = false;
        this.css3D = false;
        this.pointerLock = false;
        this.arora = false;
        this.chrome = false;
        this.epiphany = false;
        this.firefox = false;
        this.ie = false;
        this.ieVersion = 0;
        this.mobileSafari = false;
        this.midori = false;
        this.opera = false;
        this.safari = false;
        this.webApp = false;
        this.audioData = false;
        this.webAudio = false;
        this.ogg = false;
        this.opus = false;
        this.mp3 = false;
        this.wav = false;
        this.m4a = false;
        this.webm = false;
        this.iPhone = false;
        this.iPhone4 = false;
        this.iPad = false;
        this.pixelRatio = 0;
        this._checkAudio();
        this._checkBrowser();
        this._checkCSS3D();
        this._checkDevice();
        this._checkFeatures();
        this._checkOS()
    };
    d.Device.prototype = {
        _checkOS: function () {
            var b = navigator.userAgent;
            if (/Android/.test(b)) {
                this.android = true
            } else {
                if (/CrOS/.test(b)) {
                    this.chromeOS = true
                } else {
                    if (/iP[ao]d|iPhone/i.test(b)) {
                        this.iOS = true
                    } else {
                        if (/Linux/.test(b)) {
                            this.linux = true
                        } else {
                            if (/Mac OS/.test(b)) {
                                this.macOS = true
                            } else {
                                if (/Windows/.test(b)) {
                                    this.windows = true
                                }
                            }
                        }
                    }
                }
            }
            if (this.windows || this.macOS || this.linux) {
                this.desktop = true
            }
        }, _checkFeatures: function () {
            this.canvas = !!window.CanvasRenderingContext2D;
            try {
                this.localStorage = !!localStorage.getItem
            } catch (b) {
                this.localStorage = false
            }
            this.file = !!window.File && !!window.FileReader && !!window.FileList && !!window.Blob;
            this.fileSystem = !!window.requestFileSystem;
            this.webGL = (function () {
                try {
                    var h = document.createElement("canvas");
                    return !!window.WebGLRenderingContext && (h.getContext("webgl") || h.getContext("experimental-webgl"))
                } catch (i) {
                    return false
                }
            })();
            if (this.webGL === null || this.webGL === false) {
                this.webGL = false
            } else {
                this.webGL = true
            }
            this.worker = !!window.Worker;
            if ("ontouchstart" in document.documentElement || window.navigator.msPointerEnabled) {
                this.touch = true
            }
            if (window.navigator.msPointerEnabled) {
                this.mspointer = true
            }
            this.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document
        }, _checkBrowser: function () {
            var b = navigator.userAgent;
            if (/Arora/.test(b)) {
                this.arora = true
            } else {
                if (/Chrome/.test(b)) {
                    this.chrome = true
                } else {
                    if (/Epiphany/.test(b)) {
                        this.epiphany = true
                    } else {
                        if (/Firefox/.test(b)) {
                            this.firefox = true
                        } else {
                            if (/Mobile Safari/.test(b)) {
                                this.mobileSafari = true
                            } else {
                                if (/MSIE (\d+\.\d+);/.test(b)) {
                                    this.ie = true;
                                    this.ieVersion = parseInt(RegExp.$1)
                                } else {
                                    if (/Midori/.test(b)) {
                                        this.midori = true
                                    } else {
                                        if (/Opera/.test(b)) {
                                            this.opera = true
                                        } else {
                                            if (/Safari/.test(b)) {
                                                this.safari = true
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (navigator.standalone) {
                this.webApp = true
            }
        }, _checkAudio: function () {
            this.audioData = !!(window.Audio);
            this.webAudio = !!(window.webkitAudioContext || window.AudioContext);
            var i = document.createElement("audio");
            var b = false;
            try {
                if (b = !!i.canPlayType) {
                    if (i.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "")) {
                        this.ogg = true
                    }
                    if (i.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "")) {
                        this.opus = true
                    }
                    if (i.canPlayType("audio/mpeg;").replace(/^no$/, "")) {
                        this.mp3 = true
                    }
                    if (i.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "")) {
                        this.wav = true
                    }
                    if (i.canPlayType("audio/x-m4a;") || i.canPlayType("audio/aac;").replace(/^no$/, "")) {
                        this.m4a = true
                    }
                    if (i.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")) {
                        this.webm = true
                    }
                }
            } catch (h) {
            }
        }, _checkDevice: function () {
            this.pixelRatio = window.devicePixelRatio || 1;
            this.iPhone = navigator.userAgent.toLowerCase().indexOf("iphone") != -1;
            this.iPhone4 = (this.pixelRatio == 2 && this.iPhone);
            this.iPad = navigator.userAgent.toLowerCase().indexOf("ipad") != -1
        }, _checkCSS3D: function () {
            var i = document.createElement("p");
            var j;
            var h = {
                webkitTransform: "-webkit-transform",
                OTransform: "-o-transform",
                msTransform: "-ms-transform",
                MozTransform: "-moz-transform",
                transform: "transform"
            };
            document.body.insertBefore(i, null);
            for (var b in h) {
                if (i.style[b] !== undefined) {
                    i.style[b] = "translate3d(1px,1px,1px)";
                    j = window.getComputedStyle(i).getPropertyValue(h[b])
                }
            }
            document.body.removeChild(i);
            this.css3D = (j !== undefined && j.length > 0 && j !== "none")
        }, canPlayAudio: function (b) {
            if (b == "mp3" && this.mp3) {
                return true
            } else {
                if (b == "ogg" && (this.ogg || this.opus)) {
                    return true
                } else {
                    if (b == "m4a" && this.m4a) {
                        return true
                    } else {
                        if (b == "wav" && this.wav) {
                            return true
                        } else {
                            if (b == "webm" && this.webm) {
                                return true
                            }
                        }
                    }
                }
            }
            return false
        }, isConsoleOpen: function () {
            if (window.console && window.console.firebug) {
                return true
            }
            if (window.console) {
                console.profile();
                console.profileEnd();
                if (console.clear) {
                    console.clear()
                }
                return console.profiles.length > 0
            }
            return false
        }
    };
    d.RequestAnimationFrame = function (h) {
        this.game = h;
        this._isSetTimeOut = false;
        this.isRunning = false;
        var i = ["ms", "moz", "webkit", "o"];
        for (var b = 0; b < i.length && !window.requestAnimationFrame; b++) {
            window.requestAnimationFrame = window[i[b] + "RequestAnimationFrame"];
            window.cancelAnimationFrame = window[i[b] + "CancelAnimationFrame"]
        }
        this._onLoop = null
    };
    d.RequestAnimationFrame.prototype = {
        start: function () {
            this.isRunning = true;
            var b = this;
            if (!window.requestAnimationFrame) {
                this._isSetTimeOut = true;
                this._onLoop = function () {
                    return b.updateSetTimeout()
                };
                this._timeOutID = window.setTimeout(this._onLoop, 0)
            } else {
                this._isSetTimeOut = false;
                this._onLoop = function (h) {
                    return b.updateRAF(h)
                };
                window.requestAnimationFrame(this._onLoop)
            }
        }, updateRAF: function (b) {
            this.game.update(b);
            window.requestAnimationFrame(this._onLoop)
        }, updateSetTimeout: function () {
            this.game.update(Date.now());
            this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)
        }, stop: function () {
            if (this._isSetTimeOut) {
                clearTimeout(this._timeOutID)
            } else {
                window.cancelAnimationFrame
            }
            this.isRunning = false
        }, isSetTimeOut: function () {
            return this._isSetTimeOut
        }, isRAF: function () {
            return (this._isSetTimeOut === false)
        }
    };
    d.RandomDataGenerator = function (b) {
        if (typeof b === "undefined") {
            b = []
        }
        this.sow(b)
    };
    d.RandomDataGenerator.prototype = {
        c: 1, s0: 0, s1: 0, s2: 0, rnd: function () {
            var b = 2091639 * this.s0 + this.c * 2.3283064365386963e-10;
            this.c = b | 0;
            this.s0 = this.s1;
            this.s1 = this.s2;
            this.s2 = b - this.c;
            return this.s2
        }, sow: function (h) {
            if (typeof h === "undefined") {
                h = []
            }
            this.s0 = this.hash(" ");
            this.s1 = this.hash(this.s0);
            this.s2 = this.hash(this.s1);
            this.c = 1;
            var b;
            for (var j = 0; b = h[j++];) {
                this.s0 -= this.hash(b);
                this.s0 += ~~(this.s0 < 0);
                this.s1 -= this.hash(b);
                this.s1 += ~~(this.s1 < 0);
                this.s2 -= this.hash(b);
                this.s2 += ~~(this.s2 < 0)
            }
        }, hash: function (k) {
            var j, b, l;
            l = 4022871197;
            k = k.toString();
            for (b = 0; b < k.length; b++) {
                l += k.charCodeAt(b);
                j = 0.02519603282416938 * l;
                l = j >>> 0;
                j -= l;
                j *= l;
                l = j >>> 0;
                j -= l;
                l += j * 4294967296
            }
            return (l >>> 0) * 2.3283064365386963e-10
        }, integer: function () {
            return this.rnd.apply(this) * 4294967296
        }, frac: function () {
            return this.rnd.apply(this) + (this.rnd.apply(this) * 2097152 | 0) * 1.1102230246251565e-16
        }, real: function () {
            return this.integer() + this.frac()
        }, integerInRange: function (h, b) {
            return Math.floor(this.realInRange(h, b))
        }, realInRange: function (h, b) {
            return this.frac() * (b - h) + h
        }, normal: function () {
            return 1 - 2 * this.frac()
        }, uuid: function () {
            var i, h;
            for (h = i = ""; i++ < 36; h += ~i % 5 | i * 3 & 4 ? (i ^ 15 ? 8 ^ this.frac() * (i ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
            }
            return h
        }, pick: function (b) {
            return b[this.integerInRange(0, b.length)]
        }, weightedPick: function (b) {
            return b[~~(Math.pow(this.frac(), 2) * b.length)]
        }, timestamp: function (i, h) {
            return this.realInRange(i || 946684800000, h || 1577862000000)
        }, angle: function () {
            return this.integerInRange(-180, 180)
        }
    };
    d.Math = {
        PI2: Math.PI * 2, fuzzyEqual: function (i, h, j) {
            if (typeof j === "undefined") {
                j = 0.0001
            }
            return Math.abs(i - h) < j
        }, fuzzyLessThan: function (i, h, j) {
            if (typeof j === "undefined") {
                j = 0.0001
            }
            return i < h + j
        }, fuzzyGreaterThan: function (i, h, j) {
            if (typeof j === "undefined") {
                j = 0.0001
            }
            return i > h - j
        }, fuzzyCeil: function (b, h) {
            if (typeof h === "undefined") {
                h = 0.0001
            }
            return Math.ceil(b - h)
        }, fuzzyFloor: function (b, h) {
            if (typeof h === "undefined") {
                h = 0.0001
            }
            return Math.floor(b + h)
        }, average: function () {
            var b = [];
            for (var j = 0; j < (arguments.length - 0); j++) {
                b[j] = arguments[j + 0]
            }
            var k = 0;
            for (var h = 0; h < b.length; h++) {
                k += b[h]
            }
            return k / b.length
        }, truncate: function (b) {
            return (b > 0) ? Math.floor(b) : Math.ceil(b)
        }, shear: function (b) {
            return b % 1
        }, snapTo: function (b, i, h) {
            if (typeof h === "undefined") {
                h = 0
            }
            if (i == 0) {
                return b
            }
            b -= h;
            b = i * Math.round(b / i);
            return h + b
        }, snapToFloor: function (b, i, h) {
            if (typeof h === "undefined") {
                h = 0
            }
            if (i == 0) {
                return b
            }
            b -= h;
            b = i * Math.floor(b / i);
            return h + b
        }, snapToCeil: function (b, i, h) {
            if (typeof h === "undefined") {
                h = 0
            }
            if (i == 0) {
                return b
            }
            b -= h;
            b = i * Math.ceil(b / i);
            return h + b
        }, snapToInArray: function (j, h, l) {
            if (typeof l === "undefined") {
                l = true
            }
            if (l) {
                h.sort()
            }
            if (j < h[0]) {
                return h[0]
            }
            var k = 1;
            while (h[k] < j) {
                k++
            }
            var b = h[k - 1];
            var m = (k < h.length) ? h[k] : Number.POSITIVE_INFINITY;
            return ((m - j) <= (j - b)) ? m : b
        }, roundTo: function (i, b, h) {
            if (typeof b === "undefined") {
                b = 0
            }
            if (typeof h === "undefined") {
                h = 10
            }
            var j = Math.pow(h, -b);
            return Math.round(i * j) / j
        }, floorTo: function (i, b, h) {
            if (typeof b === "undefined") {
                b = 0
            }
            if (typeof h === "undefined") {
                h = 10
            }
            var j = Math.pow(h, -b);
            return Math.floor(i * j) / j
        }, ceilTo: function (i, b, h) {
            if (typeof b === "undefined") {
                b = 0
            }
            if (typeof h === "undefined") {
                h = 10
            }
            var j = Math.pow(h, -b);
            return Math.ceil(i * j) / j
        }, interpolateFloat: function (i, h, j) {
            return (h - i) * j + i
        }, angleBetween: function (h, j, b, i) {
            return Math.atan2(i - j, b - h)
        }, normalizeAngle: function (i, h) {
            if (typeof h === "undefined") {
                h = true
            }
            var b = (h) ? GameMath.PI : 180;
            return this.wrap(i, b, -b)
        }, nearestAngleBetween: function (h, b, j) {
            if (typeof j === "undefined") {
                j = true
            }
            var i = (j) ? Math.PI : 180;
            h = this.normalizeAngle(h, j);
            b = this.normalizeAngle(b, j);
            if (h < -i / 2 && b > i / 2) {
                h += i * 2
            }
            if (b < -i / 2 && h > i / 2) {
                b += i * 2
            }
            return b - h
        }, interpolateAngles: function (h, b, i, j, k) {
            if (typeof j === "undefined") {
                j = true
            }
            if (typeof k === "undefined") {
                k = null
            }
            h = this.normalizeAngle(h, j);
            b = this.normalizeAngleToAnother(b, h, j);
            return (typeof k === "function") ? k(i, h, b - h, 1) : this.interpolateFloat(h, b, i)
        }, chanceRoll: function (b) {
            if (typeof b === "undefined") {
                b = 50
            }
            if (b <= 0) {
                return false
            } else {
                if (b >= 100) {
                    return true
                } else {
                    if (Math.random() * 100 >= b) {
                        return false
                    } else {
                        return true
                    }
                }
            }
        }, numberArray: function (k, h) {
            var b = [];
            for (var j = k; j <= h; j++) {
                b.push(j)
            }
            return b
        }, maxAdd: function (i, h, b) {
            i += h;
            if (i > b) {
                i = b
            }
            return i
        }, minSub: function (i, h, b) {
            i -= h;
            if (i < b) {
                i = b
            }
            return i
        }, wrap: function (k, j, h) {
            var i = h - j;
            if (i <= 0) {
                return 0
            }
            var b = (k - j) % i;
            if (b < 0) {
                b += i
            }
            return b + j
        }, wrapValue: function (i, h, b) {
            var j;
            i = Math.abs(i);
            h = Math.abs(h);
            b = Math.abs(b);
            j = (i + h) % b;
            return j
        }, randomSign: function () {
            return (Math.random() > 0.5) ? 1 : -1
        }, isOdd: function (b) {
            return (b & 1)
        }, isEven: function (b) {
            if (b & 1) {
                return false
            } else {
                return true
            }
        }, max: function () {
            for (var j = 1, h = 0, b = arguments.length; j < b; j++) {
                if (arguments[h] < arguments[j]) {
                    h = j
                }
            }
            return arguments[h]
        }, min: function () {
            for (var j = 1, h = 0, b = arguments.length; j < b; j++) {
                if (arguments[j] < arguments[h]) {
                    h = j
                }
            }
            return arguments[h]
        }, wrapAngle: function (h) {
            var b = h;
            if (h >= -180 && h <= 180) {
                return h
            }
            b = (h + 180) % 360;
            if (b < 0) {
                b += 360
            }
            return b - 180
        }, angleLimit: function (j, i, h) {
            var b = j;
            if (j > h) {
                b = h
            } else {
                if (j < i) {
                    b = i
                }
            }
            return b
        }, linearInterpolation: function (j, h) {
            var b = j.length - 1;
            var n = b * h;
            var l = Math.floor(n);
            if (h < 0) {
                return this.linear(j[0], j[1], n)
            }
            if (h > 1) {
                return this.linear(j[b], j[b - 1], b - n)
            }
            return this.linear(j[l], j[l + 1 > b ? b : l + 1], n - l)
        }, bezierInterpolation: function (l, j) {
            var h = 0;
            var o = l.length - 1;
            for (var m = 0; m <= o; m++) {
                h += Math.pow(1 - j, o - m) * Math.pow(j, m) * l[m] * this.bernstein(o, m)
            }
            return h
        }, catmullRomInterpolation: function (j, h) {
            var b = j.length - 1;
            var n = b * h;
            var l = Math.floor(n);
            if (j[0] === j[b]) {
                if (h < 0) {
                    l = Math.floor(n = b * (1 + h))
                }
                return this.catmullRom(j[(l - 1 + b) % b], j[l], j[(l + 1) % b], j[(l + 2) % b], n - l)
            } else {
                if (h < 0) {
                    return j[0] - (this.catmullRom(j[0], j[0], j[1], j[1], -n) - j[0])
                }
                if (h > 1) {
                    return j[b] - (this.catmullRom(j[b], j[b], j[b - 1], j[b - 1], n - b) - j[b])
                }
                return this.catmullRom(j[l ? l - 1 : 0], j[l], j[b < l + 1 ? b : l + 1], j[b < l + 2 ? b : l + 2], n - l)
            }
        }, linear: function (i, h, b) {
            return (h - i) * b + i
        }, bernstein: function (h, b) {
            return this.factorial(h) / this.factorial(b) / this.factorial(h - b)
        }, catmullRom: function (n, m, k, j, o) {
            var l = (k - n) * 0.5, i = (j - m) * 0.5, h = o * o, b = o * h;
            return (2 * m - 2 * k + l + i) * b + (-3 * m + 3 * k - 2 * l - i) * h + l * o + m
        }, difference: function (i, h) {
            return Math.abs(i - h)
        }, getRandom: function (i, j, h) {
            if (typeof j === "undefined") {
                j = 0
            }
            if (typeof h === "undefined") {
                h = 0
            }
            if (i != null) {
                var b = h;
                if ((b == 0) || (b > i.length - j)) {
                    b = i.length - j
                }
                if (b > 0) {
                    return i[j + Math.floor(Math.random() * b)]
                }
            }
            return null
        }, floor: function (b) {
            var h = b | 0;
            return (b > 0) ? (h) : ((h != b) ? (h - 1) : (h))
        }, ceil: function (b) {
            var h = b | 0;
            return (b > 0) ? ((h != b) ? (h + 1) : (h)) : (h)
        }, sinCosGenerator: function (b, n, h, l) {
            if (typeof n === "undefined") {
                n = 1
            }
            if (typeof h === "undefined") {
                h = 1
            }
            if (typeof l === "undefined") {
                l = 1
            }
            var m = n;
            var p = h;
            var j = l * Math.PI / b;
            var i = [];
            var o = [];
            for (var k = 0; k < b; k++) {
                p -= m * j;
                m += p * j;
                i[k] = p;
                o[k] = m
            }
            return {sin: o, cos: i}
        }, shift: function (b) {
            var h = b.shift();
            b.push(h);
            return h
        }, shuffleArray: function (l) {
            for (var k = l.length - 1; k > 0; k--) {
                var h = Math.floor(Math.random() * (k + 1));
                var b = l[k];
                l[k] = l[h];
                l[h] = b
            }
            return l
        }, distance: function (j, l, i, k) {
            var h = j - i;
            var b = l - k;
            return Math.sqrt(h * h + b * b)
        }, distanceRounded: function (h, j, b, i) {
            return Math.round(d.Math.distance(h, j, b, i))
        }, clamp: function (i, j, h) {
            return (i < j) ? j : ((i > h) ? h : i)
        }, clampBottom: function (b, h) {
            return b < h ? h : b
        }, within: function (i, h, j) {
            return (Math.abs(i - h) <= j)
        }, mapLinear: function (h, i, b, k, j) {
            return k + (h - i) * (j - k) / (b - i)
        }, smoothstep: function (h, i, b) {
            if (h <= i) {
                return 0
            }
            if (h >= b) {
                return 1
            }
            h = (h - i) / (b - i);
            return h * h * (3 - 2 * h)
        }, smootherstep: function (h, i, b) {
            if (h <= i) {
                return 0
            }
            if (h >= b) {
                return 1
            }
            h = (h - i) / (b - i);
            return h * h * h * (h * (h * 6 - 15) + 10)
        }, sign: function (b) {
            return (b < 0) ? -1 : ((b > 0) ? 1 : 0)
        }, degToRad: function () {
            var b = Math.PI / 180;
            return function (h) {
                return h * b
            }
        }(), radToDeg: function () {
            var b = 180 / Math.PI;
            return function (h) {
                return h * b
            }
        }()
    };
    d.QuadTree = function (l, h, n, k, b, j, i, m) {
        this.physicsManager = l;
        this.ID = l.quadTreeID;
        l.quadTreeID++;
        this.maxObjects = j || 10;
        this.maxLevels = i || 4;
        this.level = m || 0;
        this.bounds = {
            x: Math.round(h),
            y: Math.round(n),
            width: k,
            height: b,
            subWidth: Math.floor(k / 2),
            subHeight: Math.floor(b / 2),
            right: Math.round(h) + Math.floor(k / 2),
            bottom: Math.round(n) + Math.floor(b / 2)
        };
        this.objects = [];
        this.nodes = []
    };
    d.QuadTree.prototype = {
        split: function () {
            this.level++;
            this.nodes[0] = new d.QuadTree(this.physicsManager, this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[1] = new d.QuadTree(this.physicsManager, this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[2] = new d.QuadTree(this.physicsManager, this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level);
            this.nodes[3] = new d.QuadTree(this.physicsManager, this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level)
        }, insert: function (b) {
            var j = 0;
            var h;
            if (this.nodes[0] != null) {
                h = this.getIndex(b);
                if (h !== -1) {
                    this.nodes[h].insert(b);
                    return
                }
            }
            this.objects.push(b);
            if (this.objects.length > this.maxObjects && this.level < this.maxLevels) {
                if (this.nodes[0] == null) {
                    this.split()
                }
                while (j < this.objects.length) {
                    h = this.getIndex(this.objects[j]);
                    if (h !== -1) {
                        this.nodes[h].insert(this.objects.splice(j, 1)[0])
                    } else {
                        j++
                    }
                }
            }
        }, getIndex: function (h) {
            var b = -1;
            if (h.x < this.bounds.right && h.right < this.bounds.right) {
                if ((h.y < this.bounds.bottom && h.bottom < this.bounds.bottom)) {
                    b = 1
                } else {
                    if ((h.y > this.bounds.bottom)) {
                        b = 2
                    }
                }
            } else {
                if (h.x > this.bounds.right) {
                    if ((h.y < this.bounds.bottom && h.bottom < this.bounds.bottom)) {
                        b = 0
                    } else {
                        if ((h.y > this.bounds.bottom)) {
                            b = 3
                        }
                    }
                }
            }
            return b
        }, retrieve: function (b) {
            var h = this.objects;
            b.body.quadTreeIndex = this.getIndex(b.body);
            b.body.quadTreeIDs.push(this.ID);
            if (this.nodes[0]) {
                if (b.body.quadTreeIndex !== -1) {
                    h = h.concat(this.nodes[b.body.quadTreeIndex].retrieve(b))
                } else {
                    h = h.concat(this.nodes[0].retrieve(b));
                    h = h.concat(this.nodes[1].retrieve(b));
                    h = h.concat(this.nodes[2].retrieve(b));
                    h = h.concat(this.nodes[3].retrieve(b))
                }
            }
            return h
        }, clear: function () {
            this.objects = [];
            for (var h = 0, b = this.nodes.length; h < b; h++) {
                if (this.nodes[h]) {
                    this.nodes[h].clear();
                    delete this.nodes[h]
                }
            }
        }
    };
    d.Circle = function (b, i, h) {
        b = b || 0;
        i = i || 0;
        h = h || 0;
        this.x = b;
        this.y = i;
        this._diameter = h;
        if (h > 0) {
            this._radius = h * 0.5
        } else {
            this._radius = 0
        }
    };
    d.Circle.prototype = {
        circumference: function () {
            return 2 * (Math.PI * this._radius)
        }, setTo: function (b, i, h) {
            this.x = b;
            this.y = i;
            this._diameter = h;
            this._radius = h * 0.5;
            return this
        }, copyFrom: function (b) {
            return this.setTo(b.x, b.y, b.diameter)
        }, copyTo: function (b) {
            b[x] = this.x;
            b[y] = this.y;
            b[diameter] = this._diameter;
            return b
        }, distance: function (h, b) {
            if (typeof b === "undefined") {
                b = false
            }
            if (b) {
                return d.Math.distanceRound(this.x, this.y, h.x, h.y)
            } else {
                return d.Math.distance(this.x, this.y, h.x, h.y)
            }
        }, clone: function (b) {
            if (typeof b === "undefined") {
                b = new d.Circle()
            }
            return b.setTo(a.x, a.y, a.diameter)
        }, contains: function (b, h) {
            return d.Circle.contains(this, b, h)
        }, circumferencePoint: function (i, h, b) {
            return d.Circle.circumferencePoint(this, i, h, b)
        }, offset: function (h, b) {
            this.x += h;
            this.y += b;
            return this
        }, offsetPoint: function (b) {
            return this.offset(b.x, b.y)
        }, toString: function () {
            return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
        }
    };
    Object.defineProperty(d.Circle.prototype, "diameter", {
        get: function () {
            return this._diameter
        }, set: function (b) {
            if (b > 0) {
                this._diameter = b;
                this._radius = b * 0.5
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "radius", {
        get: function () {
            return this._radius
        }, set: function (b) {
            if (b > 0) {
                this._radius = b;
                this._diameter = b * 2
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "left", {
        get: function () {
            return this.x - this._radius
        }, set: function (b) {
            if (b > this.x) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = this.x - b
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "right", {
        get: function () {
            return this.x + this._radius
        }, set: function (b) {
            if (b < this.x) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = b - this.x
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "top", {
        get: function () {
            return this.y - this._radius
        }, set: function (b) {
            if (b > this.y) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = this.y - b
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "bottom", {
        get: function () {
            return this.y + this._radius
        }, set: function (b) {
            if (b < this.y) {
                this._radius = 0;
                this._diameter = 0
            } else {
                this.radius = b - this.y
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "area", {
        get: function () {
            if (this._radius > 0) {
                return Math.PI * this._radius * this._radius
            } else {
                return 0
            }
        }
    });
    Object.defineProperty(d.Circle.prototype, "empty", {
        get: function () {
            return (this._diameter == 0)
        }, set: function (b) {
            this.setTo(0, 0, 0)
        }
    });
    d.Circle.contains = function (i, b, k) {
        if (b >= i.left && b <= i.right && k >= i.top && k <= i.bottom) {
            var j = (i.x - b) * (i.x - b);
            var h = (i.y - k) * (i.y - k);
            return (j + h) <= (i.radius * i.radius)
        }
        return false
    };
    d.Circle.equals = function (i, h) {
        return (i.x == h.x && i.y == h.y && i.diameter == h.diameter)
    };
    d.Circle.intersects = function (i, h) {
        return (d.Math.distance(i.x, i.y, h.x, h.y) <= (i.radius + h.radius))
    };
    d.Circle.circumferencePoint = function (b, j, i, h) {
        if (typeof i === "undefined") {
            i = false
        }
        if (typeof h === "undefined") {
            h = new d.Point()
        }
        if (i === true) {
            j = d.Math.radToDeg(j)
        }
        h.x = b.x + b.radius * Math.cos(j);
        h.y = b.y + b.radius * Math.sin(j);
        return h
    };
    d.Circle.intersectsRectangle = function (q, h) {
        var k = Math.abs(q.x - h.x - h.halfWidth);
        var p = h.halfWidth + q.radius;
        if (k > p) {
            return false
        }
        var j = Math.abs(q.y - h.y - h.halfHeight);
        var n = h.halfHeight + q.radius;
        if (j > n) {
            return false
        }
        if (k <= h.halfWidth || j <= h.halfHeight) {
            return true
        }
        var l = k - h.halfWidth;
        var i = j - h.halfHeight;
        var o = l * l;
        var b = i * i;
        var m = q.radius * q.radius;
        return o + b <= m
    };
    d.Point = function (b, h) {
        b = b || 0;
        h = h || 0;
        this.x = b;
        this.y = h
    };
    d.Point.prototype = {
        copyFrom: function (b) {
            return this.setTo(b.x, b.y)
        }, invert: function () {
            return this.setTo(this.y, this.x)
        }, setTo: function (b, h) {
            this.x = b;
            this.y = h;
            return this
        }, add: function (b, h) {
            this.x += b;
            this.y += h;
            return this
        }, subtract: function (b, h) {
            this.x -= b;
            this.y -= h;
            return this
        }, multiply: function (b, h) {
            this.x *= b;
            this.y *= h;
            return this
        }, divide: function (b, h) {
            this.x /= b;
            this.y /= h;
            return this
        }, clampX: function (h, b) {
            this.x = d.Math.clamp(this.x, h, b);
            return this
        }, clampY: function (h, b) {
            this.y = d.Math.clamp(this.y, h, b);
            return this
        }, clamp: function (h, b) {
            this.x = d.Math.clamp(this.x, h, b);
            this.y = d.Math.clamp(this.y, h, b);
            return this
        }, clone: function (b) {
            if (typeof b === "undefined") {
                b = new d.Point
            }
            return b.setTo(this.x, this.y)
        }, copyFrom: function (b) {
            return this.setTo(b.x, b.y)
        }, copyTo: function (b) {
            b[x] = this.x;
            b[y] = this.y;
            return b
        }, distance: function (h, b) {
            return d.Point.distance(this, h, b)
        }, equals: function (b) {
            return (b.x == this.x && b.y == this.y)
        }, rotate: function (b, k, i, h, j) {
            return d.Point.rotate(this, b, k, i, h, j)
        }, toString: function () {
            return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
        }
    };
    d.Point.add = function (i, h, j) {
        if (typeof j === "undefined") {
            j = new d.Point()
        }
        j.x = i.x + h.x;
        j.y = i.y + h.y;
        return j
    };
    d.Point.subtract = function (i, h, j) {
        if (typeof j === "undefined") {
            j = new d.Point()
        }
        j.x = i.x - h.x;
        j.y = i.y - h.y;
        return j
    };
    d.Point.multiply = function (i, h, j) {
        if (typeof j === "undefined") {
            j = new d.Point()
        }
        j.x = i.x * h.x;
        j.y = i.y * h.y;
        return j
    };
    d.Point.divide = function (i, h, j) {
        if (typeof j === "undefined") {
            j = new d.Point()
        }
        j.x = i.x / h.x;
        j.y = i.y / h.y;
        return j
    };
    d.Point.equals = function (i, h) {
        return (i.x == h.x && i.y == h.y)
    };
    d.Point.distance = function (i, h, j) {
        if (typeof j === "undefined") {
            j = false
        }
        if (j) {
            return d.Math.distanceRound(i.x, i.y, h.x, h.y)
        } else {
            return d.Math.distance(i.x, i.y, h.x, h.y)
        }
    }, d.Point.rotate = function (h, b, l, j, i, k) {
        i = i || false;
        k = k || null;
        if (i) {
            j = d.Math.radToDeg(j)
        }
        if (k === null) {
            k = Math.sqrt(((b - h.x) * (b - h.x)) + ((l - h.y) * (l - h.y)))
        }
        return h.setTo(b + k * Math.cos(j), l + k * Math.sin(j))
    };
    d.Rectangle = function (h, j, i, b) {
        h = h || 0;
        j = j || 0;
        i = i || 0;
        b = b || 0;
        this.x = h;
        this.y = j;
        this.width = i;
        this.height = b
    };
    d.Rectangle.prototype = {
        offset: function (h, b) {
            this.x += h;
            this.y += b;
            return this
        }, offsetPoint: function (b) {
            return this.offset(b.x, b.y)
        }, setTo: function (h, j, i, b) {
            this.x = h;
            this.y = j;
            this.width = i;
            this.height = b;
            return this
        }, floor: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y)
        }, floorAll: function () {
            this.x = Math.floor(this.x);
            this.y = Math.floor(this.y);
            this.width = Math.floor(this.width);
            this.height = Math.floor(this.height)
        }, copyFrom: function (b) {
            return this.setTo(b.x, b.y, b.width, b.height)
        }, copyTo: function (b) {
            b.x = this.x;
            b.y = this.y;
            b.width = this.width;
            b.height = this.height;
            return b
        }, inflate: function (h, b) {
            return d.Rectangle.inflate(this, h, b)
        }, size: function (b) {
            return d.Rectangle.size(this, b)
        }, clone: function (b) {
            return d.Rectangle.clone(this, b)
        }, contains: function (b, h) {
            return d.Rectangle.contains(this, b, h)
        }, containsRect: function (h) {
            return d.Rectangle.containsRect(this, h)
        }, equals: function (h) {
            return d.Rectangle.equals(this, h)
        }, intersection: function (h, i) {
            return d.Rectangle.intersection(this, h, output)
        }, intersects: function (h, i) {
            return d.Rectangle.intersects(this, h, i)
        }, intersectsRaw: function (k, i, j, h, b) {
            return d.Rectangle.intersectsRaw(this, k, i, j, h, b)
        }, union: function (h, i) {
            return d.Rectangle.union(this, h, i)
        }, toString: function () {
            return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
        }
    };
    Object.defineProperty(d.Rectangle.prototype, "halfWidth", {
        get: function () {
            return Math.round(this.width / 2)
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "halfHeight", {
        get: function () {
            return Math.round(this.height / 2)
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "bottom", {
        get: function () {
            return this.y + this.height
        }, set: function (b) {
            if (b <= this.y) {
                this.height = 0
            } else {
                this.height = (this.y - b)
            }
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "bottomRight", {
        get: function () {
            return new d.Point(this.right, this.bottom)
        }, set: function (b) {
            this.right = b.x;
            this.bottom = b.y
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "left", {
        get: function () {
            return this.x
        }, set: function (b) {
            if (b >= this.right) {
                this.width = 0
            } else {
                this.width = this.right - b
            }
            this.x = b
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "right", {
        get: function () {
            return this.x + this.width
        }, set: function (b) {
            if (b <= this.x) {
                this.width = 0
            } else {
                this.width = this.x + b
            }
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "volume", {
        get: function () {
            return this.width * this.height
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "perimeter", {
        get: function () {
            return (this.width * 2) + (this.height * 2)
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "centerX", {
        get: function () {
            return this.x + this.halfWidth
        }, set: function (b) {
            this.x = b - this.halfWidth
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "centerY", {
        get: function () {
            return this.y + this.halfHeight
        }, set: function (b) {
            this.y = b - this.halfHeight
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "top", {
        get: function () {
            return this.y
        }, set: function (b) {
            if (b >= this.bottom) {
                this.height = 0;
                this.y = b
            } else {
                this.height = (this.bottom - b)
            }
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "topLeft", {
        get: function () {
            return new d.Point(this.x, this.y)
        }, set: function (b) {
            this.x = b.x;
            this.y = b.y
        }
    });
    Object.defineProperty(d.Rectangle.prototype, "empty", {
        get: function () {
            return (!this.width || !this.height)
        }, set: function (b) {
            this.setTo(0, 0, 0, 0)
        }
    });
    d.Rectangle.inflate = function (h, i, b) {
        h.x -= i;
        h.width += 2 * i;
        h.y -= b;
        h.height += 2 * b;
        return h
    };
    d.Rectangle.inflatePoint = function (h, b) {
        return d.Rectangle.inflate(h, b.x, b.y)
    };
    d.Rectangle.size = function (b, h) {
        if (typeof h === "undefined") {
            h = new d.Point()
        }
        return h.setTo(b.width, b.height)
    };
    d.Rectangle.clone = function (b, h) {
        if (typeof h === "undefined") {
            h = new d.Rectangle()
        }
        return h.setTo(b.x, b.y, b.width, b.height)
    };
    d.Rectangle.contains = function (h, b, i) {
        return (b >= h.x && b <= h.right && i >= h.y && i <= h.bottom)
    };
    d.Rectangle.containsRaw = function (j, i, k, h, b, l) {
        return (b >= j && b <= (j + k) && l >= i && l <= (i + h))
    };
    d.Rectangle.containsPoint = function (h, b) {
        return d.Rectangle.contains(h, b.x, b.y)
    };
    d.Rectangle.containsRect = function (i, h) {
        if (i.volume > h.volume) {
            return false
        }
        return (i.x >= h.x && i.y >= h.y && i.right <= h.right && i.bottom <= h.bottom)
    };
    d.Rectangle.equals = function (i, h) {
        return (i.x == h.x && i.y == h.y && i.width == h.width && i.height == h.height)
    };
    d.Rectangle.intersection = function (i, h, j) {
        j = j || new d.Rectangle;
        if (d.Rectangle.intersects(i, h)) {
            j.x = Math.max(i.x, h.x);
            j.y = Math.max(i.y, h.y);
            j.width = Math.min(i.right, h.right) - j.x;
            j.height = Math.min(i.bottom, h.bottom) - j.y
        }
        return j
    };
    d.Rectangle.intersects = function (i, h) {
        return (i.x < h.right && h.x < i.right && i.y < h.bottom && h.y < i.bottom)
    };
    d.Rectangle.intersectsRaw = function (b, l, j, k, i, h) {
        if (typeof h === "undefined") {
            h = 0
        }
        return !(l > b.right + h || j < b.left - h || k > b.bottom + h || i < b.top - h)
    };
    d.Rectangle.union = function (i, h, j) {
        if (typeof j === "undefined") {
            j = new d.Rectangle()
        }
        return j.setTo(Math.min(i.x, h.x), Math.min(i.y, h.y), Math.max(i.right, h.right) - Math.min(i.left, h.left), Math.max(i.bottom, h.bottom) - Math.min(i.top, h.top))
    };
    d.Net = function (b) {
        this.game = b
    };
    d.Net.prototype = {
        getHostName: function () {
            if (window.location && window.location.hostname) {
                return window.location.hostname
            }
            return null
        }, checkDomainName: function (b) {
            return window.location.hostname.indexOf(b) !== -1
        }, updateQueryString: function (i, k, n, h) {
            if (typeof n === "undefined") {
                n = false
            }
            if (typeof h === "undefined") {
                h = ""
            }
            if (h == "") {
                h = window.location.href
            }
            var b = "";
            var j = new RegExp("([?|&])" + i + "=.*?(&|#|$)(.*)", "gi");
            if (j.test(h)) {
                if (typeof k !== "undefined" && k !== null) {
                    b = h.replace(j, "$1" + i + "=" + k + "$2$3")
                } else {
                    b = h.replace(j, "$1$3").replace(/(&|\?)$/, "")
                }
            } else {
                if (typeof k !== "undefined" && k !== null) {
                    var m = h.indexOf("?") !== -1 ? "&" : "?";
                    var l = h.split("#");
                    h = l[0] + m + i + "=" + k;
                    if (l[1]) {
                        h += "#" + l[1]
                    }
                    b = h
                } else {
                    b = h
                }
            }
            if (n) {
                window.location.href = b
            } else {
                return b
            }
        }, getQueryString: function (l) {
            if (typeof l === "undefined") {
                l = ""
            }
            var h = {};
            var b = location.search.substring(1).split("&");
            for (var k in b) {
                var j = b[k].split("=");
                if (j.length > 1) {
                    if (l && l == this.decodeURI(j[0])) {
                        return this.decodeURI(j[1])
                    } else {
                        h[this.decodeURI(j[0])] = this.decodeURI(j[1])
                    }
                }
            }
            return h
        }, decodeURI: function (b) {
            return decodeURIComponent(b.replace(/\+/g, " "))
        }
    };
    d.TweenManager = function (b) {
        this.game = b;
        this._tweens = [];
        this._add = [];
        this.game.onPause.add(this.pauseAll, this);
        this.game.onResume.add(this.resumeAll, this)
    };
    d.TweenManager.prototype = {
        REVISION: "11dev", getAll: function () {
            return this._tweens
        }, removeAll: function () {
            this._tweens = []
        }, add: function (b) {
            this._add.push(b)
        }, create: function (b) {
            return new d.Tween(b, this.game)
        }, remove: function (h) {
            var b = this._tweens.indexOf(h);
            if (b !== -1) {
                this._tweens[b].pendingDelete = true
            }
        }, update: function () {
            if (this._tweens.length === 0 && this._add.length === 0) {
                return false
            }
            var b = 0;
            var h = this._tweens.length;
            while (b < h) {
                if (this._tweens[b].update(this.game.time.now)) {
                    b++
                } else {
                    this._tweens.splice(b, 1);
                    h--
                }
            }
            if (this._add.length > 0) {
                this._tweens = this._tweens.concat(this._add);
                this._add.length = 0
            }
            return true
        }, pauseAll: function () {
            for (var b = this._tweens.length - 1; b >= 0; b--) {
                this._tweens[b].pause()
            }
        }, resumeAll: function () {
            for (var b = this._tweens.length - 1; b >= 0; b--) {
                this._tweens[b].resume()
            }
        }
    };
    d.Tween = function (h, b) {
        this._object = h;
        this.game = b;
        this._manager = this.game.tweens;
        this._valuesStart = {};
        this._valuesEnd = {};
        this._valuesStartRepeat = {};
        this._duration = 1000;
        this._repeat = 0;
        this._yoyo = false;
        this._reversed = false;
        this._delayTime = 0;
        this._startTime = null;
        this._easingFunction = d.Easing.Linear.None;
        this._interpolationFunction = d.Math.linearInterpolation;
        this._chainedTweens = [];
        this._onStartCallback = null;
        this._onStartCallbackFired = false;
        this._onUpdateCallback = null;
        this._onCompleteCallback = null;
        this._pausedTime = 0;
        this.pendingDelete = false;
        for (var i in h) {
            this._valuesStart[i] = parseFloat(h[i], 10)
        }
        this.onStart = new d.Signal();
        this.onComplete = new d.Signal();
        this.isRunning = false
    };
    d.Tween.prototype = {
        to: function (j, m, n, i, h, l, k) {
            m = m || 1000;
            n = n || null;
            i = i || false;
            h = h || 0;
            l = l || 0;
            k = k || false;
            var b;
            if (this._parent) {
                b = this._manager.create(this._object);
                this._lastChild.chain(b);
                this._lastChild = b
            } else {
                b = this;
                this._parent = this;
                this._lastChild = this
            }
            b._repeat = l;
            b._duration = m;
            b._valuesEnd = j;
            if (n !== null) {
                b._easingFunction = n
            }
            if (h > 0) {
                b._delayTime = h
            }
            b._yoyo = k;
            if (i) {
                return this.start()
            } else {
                return this
            }
        }, start: function (h) {
            if (this.game === null || this._object === null) {
                return
            }
            this._manager.add(this);
            this.onStart.dispatch(this._object);
            this.isRunning = true;
            this._onStartCallbackFired = false;
            this._startTime = this.game.time.now + this._delayTime;
            for (var b in this._valuesEnd) {
                if (this._valuesEnd[b] instanceof Array) {
                    if (this._valuesEnd[b].length === 0) {
                        continue
                    }
                    this._valuesEnd[b] = [this._object[b]].concat(this._valuesEnd[b])
                }
                this._valuesStart[b] = this._object[b];
                if ((this._valuesStart[b] instanceof Array) === false) {
                    this._valuesStart[b] *= 1
                }
                this._valuesStartRepeat[b] = this._valuesStart[b] || 0
            }
            return this
        }, stop: function () {
            this.isRunning = false;
            this._manager.remove(this);
            return this
        }, delay: function (b) {
            this._delayTime = b;
            return this
        }, repeat: function (b) {
            this._repeat = b;
            return this
        }, yoyo: function (b) {
            this._yoyo = b;
            return this
        }, easing: function (b) {
            this._easingFunction = b;
            return this
        }, interpolation: function (b) {
            this._interpolationFunction = b;
            return this
        }, chain: function () {
            this._chainedTweens = arguments;
            return this
        }, loop: function () {
            this._lastChild.chain(this);
            return this
        }, onStartCallback: function (b) {
            this._onStartCallback = b;
            return this
        }, onUpdateCallback: function (b) {
            this._onUpdateCallback = b;
            return this
        }, onCompleteCallback: function (b) {
            this._onCompleteCallback = b;
            return this
        }, pause: function () {
            this._paused = true;
            this._pausedTime = this.game.time.now
        }, resume: function () {
            this._paused = false;
            this._startTime += (this.game.time.now - this._pausedTime)
        }, update: function (h) {
            if (this.pendingDelete) {
                return false
            }
            if (this._paused || h < this._startTime) {
                return true
            }
            var o;
            if (h < this._startTime) {
                return true
            }
            if (this._onStartCallbackFired === false) {
                if (this._onStartCallback !== null) {
                    this._onStartCallback.call(this._object)
                }
                this._onStartCallbackFired = true
            }
            var p = (h - this._startTime) / this._duration;
            p = p > 1 ? 1 : p;
            var n = this._easingFunction(p);
            for (o in this._valuesEnd) {
                var b = this._valuesStart[o] || 0;
                var j = this._valuesEnd[o];
                if (j instanceof Array) {
                    this._object[o] = this._interpolationFunction(j, n)
                } else {
                    if (typeof(j) === "string") {
                        j = b + parseFloat(j, 10)
                    }
                    if (typeof(j) === "number") {
                        this._object[o] = b + (j - b) * n
                    }
                }
            }
            if (this._onUpdateCallback !== null) {
                this._onUpdateCallback.call(this._object, n)
            }
            if (p == 1) {
                if (this._repeat > 0) {
                    if (isFinite(this._repeat)) {
                        this._repeat--
                    }
                    for (o in this._valuesStartRepeat) {
                        if (typeof(this._valuesEnd[o]) === "string") {
                            this._valuesStartRepeat[o] = this._valuesStartRepeat[o] + parseFloat(this._valuesEnd[o], 10)
                        }
                        if (this._yoyo) {
                            var k = this._valuesStartRepeat[o];
                            this._valuesStartRepeat[o] = this._valuesEnd[o];
                            this._valuesEnd[o] = k;
                            this._reversed = !this._reversed
                        }
                        this._valuesStart[o] = this._valuesStartRepeat[o]
                    }
                    this._startTime = h + this._delayTime;
                    this.onComplete.dispatch(this._object);
                    if (this._onCompleteCallback !== null) {
                        this._onCompleteCallback.call(this._object)
                    }
                    return true
                } else {
                    this.onComplete.dispatch(this._object);
                    if (this._onCompleteCallback !== null) {
                        this._onCompleteCallback.call(this._object)
                    }
                    for (var l = 0, m = this._chainedTweens.length; l < m; l++) {
                        this._chainedTweens[l].start(h)
                    }
                    return false
                }
            }
            return true
        }
    };
    d.Easing = {
        Linear: {
            None: function (b) {
                return b
            }
        }, Quadratic: {
            In: function (b) {
                return b * b
            }, Out: function (b) {
                return b * (2 - b)
            }, InOut: function (b) {
                if ((b *= 2) < 1) {
                    return 0.5 * b * b
                }
                return -0.5 * (--b * (b - 2) - 1)
            }
        }, Cubic: {
            In: function (b) {
                return b * b * b
            }, Out: function (b) {
                return --b * b * b + 1
            }, InOut: function (b) {
                if ((b *= 2) < 1) {
                    return 0.5 * b * b * b
                }
                return 0.5 * ((b -= 2) * b * b + 2)
            }
        }, Quartic: {
            In: function (b) {
                return b * b * b * b
            }, Out: function (b) {
                return 1 - (--b * b * b * b)
            }, InOut: function (b) {
                if ((b *= 2) < 1) {
                    return 0.5 * b * b * b * b
                }
                return -0.5 * ((b -= 2) * b * b * b - 2)
            }
        }, Quintic: {
            In: function (b) {
                return b * b * b * b * b
            }, Out: function (b) {
                return --b * b * b * b * b + 1
            }, InOut: function (b) {
                if ((b *= 2) < 1) {
                    return 0.5 * b * b * b * b * b
                }
                return 0.5 * ((b -= 2) * b * b * b * b + 2)
            }
        }, Sinusoidal: {
            In: function (b) {
                return 1 - Math.cos(b * Math.PI / 2)
            }, Out: function (b) {
                return Math.sin(b * Math.PI / 2)
            }, InOut: function (b) {
                return 0.5 * (1 - Math.cos(Math.PI * b))
            }
        }, Exponential: {
            In: function (b) {
                return b === 0 ? 0 : Math.pow(1024, b - 1)
            }, Out: function (b) {
                return b === 1 ? 1 : 1 - Math.pow(2, -10 * b)
            }, InOut: function (b) {
                if (b === 0) {
                    return 0
                }
                if (b === 1) {
                    return 1
                }
                if ((b *= 2) < 1) {
                    return 0.5 * Math.pow(1024, b - 1)
                }
                return 0.5 * (-Math.pow(2, -10 * (b - 1)) + 2)
            }
        }, Circular: {
            In: function (b) {
                return 1 - Math.sqrt(1 - b * b)
            }, Out: function (b) {
                return Math.sqrt(1 - (--b * b))
            }, InOut: function (b) {
                if ((b *= 2) < 1) {
                    return -0.5 * (Math.sqrt(1 - b * b) - 1)
                }
                return 0.5 * (Math.sqrt(1 - (b -= 2) * b) + 1)
            }
        }, Elastic: {
            In: function (h) {
                var i, b = 0.1, j = 0.4;
                if (h === 0) {
                    return 0
                }
                if (h === 1) {
                    return 1
                }
                if (!b || b < 1) {
                    b = 1;
                    i = j / 4
                } else {
                    i = j * Math.asin(1 / b) / (2 * Math.PI)
                }
                return -(b * Math.pow(2, 10 * (h -= 1)) * Math.sin((h - i) * (2 * Math.PI) / j))
            }, Out: function (h) {
                var i, b = 0.1, j = 0.4;
                if (h === 0) {
                    return 0
                }
                if (h === 1) {
                    return 1
                }
                if (!b || b < 1) {
                    b = 1;
                    i = j / 4
                } else {
                    i = j * Math.asin(1 / b) / (2 * Math.PI)
                }
                return (b * Math.pow(2, -10 * h) * Math.sin((h - i) * (2 * Math.PI) / j) + 1)
            }, InOut: function (h) {
                var i, b = 0.1, j = 0.4;
                if (h === 0) {
                    return 0
                }
                if (h === 1) {
                    return 1
                }
                if (!b || b < 1) {
                    b = 1;
                    i = j / 4
                } else {
                    i = j * Math.asin(1 / b) / (2 * Math.PI)
                }
                if ((h *= 2) < 1) {
                    return -0.5 * (b * Math.pow(2, 10 * (h -= 1)) * Math.sin((h - i) * (2 * Math.PI) / j))
                }
                return b * Math.pow(2, -10 * (h -= 1)) * Math.sin((h - i) * (2 * Math.PI) / j) * 0.5 + 1
            }
        }, Back: {
            In: function (b) {
                var h = 1.70158;
                return b * b * ((h + 1) * b - h)
            }, Out: function (b) {
                var h = 1.70158;
                return --b * b * ((h + 1) * b + h) + 1
            }, InOut: function (b) {
                var h = 1.70158 * 1.525;
                if ((b *= 2) < 1) {
                    return 0.5 * (b * b * ((h + 1) * b - h))
                }
                return 0.5 * ((b -= 2) * b * ((h + 1) * b + h) + 2)
            }
        }, Bounce: {
            In: function (b) {
                return 1 - d.Easing.Bounce.Out(1 - b)
            }, Out: function (b) {
                if (b < (1 / 2.75)) {
                    return 7.5625 * b * b
                } else {
                    if (b < (2 / 2.75)) {
                        return 7.5625 * (b -= (1.5 / 2.75)) * b + 0.75
                    } else {
                        if (b < (2.5 / 2.75)) {
                            return 7.5625 * (b -= (2.25 / 2.75)) * b + 0.9375
                        } else {
                            return 7.5625 * (b -= (2.625 / 2.75)) * b + 0.984375
                        }
                    }
                }
            }, InOut: function (b) {
                if (b < 0.5) {
                    return d.Easing.Bounce.In(b * 2) * 0.5
                }
                return d.Easing.Bounce.Out(b * 2 - 1) * 0.5 + 0.5
            }
        }
    };
    d.Time = function (b) {
        this.game = b;
        this._started = 0;
        this._timeLastSecond = 0;
        this._pauseStarted = 0;
        this.physicsElapsed = 0;
        this.time = 0;
        this.pausedTime = 0;
        this.now = 0;
        this.elapsed = 0;
        this.fps = 0;
        this.fpsMin = 1000;
        this.fpsMax = 0;
        this.msMin = 1000;
        this.msMax = 0;
        this.frames = 0;
        this.pauseDuration = 0;
        this.timeToCall = 0;
        this.lastTime = 0;
        this.game.onPause.add(this.gamePaused, this);
        this.game.onResume.add(this.gameResumed, this);
        this._justResumed = false
    };
    d.Time.prototype = {
        totalElapsedSeconds: function () {
            return (this.now - this._started) * 0.001
        }, update: function (b) {
            this.now = b;
            if (this._justResumed) {
                this.time = this.now;
                this._justResumed = false
            }
            this.timeToCall = this.game.math.max(0, 16 - (b - this.lastTime));
            this.elapsed = this.now - this.time;
            this.msMin = this.game.math.min(this.msMin, this.elapsed);
            this.msMax = this.game.math.max(this.msMax, this.elapsed);
            this.frames++;
            if (this.now > this._timeLastSecond + 1000) {
                this.fps = Math.round((this.frames * 1000) / (this.now - this._timeLastSecond));
                this.fpsMin = this.game.math.min(this.fpsMin, this.fps);
                this.fpsMax = this.game.math.max(this.fpsMax, this.fps);
                this._timeLastSecond = this.now;
                this.frames = 0
            }
            this.time = this.now;
            this.lastTime = b + this.timeToCall;
            this.physicsElapsed = 1 * (this.elapsed / 1000);
            if (this.physicsElapsed > 1) {
                this.physicsElapsed = 1
            }
            if (this.game.paused) {
                this.pausedTime = this.now - this._pauseStarted
            }
        }, gamePaused: function () {
            this._pauseStarted = this.now
        }, gameResumed: function () {
            this.time = Date.now();
            this.pauseDuration = this.pausedTime;
            this._justResumed = true
        }, elapsedSince: function (b) {
            return this.now - b
        }, elapsedSecondsSince: function (b) {
            return (this.now - b) * 0.001
        }, reset: function () {
            this._started = this.now
        }
    };
    d.AnimationManager = function (b) {
        this.sprite = b;
        this.game = b.game;
        this.currentFrame = null;
        this.updateIfVisible = true;
        this.isLoaded = false;
        this._frameData = null;
        this._anims = {};
        this._outputFrames = []
    };
    d.AnimationManager.prototype = {
        loadFrameData: function (b) {
            this._frameData = b;
            this.frame = 0;
            this.isLoaded = true
        }, add: function (j, k, i, h, b) {
            if (this._frameData == null) {
                console.warn("No FrameData available for Phaser.Animation " + j);
                return
            }
            i = i || 60;
            if (typeof h === "undefined") {
                h = false
            }
            if (typeof b === "undefined") {
                if (k && typeof k[0] === "number") {
                    b = true
                } else {
                    b = false
                }
            }
            if (this.sprite.events.onAnimationStart == null) {
                this.sprite.events.onAnimationStart = new d.Signal();
                this.sprite.events.onAnimationComplete = new d.Signal();
                this.sprite.events.onAnimationLoop = new d.Signal()
            }
            this._outputFrames.length = 0;
            this._frameData.getFrameIndexes(k, b, this._outputFrames);
            this._anims[j] = new d.Animation(this.game, this.sprite, j, this._frameData, this._outputFrames, i, h);
            this.currentAnim = this._anims[j];
            this.currentFrame = this.currentAnim.currentFrame;
            this.sprite.setTexture(g.TextureCache[this.currentFrame.uuid]);
            return this._anims[j]
        }, validateFrames: function (j, b) {
            if (typeof b == "undefined") {
                b = true
            }
            for (var h = 0; h < j.length; h++) {
                if (b == true) {
                    if (j[h] > this._frameData.total) {
                        return false
                    }
                } else {
                    if (this._frameData.checkFrameName(j[h]) == false) {
                        return false
                    }
                }
            }
            return true
        }, play: function (j, i, h, b) {
            if (this._anims[j]) {
                if (this.currentAnim == this._anims[j]) {
                    if (this.currentAnim.isPlaying == false) {
                        this.currentAnim.paused = false;
                        return this.currentAnim.play(i, h, b)
                    }
                } else {
                    this.currentAnim = this._anims[j];
                    this.currentAnim.paused = false;
                    return this.currentAnim.play(i, h, b)
                }
            }
        }, stop: function (h, b) {
            if (typeof b == "undefined") {
                b = false
            }
            if (typeof h == "string") {
                if (this._anims[h]) {
                    this.currentAnim = this._anims[h];
                    this.currentAnim.stop(b)
                }
            } else {
                if (this.currentAnim) {
                    this.currentAnim.stop(b)
                }
            }
        }, update: function () {
            if (this.updateIfVisible && this.sprite.visible == false) {
                return false
            }
            if (this.currentAnim && this.currentAnim.update() == true) {
                this.currentFrame = this.currentAnim.currentFrame;
                this.sprite.currentFrame = this.currentFrame;
                return true
            }
            return false
        }, refreshFrame: function () {
            this.sprite.currentFrame = this.currentFrame;
            this.sprite.setTexture(g.TextureCache[this.currentFrame.uuid])
        }, destroy: function () {
            this._anims = {};
            this._frameData = null;
            this._frameIndex = 0;
            this.currentAnim = null;
            this.currentFrame = null
        }
    };
    Object.defineProperty(d.AnimationManager.prototype, "frameData", {
        get: function () {
            return this._frameData
        }
    });
    Object.defineProperty(d.AnimationManager.prototype, "frameTotal", {
        get: function () {
            if (this._frameData) {
                return this._frameData.total
            } else {
                return -1
            }
        }
    });
    Object.defineProperty(d.AnimationManager.prototype, "paused", {
        get: function () {
            return this.currentAnim.isPaused
        }, set: function (b) {
            this.currentAnim.paused = b
        }
    });
    Object.defineProperty(d.AnimationManager.prototype, "frame", {
        get: function () {
            if (this.currentFrame) {
                return this._frameIndex
            }
        }, set: function (b) {
            if (typeof b === "number" && this._frameData && this._frameData.getFrame(b) !== null) {
                this.currentFrame = this._frameData.getFrame(b);
                this._frameIndex = b;
                this.sprite.currentFrame = this.currentFrame;
                this.sprite.setTexture(g.TextureCache[this.currentFrame.uuid])
            }
        }
    });
    Object.defineProperty(d.AnimationManager.prototype, "frameName", {
        get: function () {
            if (this.currentFrame) {
                return this.currentFrame.name
            }
        }, set: function (b) {
            if (typeof b === "string" && this._frameData && this._frameData.getFrameByName(b) !== null) {
                this.currentFrame = this._frameData.getFrameByName(b);
                this._frameIndex = this.currentFrame.index;
                this.sprite.currentFrame = this.currentFrame;
                this.sprite.setTexture(g.TextureCache[this.currentFrame.uuid])
            } else {
                console.warn("Cannot set frameName: " + b)
            }
        }
    });
    d.Animation = function (h, l, j, k, m, i, b) {
        this.game = h;
        this._parent = l;
        this._frameData = k;
        this.name = j;
        this._frames = [];
        this._frames = this._frames.concat(m);
        this.delay = 1000 / i;
        this.looped = b;
        this.killOnComplete = false;
        this.isFinished = false;
        this.isPlaying = false;
        this.isPaused = false;
        this._pauseStartTime = 0;
        this._frameIndex = 0;
        this._frameDiff = 0;
        this._frameSkip = 1;
        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])
    };
    d.Animation.prototype = {
        play: function (i, h, b) {
            if (typeof i === "number") {
                this.delay = 1000 / i
            }
            if (typeof h === "boolean") {
                this.looped = h
            }
            if (typeof b !== "undefined") {
                this.killOnComplete = b
            }
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
            this._parent.setTexture(g.TextureCache[this.currentFrame.uuid]);
            if (this._parent.events) {
                this._parent.events.onAnimationStart.dispatch(this._parent, this)
            }
            return this
        }, restart: function () {
            this.isPlaying = true;
            this.isFinished = false;
            this.paused = false;
            this._timeLastFrame = this.game.time.now;
            this._timeNextFrame = this.game.time.now + this.delay;
            this._frameIndex = 0;
            this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex])
        }, stop: function (b) {
            if (typeof b === "undefined") {
                b = false
            }
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            if (b) {
                this.currentFrame = this._frameData.getFrame(this._frames[0])
            }
        }, update: function () {
            if (this.isPaused) {
                return false
            }
            if (this.isPlaying == true && this.game.time.now >= this._timeNextFrame) {
                this._frameSkip = 1;
                this._frameDiff = this.game.time.now - this._timeNextFrame;
                this._timeLastFrame = this.game.time.now;
                if (this._frameDiff > this.delay) {
                    this._frameSkip = Math.floor(this._frameDiff / this.delay);
                    this._frameDiff -= (this._frameSkip * this.delay)
                }
                this._timeNextFrame = this.game.time.now + (this.delay - this._frameDiff);
                this._frameIndex += this._frameSkip;
                if (this._frameIndex >= this._frames.length) {
                    if (this.looped) {
                        this._frameIndex %= this._frames.length;
                        this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                        if (this.currentFrame) {
                            this._parent.setTexture(g.TextureCache[this.currentFrame.uuid])
                        }
                        this._parent.events.onAnimationLoop.dispatch(this._parent, this)
                    } else {
                        this.onComplete()
                    }
                } else {
                    this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]);
                    this._parent.setTexture(g.TextureCache[this.currentFrame.uuid])
                }
                return true
            }
            return false
        }, destroy: function () {
            this.game = null;
            this._parent = null;
            this._frames = null;
            this._frameData = null;
            this.currentFrame = null;
            this.isPlaying = false
        }, onComplete: function () {
            this.isPlaying = false;
            this.isFinished = true;
            this.paused = false;
            if (this._parent.events) {
                this._parent.events.onAnimationComplete.dispatch(this._parent, this)
            }
            if (this.killOnComplete) {
                this._parent.kill()
            }
        }
    };
    Object.defineProperty(d.Animation.prototype, "paused", {
        get: function () {
            return this.isPaused
        }, set: function (b) {
            this.isPaused = b;
            if (b) {
                this._pauseStartTime = this.game.time.now
            } else {
                if (this.isPlaying) {
                    this._timeNextFrame = this.game.time.now + this.delay
                }
            }
        }
    });
    Object.defineProperty(d.Animation.prototype, "frameTotal", {
        get: function () {
            return this._frames.length
        }
    });
    Object.defineProperty(d.Animation.prototype, "frame", {
        get: function () {
            if (this.currentFrame !== null) {
                return this.currentFrame.index
            } else {
                return this._frameIndex
            }
        }, set: function (b) {
            this.currentFrame = this._frameData.getFrame(b);
            if (this.currentFrame !== null) {
                this._frameIndex = b;
                this._parent.setTexture(g.TextureCache[this.currentFrame.uuid])
            }
        }
    });
    d.Animation.generateFrameNames = function (l, o, j, m, k) {
        if (typeof m == "undefined") {
            m = ""
        }
        var b = [];
        var n = "";
        if (o < j) {
            for (var h = o; h <= j; h++) {
                if (typeof k == "number") {
                    n = d.Utils.pad(h.toString(), k, "0", 1)
                } else {
                    n = h.toString()
                }
                n = l + n + m;
                b.push(n)
            }
        } else {
            for (var h = o; h >= j; h--) {
                if (typeof k == "number") {
                    n = d.Utils.pad(h.toString(), k, "0", 1)
                } else {
                    n = h.toString()
                }
                n = l + n + m;
                b.push(n)
            }
        }
        return b
    };
    d.Frame = function (j, h, m, l, b, i, k) {
        this.index = j;
        this.x = h;
        this.y = m;
        this.width = l;
        this.height = b;
        this.name = i;
        this.uuid = k;
        this.centerX = Math.floor(l / 2);
        this.centerY = Math.floor(b / 2);
        this.distance = d.Math.distance(0, 0, l, b);
        this.rotated = false;
        this.rotationDirection = "cw";
        this.trimmed = false;
        this.sourceSizeW = l;
        this.sourceSizeH = b;
        this.spriteSourceSizeX = 0;
        this.spriteSourceSizeY = 0;
        this.spriteSourceSizeW = 0;
        this.spriteSourceSizeH = 0
    };
    d.Frame.prototype = {
        setTrim: function (k, j, m, h, b, i, l) {
            this.trimmed = k;
            if (k) {
                this.width = j;
                this.height = m;
                this.sourceSizeW = j;
                this.sourceSizeH = m;
                this.centerX = Math.floor(j / 2);
                this.centerY = Math.floor(m / 2);
                this.spriteSourceSizeX = h;
                this.spriteSourceSizeY = b;
                this.spriteSourceSizeW = i;
                this.spriteSourceSizeH = l
            }
        }
    };
    d.FrameData = function () {
        this._frames = [];
        this._frameNames = []
    };
    d.FrameData.prototype = {
        addFrame: function (b) {
            b.index = this._frames.length;
            this._frames.push(b);
            if (b.name !== "") {
                this._frameNames[b.name] = b.index
            }
            return b
        }, getFrame: function (b) {
            if (this._frames.length > b) {
                return this._frames[b]
            }
            return null
        }, getFrameByName: function (b) {
            if (typeof this._frameNames[b] === "number") {
                return this._frames[this._frameNames[b]]
            }
            return null
        }, checkFrameName: function (b) {
            if (this._frameNames[b] == null) {
                return false
            }
            return true
        }, getFrameRange: function (k, b, h) {
            if (typeof h === "undefined") {
                h = []
            }
            for (var j = k; j <= b; j++) {
                h.push(this._frames[j])
            }
            return h
        }, getFrames: function (l, h, j) {
            if (typeof h === "undefined") {
                h = true
            }
            if (typeof j === "undefined") {
                j = []
            }
            if (typeof l === "undefined" || l.length == 0) {
                for (var k = 0; k < this._frames.length; k++) {
                    j.push(this._frames[k])
                }
            } else {
                for (var k = 0, b = l.length; k < b; k++) {
                    if (h) {
                        j.push(this.getFrame(l[k]))
                    } else {
                        j.push(this.getFrameByName(l[k]))
                    }
                }
            }
            return j
        }, getFrameIndexes: function (l, h, j) {
            if (typeof h === "undefined") {
                h = true
            }
            if (typeof j === "undefined") {
                j = []
            }
            if (typeof l === "undefined" || l.length == 0) {
                for (var k = 0, b = this._frames.length; k < b; k++) {
                    j.push(this._frames[k].index)
                }
            } else {
                for (var k = 0, b = l.length; k < b; k++) {
                    if (h) {
                        j.push(l[k])
                    } else {
                        if (this.getFrameByName(l[k])) {
                            j.push(this.getFrameByName(l[k]).index)
                        }
                    }
                }
            }
            return j
        }
    };
    Object.defineProperty(d.FrameData.prototype, "total", {
        get: function () {
            return this._frames.length
        }
    });
    d.AnimationParser = {
        spriteSheet: function (u, t, r, l, k) {
            var o = u.cache.getImage(t);
            if (o == null) {
                return null
            }
            var h = o.width;
            var v = o.height;
            if (r <= 0) {
                r = Math.floor(-h / Math.min(-1, r))
            }
            if (l <= 0) {
                l = Math.floor(-v / Math.min(-1, l))
            }
            var w = Math.round(h / r);
            var j = Math.round(v / l);
            var q = w * j;
            if (k !== -1) {
                q = k
            }
            if (h == 0 || v == 0 || h < r || v < l || q === 0) {
                console.warn("Phaser.AnimationParser.spriteSheet: width/height zero or width/height < given frameWidth/frameHeight");
                return null
            }
            var n = new d.FrameData();
            var s = 0;
            var p = 0;
            for (var m = 0; m < q; m++) {
                var b = u.rnd.uuid();
                n.addFrame(new d.Frame(m, s, p, r, l, "", b));
                g.TextureCache[b] = new g.Texture(g.BaseTextureCache[t], {x: s, y: p, width: r, height: l});
                s += r;
                if (s === h) {
                    s = 0;
                    p += l
                }
            }
            return n
        }, JSONData: function (b, j, n) {
            if (!j.frames) {
                console.warn("Phaser.AnimationParser.JSONData: Invalid Texture Atlas JSON given, missing 'frames' array");
                console.log(j);
                return
            }
            var l = new d.FrameData();
            var m = j.frames;
            var o;
            for (var h = 0; h < m.length; h++) {
                var k = b.rnd.uuid();
                o = l.addFrame(new d.Frame(h, m[h].frame.x, m[h].frame.y, m[h].frame.w, m[h].frame.h, m[h].filename, k));
                g.TextureCache[k] = new g.Texture(g.BaseTextureCache[n], {
                    x: m[h].frame.x,
                    y: m[h].frame.y,
                    width: m[h].frame.w,
                    height: m[h].frame.h
                });
                if (m[h].trimmed) {
                    o.setTrim(m[h].trimmed, m[h].sourceSize.w, m[h].sourceSize.h, m[h].spriteSourceSize.x, m[h].spriteSourceSize.y, m[h].spriteSourceSize.w, m[h].spriteSourceSize.h);
                    g.TextureCache[k].trimmed = true;
                    g.TextureCache[k].trim.x = m[h].spriteSourceSize.x;
                    g.TextureCache[k].trim.y = m[h].spriteSourceSize.y
                }
            }
            return l
        }, JSONDataHash: function (o, p, l) {
            if (!p.frames) {
                console.warn("Phaser.AnimationParser.JSONDataHash: Invalid Texture Atlas JSON given, missing 'frames' object");
                console.log(p);
                return
            }
            var h = new d.FrameData();
            var m = p.frames;
            var k;
            var j = 0;
            for (var n in m) {
                var b = o.rnd.uuid();
                k = h.addFrame(new d.Frame(j, m[n].frame.x, m[n].frame.y, m[n].frame.w, m[n].frame.h, n, b));
                g.TextureCache[b] = new g.Texture(g.BaseTextureCache[l], {
                    x: m[n].frame.x,
                    y: m[n].frame.y,
                    width: m[n].frame.w,
                    height: m[n].frame.h
                });
                if (m[n].trimmed) {
                    k.setTrim(m[n].trimmed, m[n].sourceSize.w, m[n].sourceSize.h, m[n].spriteSourceSize.x, m[n].spriteSourceSize.y, m[n].spriteSourceSize.w, m[n].spriteSourceSize.h);
                    g.TextureCache[b].trimmed = true;
                    g.TextureCache[b].trim.x = m[n].spriteSourceSize.x;
                    g.TextureCache[b].trim.y = m[n].spriteSourceSize.y
                }
                j++
            }
            return h
        }, XMLData: function (z, o, p) {
            if (!o.getElementsByTagName("TextureAtlas")) {
                console.warn("Phaser.AnimationParser.XMLData: Invalid Texture Atlas XML given, missing <TextureAtlas> tag");
                return
            }
            var m = new d.FrameData();
            var q = o.getElementsByTagName("SubTexture");
            var n;
            var b;
            var j;
            var u;
            var s;
            var h;
            var w;
            var v;
            var t;
            var r;
            var k;
            for (var l = 0; l < q.length; l++) {
                b = z.rnd.uuid();
                j = q[l].attributes;
                name = j.name.nodeValue;
                u = parseInt(j.x.nodeValue);
                s = parseInt(j.y.nodeValue);
                h = parseInt(j.width.nodeValue);
                w = parseInt(j.height.nodeValue);
                v = null;
                t = null;
                if (j.frameX) {
                    v = Math.abs(parseInt(j.frameX.nodeValue));
                    t = Math.abs(parseInt(j.frameY.nodeValue));
                    r = parseInt(j.frameWidth.nodeValue);
                    k = parseInt(j.frameHeight.nodeValue)
                }
                n = m.addFrame(new d.Frame(l, u, s, h, w, name, b));
                g.TextureCache[b] = new g.Texture(g.BaseTextureCache[p], {x: u, y: s, width: h, height: w});
                if (v !== null || t !== null) {
                    n.setTrim(true, h, w, v, t, r, k);
                    g.TextureCache[b].realSize = {x: v, y: t, w: r, h: k};
                    g.TextureCache[b].trimmed = true;
                    g.TextureCache[b].trim.x = v;
                    g.TextureCache[b].trim.y = t
                }
            }
            return m
        }
    };
    d.Cache = function (b) {
        this.game = b;
        this._canvases = {};
        this._images = {};
        this._textures = {};
        this._sounds = {};
        this._text = {};
        this._tilemaps = {};
        this._tilesets = {};
        this.addDefaultImage();
        this.onSoundUnlock = new d.Signal
    };
    d.Cache.prototype = {
        addCanvas: function (i, b, h) {
            this._canvases[i] = {canvas: b, context: h}
        }, addRenderTexture: function (b, h) {
            var i = new d.Frame(0, 0, 0, h.width, h.height, "", "");
            this._textures[b] = {texture: h, frame: i}
        }, addSpriteSheet: function (j, i, k, b, h, l) {
            this._images[j] = {url: i, data: k, spriteSheet: true, frameWidth: b, frameHeight: h};
            g.BaseTextureCache[j] = new g.BaseTexture(k);
            g.TextureCache[j] = new g.Texture(g.BaseTextureCache[j]);
            this._images[j].frameData = d.AnimationParser.spriteSheet(this.game, j, b, h, l)
        }, addTileset: function (j, h, l, n, b, k, m, i) {
            this._tilesets[j] = {url: h, data: l, tileWidth: n, tileHeight: b, tileMargin: m, tileSpacing: i};
            g.BaseTextureCache[j] = new g.BaseTexture(l);
            g.TextureCache[j] = new g.Texture(g.BaseTextureCache[j]);
            this._tilesets[j].tileData = d.TilemapParser.tileset(this.game, j, n, b, k, m, i)
        }, addTilemap: function (h, b, j, i) {
            this._tilemaps[h] = {url: b, data: j, format: i};
            this._tilemaps[h].layers = d.TilemapParser.parse(this.game, j, i)
        }, addTextureAtlas: function (i, h, j, b, k) {
            this._images[i] = {url: h, data: j, spriteSheet: true};
            g.BaseTextureCache[i] = new g.BaseTexture(j);
            g.TextureCache[i] = new g.Texture(g.BaseTextureCache[i]);
            if (k == d.Loader.TEXTURE_ATLAS_JSON_ARRAY) {
                this._images[i].frameData = d.AnimationParser.JSONData(this.game, b, i)
            } else {
                if (k == d.Loader.TEXTURE_ATLAS_JSON_HASH) {
                    this._images[i].frameData = d.AnimationParser.JSONDataHash(this.game, b, i)
                } else {
                    if (k == d.Loader.TEXTURE_ATLAS_XML_STARLING) {
                        this._images[i].frameData = d.AnimationParser.XMLData(this.game, b, i)
                    }
                }
            }
        }, addBitmapFont: function (h, b, j, i) {
            this._images[h] = {url: b, data: j, spriteSheet: true};
            g.BaseTextureCache[h] = new g.BaseTexture(j);
            g.TextureCache[h] = new g.Texture(g.BaseTextureCache[h]);
            d.LoaderParser.bitmapFont(this.game, i, h)
        }, addDefaultImage: function () {
            var b = new Image();
            b.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
            this._images.__default = {url: null, data: b, spriteSheet: false};
            this._images.__default.frame = new d.Frame(0, 0, 0, 32, 32, "", "");
            g.BaseTextureCache.__default = new g.BaseTexture(b);
            g.TextureCache.__default = new g.Texture(g.BaseTextureCache.__default)
        }, addText: function (h, b, i) {
            this._text[h] = {url: b, data: i}
        }, addImage: function (h, b, i) {
            this._images[h] = {url: b, data: i, spriteSheet: false};
            this._images[h].frame = new d.Frame(0, 0, 0, i.width, i.height, h, this.game.rnd.uuid());
            g.BaseTextureCache[h] = new g.BaseTexture(i);
            g.TextureCache[h] = new g.Texture(g.BaseTextureCache[h])
        }, addSound: function (k, j, m, i, l) {
            i = i || true;
            l = l || false;
            var h = this.game.sound.touchLocked;
            var b = false;
            if (l) {
                b = true
            }
            this._sounds[k] = {url: j, data: m, isDecoding: false, decoded: b, webAudio: i, audioTag: l}
        }, reloadSound: function (b) {
            var h = this;
            if (this._sounds[b]) {
                this._sounds[b].data.src = this._sounds[b].url;
                this._sounds[b].data.addEventListener("canplaythrough", function () {
                    return h.reloadSoundComplete(b)
                }, false);
                this._sounds[b].data.load()
            }
        }, reloadSoundComplete: function (b) {
            if (this._sounds[b]) {
                this._sounds[b].locked = false;
                this.onSoundUnlock.dispatch(b)
            }
        }, updateSound: function (b, i, h) {
            if (this._sounds[b]) {
                this._sounds[b][i] = h
            }
        }, decodedSound: function (b, h) {
            this._sounds[b].data = h;
            this._sounds[b].decoded = true;
            this._sounds[b].isDecoding = false
        }, getCanvas: function (b) {
            if (this._canvases[b]) {
                return this._canvases[b].canvas
            }
            return null
        }, checkImageKey: function (b) {
            if (this._images[b]) {
                return true
            }
            return false
        }, getImage: function (b) {
            if (this._images[b]) {
                return this._images[b].data
            }
            return null
        }, getTilesetImage: function (b) {
            if (this._tilesets[b]) {
                return this._tilesets[b].data
            }
            return null
        }, getTileset: function (b) {
            if (this._tilesets[b]) {
                return this._tilesets[b].tileData
            }
            return null
        }, getTilemapData: function (b) {
            if (this._tilemaps[b]) {
                return this._tilemaps[b]
            }
            return null
        }, getFrameData: function (b) {
            if (this._images[b] && this._images[b].frameData) {
                return this._images[b].frameData
            }
            return null
        }, getFrameByIndex: function (b, h) {
            if (this._images[b] && this._images[b].frameData) {
                return this._images[b].frameData.getFrame(h)
            }
            return null
        }, getFrameByName: function (b, h) {
            if (this._images[b] && this._images[b].frameData) {
                return this._images[b].frameData.getFrameByName(h)
            }
            return null
        }, getFrame: function (b) {
            if (this._images[b] && this._images[b].spriteSheet == false) {
                return this._images[b].frame
            }
            return null
        }, getTextureFrame: function (b) {
            if (this._textures[b]) {
                return this._textures[b].frame
            }
            return null
        }, getTexture: function (b) {
            if (this._textures[b]) {
                return this._textures[b]
            }
            return null
        }, getSound: function (b) {
            if (this._sounds[b]) {
                return this._sounds[b]
            }
            return null
        }, getSoundData: function (b) {
            if (this._sounds[b]) {
                return this._sounds[b].data
            }
            return null
        }, isSoundDecoded: function (b) {
            if (this._sounds[b]) {
                return this._sounds[b].decoded
            }
        }, isSoundReady: function (b) {
            return (this._sounds[b] && this._sounds[b].decoded && this.game.sound.touchLocked == false)
        }, isSpriteSheet: function (b) {
            if (this._images[b]) {
                return this._images[b].spriteSheet
            }
            return false
        }, getText: function (b) {
            if (this._text[b]) {
                return this._text[b].data
            }
            return null
        }, getKeys: function (i) {
            var b = [];
            for (var h in i) {
                if (h !== "__default") {
                    b.push(h)
                }
            }
            return b
        }, getImageKeys: function () {
            return this.getKeys(this._images)
        }, getSoundKeys: function () {
            return this.getKeys(this._sounds)
        }, getTextKeys: function () {
            return this.getKeys(this._text)
        }, removeCanvas: function (b) {
            delete this._canvases[b]
        }, removeImage: function (b) {
            delete this._images[b]
        }, removeSound: function (b) {
            delete this._sounds[b]
        }, removeText: function (b) {
            delete this._text[b]
        }, destroy: function () {
            for (var b in this._canvases) {
                delete this._canvases[b.key]
            }
            for (var b in this._images) {
                delete this._images[b.key]
            }
            for (var b in this._sounds) {
                delete this._sounds[b.key]
            }
            for (var b in this._text) {
                delete this._text[b.key]
            }
        }
    };
    d.Loader = function (b) {
        this.game = b;
        this._keys = [];
        this._fileList = {};
        this._progressChunk = 0;
        this._xhr = new XMLHttpRequest();
        this.queueSize = 0;
        this.isLoading = false;
        this.hasLoaded = false;
        this.progress = 0;
        this.preloadSprite = null;
        this.crossOrigin = "";
        this.baseURL = "";
        this.onFileComplete = new d.Signal;
        this.onFileError = new d.Signal;
        this.onLoadStart = new d.Signal;
        this.onLoadComplete = new d.Signal
    };
    d.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0;
    d.Loader.TEXTURE_ATLAS_JSON_HASH = 1;
    d.Loader.TEXTURE_ATLAS_XML_STARLING = 2;
    d.Loader.prototype = {
        setPreloadSprite: function (b, h) {
            h = h || 0;
            this.preloadSprite = {sprite: b, direction: h, width: b.width, height: b.height, crop: null};
            if (h == 0) {
                this.preloadSprite.crop = new d.Rectangle(0, 0, 1, b.height)
            } else {
                this.preloadSprite.crop = new d.Rectangle(0, 0, b.width, 1)
            }
            b.crop = this.preloadSprite.crop;
            b.cropEnabled = true
        }, checkKeyExists: function (b) {
            if (this._fileList[b]) {
                return true
            } else {
                return false
            }
        }, reset: function () {
            this.preloadSprite = null;
            this.queueSize = 0;
            this.isLoading = false
        }, addToFileList: function (j, i, b, h) {
            var k = {type: j, key: i, url: b, data: null, error: false, loaded: false};
            if (typeof h !== "undefined") {
                for (var l in h) {
                    k[l] = h[l]
                }
            }
            this._fileList[i] = k;
            this._keys.push(i);
            this.queueSize++
        }, image: function (i, h, b) {
            if (typeof b === "undefined") {
                b = false
            }
            if (b || this.checkKeyExists(i) == false) {
                this.addToFileList("image", i, h)
            }
            return this
        }, text: function (i, h, b) {
            if (typeof b === "undefined") {
                b = false
            }
            if (b || this.checkKeyExists(i) == false) {
                this.addToFileList("text", i, h)
            }
            return this
        }, spritesheet: function (j, i, b, h, k) {
            if (typeof k === "undefined") {
                k = -1
            }
            if (this.checkKeyExists(j) === false) {
                this.addToFileList("spritesheet", j, i, {frameWidth: b, frameHeight: h, frameMax: k})
            }
            return this
        }, tileset: function (j, h, m, b, k, l, i) {
            if (typeof k === "undefined") {
                k = -1
            }
            if (typeof l === "undefined") {
                l = 0
            }
            if (typeof i === "undefined") {
                i = 0
            }
            if (this.checkKeyExists(j) === false) {
                this.addToFileList("tileset", j, h, {
                    tileWidth: m,
                    tileHeight: b,
                    tileMax: k,
                    tileMargin: l,
                    tileSpacing: i
                })
            }
            return this
        }, audio: function (h, i, b) {
            if (typeof b === "undefined") {
                b = true
            }
            if (this.checkKeyExists(h) === false) {
                this.addToFileList("audio", h, i, {buffer: null, autoDecode: b})
            }
            return this
        }, tilemap: function (b, j, i, h) {
            if (typeof j === "undefined") {
                j = null
            }
            if (typeof i === "undefined") {
                i = null
            }
            if (typeof h === "undefined") {
                h = d.Tilemap.CSV
            }
            if (j == null && i == null) {
                console.warn("Phaser.Loader.tilemap - Both mapDataURL and mapData are null. One must be set.");
                return this
            }
            if (this.checkKeyExists(b) === false) {
                if (j) {
                    this.addToFileList("tilemap", b, j, {format: h})
                } else {
                    switch (h) {
                        case d.Tilemap.CSV:
                            break;
                        case d.Tilemap.TILED_JSON:
                            if (typeof i === "string") {
                                i = JSON.parse(i)
                            }
                            break
                    }
                    this.game.cache.addTilemap(b, null, i, h)
                }
            }
            return this
        }, bitmapFont: function (j, i, h, k) {
            if (typeof h === "undefined") {
                h = null
            }
            if (typeof k === "undefined") {
                k = null
            }
            if (this.checkKeyExists(j) === false) {
                if (h) {
                    this.addToFileList("bitmapfont", j, i, {xmlURL: h})
                } else {
                    if (typeof k === "string") {
                        var b;
                        try {
                            if (window.DOMParser) {
                                var m = new DOMParser();
                                b = m.parseFromString(k, "text/xml")
                            } else {
                                b = new ActiveXObject("Microsoft.XMLDOM");
                                b.async = "false";
                                b.loadXML(k)
                            }
                        } catch (l) {
                            b = undefined
                        }
                        if (!b || !b.documentElement || b.getElementsByTagName("parsererror").length) {
                            throw new Error("Phaser.Loader. Invalid Bitmap Font XML given")
                        } else {
                            this.addToFileList("bitmapfont", j, i, {xmlURL: null, xmlData: b})
                        }
                    }
                }
            }
            return this
        }, atlasJSONArray: function (i, h, j, b) {
            return this.atlas(i, h, j, b, d.Loader.TEXTURE_ATLAS_JSON_ARRAY)
        }, atlasJSONHash: function (i, h, j, b) {
            return this.atlas(i, h, j, b, d.Loader.TEXTURE_ATLAS_JSON_HASH)
        }, atlasXML: function (i, h, j, b) {
            return this.atlas(i, h, j, b, d.Loader.TEXTURE_ATLAS_XML_STARLING)
        }, atlas: function (j, i, k, b, m) {
            if (typeof k === "undefined") {
                k = null
            }
            if (typeof b === "undefined") {
                b = null
            }
            if (typeof m === "undefined") {
                m = d.Loader.TEXTURE_ATLAS_JSON_ARRAY
            }
            if (this.checkKeyExists(j) === false) {
                if (k) {
                    this.addToFileList("textureatlas", j, i, {atlasURL: k, format: m})
                } else {
                    switch (m) {
                        case d.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            if (typeof b === "string") {
                                b = JSON.parse(b)
                            }
                            break;
                        case d.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if (typeof b === "string") {
                                var h;
                                try {
                                    if (window.DOMParser) {
                                        var n = new DOMParser();
                                        h = n.parseFromString(b, "text/xml")
                                    } else {
                                        h = new ActiveXObject("Microsoft.XMLDOM");
                                        h.async = "false";
                                        h.loadXML(b)
                                    }
                                } catch (l) {
                                    h = undefined
                                }
                                if (!h || !h.documentElement || h.getElementsByTagName("parsererror").length) {
                                    throw new Error("Phaser.Loader. Invalid Texture Atlas XML given")
                                } else {
                                    b = h
                                }
                            }
                            break
                    }
                    this.addToFileList("textureatlas", j, i, {atlasURL: null, atlasData: b, format: m})
                }
            }
            return this
        }, removeFile: function (b) {
            delete this._fileList[b]
        }, removeAll: function () {
            this._fileList = {}
        }, start: function () {
            if (this.isLoading) {
                return
            }
            this.progress = 0;
            this.hasLoaded = false;
            this.isLoading = true;
            this.onLoadStart.dispatch(this.queueSize);
            if (this._keys.length > 0) {
                this._progressChunk = 100 / this._keys.length;
                this.loadFile()
            } else {
                this.progress = 100;
                this.hasLoaded = true;
                this.onLoadComplete.dispatch()
            }
        }, loadFile: function () {
            var b = this._fileList[this._keys.shift()];
            var h = this;
            switch (b.type) {
                case"image":
                case"spritesheet":
                case"textureatlas":
                case"bitmapfont":
                case"tileset":
                    b.data = new Image();
                    b.data.name = b.key;
                    b.data.onload = function () {
                        return h.fileComplete(b.key)
                    };
                    b.data.onerror = function () {
                        return h.fileError(b.key)
                    };
                    b.data.crossOrigin = this.crossOrigin;
                    b.data.src = this.baseURL + b.url;
                    break;
                case"audio":
                    b.url = this.getAudioURL(b.url);
                    if (b.url !== null) {
                        if (this.game.sound.usingWebAudio) {
                            this._xhr.open("GET", this.baseURL + b.url, true);
                            this._xhr.responseType = "arraybuffer";
                            this._xhr.onload = function () {
                                return h.fileComplete(b.key)
                            };
                            this._xhr.onerror = function () {
                                return h.fileError(b.key)
                            };
                            this._xhr.send()
                        } else {
                            if (this.game.sound.usingAudioTag) {
                                if (this.game.sound.touchLocked) {
                                    b.data = new Audio();
                                    b.data.name = b.key;
                                    b.data.preload = "auto";
                                    b.data.src = this.baseURL + b.url;
                                    this.fileComplete(b.key)
                                } else {
                                    b.data = new Audio();
                                    b.data.name = b.key;
                                    b.data.onerror = function () {
                                        return h.fileError(b.key)
                                    };
                                    b.data.preload = "auto";
                                    b.data.src = this.baseURL + b.url;
                                    b.data.addEventListener("canplaythrough", d.GAMES[this.game.id].load.fileComplete(b.key), false);
                                    b.data.load()
                                }
                            }
                        }
                    } else {
                        this.fileError(b.key)
                    }
                    break;
                case"tilemap":
                    this._xhr.open("GET", this.baseURL + b.url, true);
                    this._xhr.responseType = "text";
                    if (b.format == d.Tilemap.TILED_JSON) {
                        this._xhr.onload = function () {
                            return h.jsonLoadComplete(b.key)
                        }
                    } else {
                        if (b.format == d.Tilemap.CSV) {
                            this._xhr.onload = function () {
                                return h.csvLoadComplete(b.key)
                            }
                        }
                    }
                    this._xhr.onerror = function () {
                        return h.dataLoadError(b.key)
                    };
                    this._xhr.send();
                    break;
                case"text":
                    this._xhr.open("GET", this.baseURL + b.url, true);
                    this._xhr.responseType = "text";
                    this._xhr.onload = function () {
                        return h.fileComplete(b.key)
                    };
                    this._xhr.onerror = function () {
                        return h.fileError(b.key)
                    };
                    this._xhr.send();
                    break
            }
        }, getAudioURL: function (h) {
            var j;
            for (var b = 0; b < h.length; b++) {
                j = h[b].toLowerCase();
                j = j.substr((Math.max(0, j.lastIndexOf(".")) || Infinity) + 1);
                if (this.game.device.canPlayAudio(j)) {
                    return h[b]
                }
            }
            return null
        }, fileError: function (b) {
            this._fileList[b].loaded = true;
            this._fileList[b].error = true;
            this.onFileError.dispatch(b);
            console.warn("Phaser.Loader error loading file: " + b + " from URL " + this._fileList[b].url);
            this.nextFile(b, false)
        }, fileComplete: function (h) {
            if (!this._fileList[h]) {
                console.warn("Phaser.Loader fileComplete invalid key " + h);
                return
            }
            this._fileList[h].loaded = true;
            var b = this._fileList[h];
            var j = true;
            var k = this;
            switch (b.type) {
                case"image":
                    this.game.cache.addImage(b.key, b.url, b.data);
                    break;
                case"spritesheet":
                    this.game.cache.addSpriteSheet(b.key, b.url, b.data, b.frameWidth, b.frameHeight, b.frameMax);
                    break;
                case"tileset":
                    this.game.cache.addTileset(b.key, b.url, b.data, b.tileWidth, b.tileHeight, b.tileMax, b.tileMargin, b.tileSpacing);
                    break;
                case"textureatlas":
                    if (b.atlasURL == null) {
                        this.game.cache.addTextureAtlas(b.key, b.url, b.data, b.atlasData, b.format)
                    } else {
                        j = false;
                        this._xhr.open("GET", this.baseURL + b.atlasURL, true);
                        this._xhr.responseType = "text";
                        if (b.format == d.Loader.TEXTURE_ATLAS_JSON_ARRAY || b.format == d.Loader.TEXTURE_ATLAS_JSON_HASH) {
                            this._xhr.onload = function () {
                                return k.jsonLoadComplete(b.key)
                            }
                        } else {
                            if (b.format == d.Loader.TEXTURE_ATLAS_XML_STARLING) {
                                this._xhr.onload = function () {
                                    return k.xmlLoadComplete(b.key)
                                }
                            }
                        }
                        this._xhr.onerror = function () {
                            return k.dataLoadError(b.key)
                        };
                        this._xhr.send()
                    }
                    break;
                case"bitmapfont":
                    if (b.xmlURL == null) {
                        this.game.cache.addBitmapFont(b.key, b.url, b.data, b.xmlData)
                    } else {
                        j = false;
                        this._xhr.open("GET", this.baseURL + b.xmlURL, true);
                        this._xhr.responseType = "text";
                        this._xhr.onload = function () {
                            return k.xmlLoadComplete(b.key)
                        };
                        this._xhr.onerror = function () {
                            return k.dataLoadError(b.key)
                        };
                        this._xhr.send()
                    }
                    break;
                case"audio":
                    if (this.game.sound.usingWebAudio) {
                        b.data = this._xhr.response;
                        this.game.cache.addSound(b.key, b.url, b.data, true, false);
                        if (b.autoDecode) {
                            this.game.cache.updateSound(h, "isDecoding", true);
                            var i = this;
                            var h = b.key;
                            this.game.sound.context.decodeAudioData(b.data, function (l) {
                                if (l) {
                                    i.game.cache.decodedSound(h, l)
                                }
                            })
                        }
                    } else {
                        b.data.removeEventListener("canplaythrough", d.GAMES[this.game.id].load.fileComplete);
                        this.game.cache.addSound(b.key, b.url, b.data, false, true)
                    }
                    break;
                case"text":
                    b.data = this._xhr.responseText;
                    this.game.cache.addText(b.key, b.url, b.data);
                    break
            }
            if (j) {
                this.nextFile(h, true)
            }
        }, jsonLoadComplete: function (h) {
            var i = JSON.parse(this._xhr.responseText);
            var b = this._fileList[h];
            if (b.type == "tilemap") {
                this.game.cache.addTilemap(b.key, b.url, i, b.format)
            } else {
                this.game.cache.addTextureAtlas(b.key, b.url, b.data, i, b.format)
            }
            this.nextFile(h, true)
        }, csvLoadComplete: function (h) {
            var i = this._xhr.responseText;
            var b = this._fileList[h];
            this.game.cache.addTilemap(b.key, b.url, i, b.format);
            this.nextFile(h, true)
        }, dataLoadError: function (h) {
            var b = this._fileList[h];
            b.error = true;
            console.warn("Phaser.Loader dataLoadError: " + h);
            this.nextFile(h, true)
        }, xmlLoadComplete: function (i) {
            var j = this._xhr.responseText;
            var b;
            try {
                if (window.DOMParser) {
                    var l = new DOMParser();
                    b = l.parseFromString(j, "text/xml")
                } else {
                    b = new ActiveXObject("Microsoft.XMLDOM");
                    b.async = "false";
                    b.loadXML(j)
                }
            } catch (k) {
                b = undefined
            }
            if (!b || !b.documentElement || b.getElementsByTagName("parsererror").length) {
                throw new Error("Phaser.Loader. Invalid XML given")
            }
            var h = this._fileList[i];
            if (h.type == "bitmapfont") {
                this.game.cache.addBitmapFont(h.key, h.url, h.data, b)
            } else {
                if (h.type == "textureatlas") {
                    this.game.cache.addTextureAtlas(h.key, h.url, h.data, b, h.format)
                }
            }
            this.nextFile(i, true)
        }, nextFile: function (b, h) {
            this.progress = Math.round(this.progress + this._progressChunk);
            if (this.progress > 100) {
                this.progress = 100
            }
            if (this.preloadSprite !== null) {
                if (this.preloadSprite.direction == 0) {
                    this.preloadSprite.crop.width = Math.floor((this.preloadSprite.width / 100) * this.progress)
                } else {
                    this.preloadSprite.crop.height = Math.floor((this.preloadSprite.height / 100) * this.progress)
                }
                this.preloadSprite.sprite.crop = this.preloadSprite.crop
            }
            this.onFileComplete.dispatch(this.progress, b, h, this.queueSize - this._keys.length, this.queueSize);
            if (this._keys.length > 0) {
                this.loadFile()
            } else {
                this.hasLoaded = true;
                this.isLoading = false;
                this.removeAll();
                this.onLoadComplete.dispatch()
            }
        }
    };
    d.LoaderParser = {
        bitmapFont: function (v, n, q) {
            if (!n.getElementsByTagName("font")) {
                console.warn("Phaser.LoaderParser.bitmapFont: Invalid XML given, missing <font> tag");
                return
            }
            var r = g.TextureCache[q];
            var k = {};
            var h = n.getElementsByTagName("info")[0];
            var o = n.getElementsByTagName("common")[0];
            k.font = h.attributes.getNamedItem("face").nodeValue;
            k.size = parseInt(h.attributes.getNamedItem("size").nodeValue, 10);
            k.lineHeight = parseInt(o.attributes.getNamedItem("lineHeight").nodeValue, 10);
            k.chars = {};
            var p = n.getElementsByTagName("char");
            for (var j = 0; j < p.length; j++) {
                var u = parseInt(p[j].attributes.getNamedItem("id").nodeValue, 10);
                var t = {
                    x: parseInt(p[j].attributes.getNamedItem("x").nodeValue, 10),
                    y: parseInt(p[j].attributes.getNamedItem("y").nodeValue, 10),
                    width: parseInt(p[j].attributes.getNamedItem("width").nodeValue, 10),
                    height: parseInt(p[j].attributes.getNamedItem("height").nodeValue, 10)
                };
                g.TextureCache[u] = new g.Texture(r, t);
                k.chars[u] = {
                    xOffset: parseInt(p[j].attributes.getNamedItem("xoffset").nodeValue, 10),
                    yOffset: parseInt(p[j].attributes.getNamedItem("yoffset").nodeValue, 10),
                    xAdvance: parseInt(p[j].attributes.getNamedItem("xadvance").nodeValue, 10),
                    kerning: {},
                    texture: new g.Texture(r, t)
                }
            }
            var s = n.getElementsByTagName("kerning");
            for (j = 0; j < s.length; j++) {
                var m = parseInt(s[j].attributes.getNamedItem("first").nodeValue, 10);
                var b = parseInt(s[j].attributes.getNamedItem("second").nodeValue, 10);
                var l = parseInt(s[j].attributes.getNamedItem("amount").nodeValue, 10);
                k.chars[b].kerning[m] = l
            }
            g.BitmapText.fonts[k.font] = k
        }
    };
    d.Sound = function (h, i, j, b) {
        j = j || 1;
        if (typeof b == "undefined") {
            b = false
        }
        this.game = h;
        this.name = i;
        this.key = i;
        this.loop = b;
        this._volume = j;
        this.markers = {};
        this.context = null;
        this._buffer = null;
        this._muted = false;
        this.autoplay = false;
        this.totalDuration = 0;
        this.startTime = 0;
        this.currentTime = 0;
        this.duration = 0;
        this.stopTime = 0;
        this.paused = false;
        this.pausedPosition = 0;
        this.pausedTime = 0;
        this.isPlaying = false;
        this.currentMarker = "";
        this.pendingPlayback = false;
        this.override = false;
        this.usingWebAudio = this.game.sound.usingWebAudio;
        this.usingAudioTag = this.game.sound.usingAudioTag;
        if (this.usingWebAudio) {
            this.context = this.game.sound.context;
            this.masterGainNode = this.game.sound.masterGain;
            if (typeof this.context.createGain === "undefined") {
                this.gainNode = this.context.createGainNode()
            } else {
                this.gainNode = this.context.createGain()
            }
            this.gainNode.gain.value = j * this.game.sound.volume;
            this.gainNode.connect(this.masterGainNode)
        } else {
            if (this.game.cache.getSound(i) && this.game.cache.isSoundReady(i)) {
                this._sound = this.game.cache.getSoundData(i);
                this.totalDuration = 0;
                if (this._sound.duration) {
                    this.totalDuration = this._sound.duration
                }
            } else {
                this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)
            }
        }
        this.onDecoded = new d.Signal;
        this.onPlay = new d.Signal;
        this.onPause = new d.Signal;
        this.onResume = new d.Signal;
        this.onLoop = new d.Signal;
        this.onStop = new d.Signal;
        this.onMute = new d.Signal;
        this.onMarkerComplete = new d.Signal
    };
    d.Sound.prototype = {
        soundHasUnlocked: function (b) {
            if (b == this.key) {
                this._sound = this.game.cache.getSoundData(this.key);
                this.totalDuration = this._sound.duration
            }
        }, addMarker: function (h, k, j, i, b) {
            i = i || 1;
            if (typeof b == "undefined") {
                b = false
            }
            this.markers[h] = {name: h, start: k, stop: k + j, volume: i, duration: j, durationMS: j * 1000, loop: b}
        }, removeMarker: function (b) {
            delete this.markers[b]
        }, update: function () {
            if (this.pendingPlayback && this.game.cache.isSoundReady(this.key)) {
                this.pendingPlayback = false;
                this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)
            }
            if (this.isPlaying) {
                this.currentTime = this.game.time.now - this.startTime;
                if (this.currentTime >= this.durationMS) {
                    if (this.usingWebAudio) {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            if (this.currentMarker == "") {
                                this.currentTime = 0;
                                this.startTime = this.game.time.now
                            } else {
                                this.play(this.currentMarker, 0, this.volume, true, true)
                            }
                        } else {
                            this.stop()
                        }
                    } else {
                        if (this.loop) {
                            this.onLoop.dispatch(this);
                            this.play(this.currentMarker, 0, this.volume, true, true)
                        } else {
                            this.stop()
                        }
                    }
                }
            }
        }, play: function (i, b, k, h, j) {
            i = i || "";
            b = b || 0;
            k = k || 1;
            if (typeof h == "undefined") {
                h = false
            }
            if (typeof j == "undefined") {
                j = true
            }
            if (this.isPlaying == true && j == false && this.override == false) {
                return
            }
            if (this.isPlaying && this.override) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0)
                    } else {
                        this._sound.stop(0)
                    }
                } else {
                    if (this.usingAudioTag) {
                        this._sound.pause();
                        this._sound.currentTime = 0
                    }
                }
            }
            this.currentMarker = i;
            if (i !== "") {
                if (this.markers[i]) {
                    this.position = this.markers[i].start;
                    this.volume = this.markers[i].volume;
                    this.loop = this.markers[i].loop;
                    this.duration = this.markers[i].duration;
                    this.durationMS = this.markers[i].durationMS;
                    this._tempMarker = i;
                    this._tempPosition = this.position;
                    this._tempVolume = this.volume;
                    this._tempLoop = this.loop
                } else {
                    console.warn("Phaser.Sound.play: audio marker " + i + " doesn't exist");
                    return
                }
            } else {
                this.position = b;
                this.volume = k;
                this.loop = h;
                this.duration = 0;
                this.durationMS = 0;
                this._tempMarker = i;
                this._tempPosition = b;
                this._tempVolume = k;
                this._tempLoop = h
            }
            if (this.usingWebAudio) {
                if (this.game.cache.isSoundDecoded(this.key)) {
                    if (this._buffer == null) {
                        this._buffer = this.game.cache.getSoundData(this.key)
                    }
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    this._sound.connect(this.gainNode);
                    this.totalDuration = this._sound.buffer.duration;
                    if (this.duration == 0) {
                        this.duration = this.totalDuration;
                        this.durationMS = this.totalDuration * 1000
                    }
                    if (this.loop && i == "") {
                        this._sound.loop = true
                    }
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, this.position, this.duration)
                    } else {
                        this._sound.start(0, this.position, this.duration)
                    }
                    this.isPlaying = true;
                    this.startTime = this.game.time.now;
                    this.currentTime = 0;
                    this.stopTime = this.startTime + this.durationMS;
                    this.onPlay.dispatch(this)
                } else {
                    this.pendingPlayback = true;
                    if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).isDecoding == false) {
                        this.game.sound.decode(this.key, this)
                    }
                }
            } else {
                if (this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked) {
                    this.game.cache.reloadSound(this.key);
                    this.pendingPlayback = true
                } else {
                    if (this._sound && this._sound.readyState == 4) {
                        this._sound.play();
                        this.totalDuration = this._sound.duration;
                        if (this.duration == 0) {
                            this.duration = this.totalDuration;
                            this.durationMS = this.totalDuration * 1000
                        }
                        this._sound.currentTime = this.position;
                        this._sound.muted = this._muted;
                        if (this._muted) {
                            this._sound.volume = 0
                        } else {
                            this._sound.volume = this._volume
                        }
                        this.isPlaying = true;
                        this.startTime = this.game.time.now;
                        this.currentTime = 0;
                        this.stopTime = this.startTime + this.durationMS;
                        this.onPlay.dispatch(this)
                    } else {
                        this.pendingPlayback = true
                    }
                }
            }
        }, restart: function (i, b, j, h) {
            i = i || "";
            b = b || 0;
            j = j || 1;
            if (typeof h == "undefined") {
                h = false
            }
            this.play(i, b, j, h, true)
        }, pause: function () {
            if (this.isPlaying && this._sound) {
                this.stop();
                this.isPlaying = false;
                this.paused = true;
                this.pausedPosition = this.currentTime;
                this.pausedTime = this.game.time.now;
                this.onPause.dispatch(this)
            }
        }, resume: function () {
            if (this.paused && this._sound) {
                if (this.usingWebAudio) {
                    var b = this.position + (this.pausedPosition / 1000);
                    this._sound = this.context.createBufferSource();
                    this._sound.buffer = this._buffer;
                    this._sound.connect(this.gainNode);
                    if (typeof this._sound.start === "undefined") {
                        this._sound.noteGrainOn(0, b, this.duration)
                    } else {
                        this._sound.start(0, b, this.duration)
                    }
                } else {
                    this._sound.play()
                }
                this.isPlaying = true;
                this.paused = false;
                this.startTime += (this.game.time.now - this.pausedTime);
                this.onResume.dispatch(this)
            }
        }, stop: function () {
            if (this.isPlaying && this._sound) {
                if (this.usingWebAudio) {
                    if (typeof this._sound.stop === "undefined") {
                        this._sound.noteOff(0)
                    } else {
                        this._sound.stop(0)
                    }
                } else {
                    if (this.usingAudioTag) {
                        this._sound.pause();
                        this._sound.currentTime = 0
                    }
                }
            }
            this.isPlaying = false;
            var b = this.currentMarker;
            this.currentMarker = "";
            this.onStop.dispatch(this, b)
        }
    };
    Object.defineProperty(d.Sound.prototype, "isDecoding", {
        get: function () {
            return this.game.cache.getSound(this.key).isDecoding
        }
    });
    Object.defineProperty(d.Sound.prototype, "isDecoded", {
        get: function () {
            return this.game.cache.isSoundDecoded(this.key)
        }
    });
    Object.defineProperty(d.Sound.prototype, "mute", {
        get: function () {
            return this._muted
        }, set: function (b) {
            b = b || null;
            if (b) {
                this._muted = true;
                if (this.usingWebAudio) {
                    this._muteVolume = this.gainNode.gain.value;
                    this.gainNode.gain.value = 0
                } else {
                    if (this.usingAudioTag && this._sound) {
                        this._muteVolume = this._sound.volume;
                        this._sound.volume = 0
                    }
                }
            } else {
                this._muted = false;
                if (this.usingWebAudio) {
                    this.gainNode.gain.value = this._muteVolume
                } else {
                    if (this.usingAudioTag && this._sound) {
                        this._sound.volume = this._muteVolume
                    }
                }
            }
            this.onMute.dispatch(this)
        }
    });
    Object.defineProperty(d.Sound.prototype, "volume", {
        get: function () {
            return this._volume
        }, set: function (b) {
            if (this.usingWebAudio) {
                this._volume = b;
                this.gainNode.gain.value = b
            } else {
                if (this.usingAudioTag && this._sound) {
                    if (b >= 0 && b <= 1) {
                        this._volume = b;
                        this._sound.volume = b
                    }
                }
            }
        }
    });
    d.SoundManager = function (b) {
        this.game = b;
        this.onSoundDecode = new d.Signal;
        this._muted = false;
        this._unlockSource = null;
        this._volume = 1;
        this._sounds = [];
        this.context = null;
        this.usingWebAudio = true;
        this.usingAudioTag = false;
        this.noAudio = false;
        this.touchLocked = false;
        this.channels = 32
    };
    d.SoundManager.prototype = {
        boot: function () {
            if (this.game.device.iOS && this.game.device.webAudio == false) {
                this.channels = 1
            }
            if (this.game.device.iOS || (window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock)) {
                this.game.input.touch.callbackContext = this;
                this.game.input.touch.touchStartCallback = this.unlock;
                this.game.input.mouse.callbackContext = this;
                this.game.input.mouse.mouseDownCallback = this.unlock;
                this.touchLocked = true
            } else {
                this.touchLocked = false
            }
            if (window.PhaserGlobal) {
                if (window.PhaserGlobal.disableAudio == true) {
                    this.usingWebAudio = false;
                    this.noAudio = true;
                    return
                }
                if (window.PhaserGlobal.disableWebAudio == true) {
                    this.usingWebAudio = false;
                    this.usingAudioTag = true;
                    this.noAudio = false;
                    return
                }
            }
            if (!!window.AudioContext) {
                this.context = new window.AudioContext()
            } else {
                if (!!window.webkitAudioContext) {
                    this.context = new window.webkitAudioContext()
                } else {
                    if (!!window.Audio) {
                        this.usingWebAudio = false;
                        this.usingAudioTag = true
                    } else {
                        this.usingWebAudio = false;
                        this.noAudio = true
                    }
                }
            }
            if (this.context !== null) {
                if (typeof this.context.createGain === "undefined") {
                    this.masterGain = this.context.createGainNode()
                } else {
                    this.masterGain = this.context.createGain()
                }
                this.masterGain.gain.value = 1;
                this.masterGain.connect(this.context.destination)
            }
        }, unlock: function () {
            if (this.touchLocked == false) {
                return
            }
            if (this.game.device.webAudio == false || (window.PhaserGlobal && window.PhaserGlobal.disableWebAudio == true)) {
                this.touchLocked = false;
                this._unlockSource = null;
                this.game.input.touch.callbackContext = null;
                this.game.input.touch.touchStartCallback = null;
                this.game.input.mouse.callbackContext = null;
                this.game.input.mouse.mouseDownCallback = null
            } else {
                var b = this.context.createBuffer(1, 1, 22050);
                this._unlockSource = this.context.createBufferSource();
                this._unlockSource.buffer = b;
                this._unlockSource.connect(this.context.destination);
                this._unlockSource.noteOn(0)
            }
        }, stopAll: function () {
            for (var b = 0; b < this._sounds.length; b++) {
                if (this._sounds[b]) {
                    this._sounds[b].stop()
                }
            }
        }, pauseAll: function () {
            for (var b = 0; b < this._sounds.length; b++) {
                if (this._sounds[b]) {
                    this._sounds[b].pause()
                }
            }
        }, resumeAll: function () {
            for (var b = 0; b < this._sounds.length; b++) {
                if (this._sounds[b]) {
                    this._sounds[b].resume()
                }
            }
        }, decode: function (h, j) {
            j = j || null;
            var b = this.game.cache.getSoundData(h);
            if (b) {
                if (this.game.cache.isSoundDecoded(h) === false) {
                    this.game.cache.updateSound(h, "isDecoding", true);
                    var i = this;
                    this.context.decodeAudioData(b, function (k) {
                        i.game.cache.decodedSound(h, k);
                        if (j) {
                            i.onSoundDecode.dispatch(j)
                        }
                    })
                }
            }
        }, update: function () {
            if (this.touchLocked) {
                if (this.game.device.webAudio && this._unlockSource !== null) {
                    if ((this._unlockSource.playbackState === this._unlockSource.PLAYING_STATE || this._unlockSource.playbackState === this._unlockSource.FINISHED_STATE)) {
                        this.touchLocked = false;
                        this._unlockSource = null;
                        this.game.input.touch.callbackContext = null;
                        this.game.input.touch.touchStartCallback = null
                    }
                }
            }
            for (var b = 0; b < this._sounds.length; b++) {
                this._sounds[b].update()
            }
        }, add: function (h, i, b) {
            i = i || 1;
            if (typeof b == "undefined") {
                b = false
            }
            var j = new d.Sound(this.game, h, i, b);
            this._sounds.push(j);
            return j
        }
    };
    Object.defineProperty(d.SoundManager.prototype, "mute", {
        get: function () {
            return this._muted
        }, set: function (h) {
            h = h || null;
            if (h) {
                if (this._muted) {
                    return
                }
                this._muted = true;
                if (this.usingWebAudio) {
                    this._muteVolume = this.masterGain.gain.value;
                    this.masterGain.gain.value = 0
                }
                for (var b = 0; b < this._sounds.length; b++) {
                    if (this._sounds[b].usingAudioTag) {
                        this._sounds[b].mute = true
                    }
                }
            } else {
                if (this._muted == false) {
                    return
                }
                this._muted = false;
                if (this.usingWebAudio) {
                    this.masterGain.gain.value = this._muteVolume
                }
                for (var b = 0; b < this._sounds.length; b++) {
                    if (this._sounds[b].usingAudioTag) {
                        this._sounds[b].mute = false
                    }
                }
            }
        }
    });
    Object.defineProperty(d.SoundManager.prototype, "volume", {
        get: function () {
            if (this.usingWebAudio) {
                return this.masterGain.gain.value
            } else {
                return this._volume
            }
        }, set: function (h) {
            h = this.game.math.clamp(h, 1, 0);
            this._volume = h;
            if (this.usingWebAudio) {
                this.masterGain.gain.value = h
            }
            for (var b = 0; b < this._sounds.length; b++) {
                if (this._sounds[b].usingAudioTag) {
                    this._sounds[b].volume = this._sounds[b].volume * h
                }
            }
        }
    });
    d.Utils.Debug = function (b) {
        this.game = b;
        this.context = b.context;
        this.font = "14px Courier";
        this.lineHeight = 16;
        this.renderShadow = true;
        this.currentX = 0;
        this.currentY = 0;
        this.currentAlpha = 1
    };
    d.Utils.Debug.prototype = {
        start: function (b, i, h) {
            if (this.context == null) {
                return
            }
            if (typeof b !== "number") {
                b = 0
            }
            if (typeof i !== "number") {
                i = 0
            }
            h = h || "rgb(255,255,255)";
            this.currentX = b;
            this.currentY = i;
            this.currentColor = h;
            this.currentAlpha = this.context.globalAlpha;
            this.context.save();
            this.context.setTransform(1, 0, 0, 1, 0, 0);
            this.context.fillStyle = h;
            this.context.font = this.font;
            this.context.globalAlpha = 1
        }, stop: function () {
            this.context.restore();
            this.context.globalAlpha = this.currentAlpha
        }, line: function (h, b, i) {
            if (this.context == null) {
                return
            }
            b = b || null;
            i = i || null;
            if (b !== null) {
                this.currentX = b
            }
            if (i !== null) {
                this.currentY = i
            }
            if (this.renderShadow) {
                this.context.fillStyle = "rgb(0,0,0)";
                this.context.fillText(h, this.currentX + 1, this.currentY + 1);
                this.context.fillStyle = this.currentColor
            }
            this.context.fillText(h, this.currentX, this.currentY);
            this.currentY += this.lineHeight
        }, renderQuadTree: function (b, h) {
            h = h || "rgba(255,0,0,0.3)";
            this.start();
            var k = b.bounds;
            if (b.nodes.length === 0) {
                this.context.strokeStyle = h;
                this.context.strokeRect(k.x, k.y, k.width, k.height);
                this.renderText(b.ID + " / " + b.objects.length, k.x + 4, k.y + 16, "rgb(0,200,0)", "12px Courier");
                this.context.strokeStyle = "rgb(0,255,0)";
                for (var j = 0; j < b.objects.length; j++) {
                    this.context.strokeRect(b.objects[j].x, b.objects[j].y, b.objects[j].width, b.objects[j].height)
                }
            } else {
                for (var j = 0; j < b.nodes.length; j++) {
                    this.renderQuadTree(b.nodes[j])
                }
            }
            this.stop()
        }, renderSpriteCorners: function (j, i, h, b) {
            if (this.context == null) {
                return
            }
            i = i || false;
            h = h || false;
            b = b || "rgb(255,255,255)";
            this.start(0, 0, b);
            if (h) {
                this.context.beginPath();
                this.context.strokeStyle = "rgba(0, 255, 0, 0.7)";
                this.context.strokeRect(j.bounds.x, j.bounds.y, j.bounds.width, j.bounds.height);
                this.context.closePath();
                this.context.stroke()
            }
            this.context.beginPath();
            this.context.moveTo(j.topLeft.x, j.topLeft.y);
            this.context.lineTo(j.topRight.x, j.topRight.y);
            this.context.lineTo(j.bottomRight.x, j.bottomRight.y);
            this.context.lineTo(j.bottomLeft.x, j.bottomLeft.y);
            this.context.closePath();
            this.context.strokeStyle = "rgba(255, 0, 255, 0.7)";
            this.context.stroke();
            this.renderPoint(j.offset);
            this.renderPoint(j.center);
            this.renderPoint(j.topLeft);
            this.renderPoint(j.topRight);
            this.renderPoint(j.bottomLeft);
            this.renderPoint(j.bottomRight);
            if (i) {
                this.currentColor = b;
                this.line("x: " + Math.floor(j.topLeft.x) + " y: " + Math.floor(j.topLeft.y), j.topLeft.x, j.topLeft.y);
                this.line("x: " + Math.floor(j.topRight.x) + " y: " + Math.floor(j.topRight.y), j.topRight.x, j.topRight.y);
                this.line("x: " + Math.floor(j.bottomLeft.x) + " y: " + Math.floor(j.bottomLeft.y), j.bottomLeft.x, j.bottomLeft.y);
                this.line("x: " + Math.floor(j.bottomRight.x) + " y: " + Math.floor(j.bottomRight.y), j.bottomRight.x, j.bottomRight.y)
            }
            this.stop()
        }, renderSoundInfo: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255,255,255)";
            this.start(b, j, h);
            this.line("Sound: " + i.key + " Locked: " + i.game.sound.touchLocked);
            this.line("Is Ready?: " + this.game.cache.isSoundReady(i.key) + " Pending Playback: " + i.pendingPlayback);
            this.line("Decoded: " + i.isDecoded + " Decoding: " + i.isDecoding);
            this.line("Total Duration: " + i.totalDuration + " Playing: " + i.isPlaying);
            this.line("Time: " + i.currentTime);
            this.line("Volume: " + i.volume + " Muted: " + i.mute);
            this.line("WebAudio: " + i.usingWebAudio + " Audio: " + i.usingAudioTag);
            if (i.currentMarker !== "") {
                this.line("Marker: " + i.currentMarker + " Duration: " + i.duration);
                this.line("Start: " + i.markers[i.currentMarker].start + " Stop: " + i.markers[i.currentMarker].stop);
                this.line("Position: " + i.position)
            }
            this.stop()
        }, renderCameraInfo: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255,255,255)";
            this.start(b, j, h);
            this.line("Camera (" + i.width + " x " + i.height + ")");
            this.line("X: " + i.x + " Y: " + i.y);
            this.line("Bounds x: " + i.bounds.x + " Y: " + i.bounds.y + " w: " + i.bounds.width + " h: " + i.bounds.height);
            this.line("View x: " + i.view.x + " Y: " + i.view.y + " w: " + i.view.width + " h: " + i.view.height);
            this.stop()
        }, renderPointer: function (k, j, h, i, b) {
            if (this.context == null || k == null) {
                return
            }
            if (typeof j === "undefined") {
                j = false
            }
            h = h || "rgba(0,255,0,0.5)";
            i = i || "rgba(255,0,0,0.5)";
            b = b || "rgb(255,255,255)";
            if (j == true && k.isUp == true) {
                return
            }
            this.start(k.x, k.y - 100, b);
            this.context.beginPath();
            this.context.arc(k.x, k.y, k.circle.radius, 0, Math.PI * 2);
            if (k.active) {
                this.context.fillStyle = h
            } else {
                this.context.fillStyle = i
            }
            this.context.fill();
            this.context.closePath();
            this.context.beginPath();
            this.context.moveTo(k.positionDown.x, k.positionDown.y);
            this.context.lineTo(k.position.x, k.position.y);
            this.context.lineWidth = 2;
            this.context.stroke();
            this.context.closePath();
            this.line("ID: " + k.id + " Active: " + k.active);
            this.line("World X: " + k.worldX + " World Y: " + k.worldY);
            this.line("Screen X: " + k.x + " Screen Y: " + k.y);
            this.line("Duration: " + k.duration + " ms");
            this.stop()
        }, renderSpriteInputInfo: function (i, b, j, h) {
            h = h || "rgb(255,255,255)";
            this.start(b, j, h);
            this.line("Sprite Input: (" + i.width + " x " + i.height + ")");
            this.line("x: " + i.input.pointerX().toFixed(1) + " y: " + i.input.pointerY().toFixed(1));
            this.line("over: " + i.input.pointerOver() + " duration: " + i.input.overDuration().toFixed(0));
            this.line("down: " + i.input.pointerDown() + " duration: " + i.input.downDuration().toFixed(0));
            this.line("just over: " + i.input.justOver() + " just out: " + i.input.justOut());
            this.stop()
        }, renderSpriteCollision: function (i, b, j, h) {
            h = h || "rgb(255,255,255)";
            this.start(b, j, h);
            this.line("Sprite Collision: (" + i.width + " x " + i.height + ")");
            this.line("left: " + i.body.touching.left);
            this.line("right: " + i.body.touching.right);
            this.line("up: " + i.body.touching.up);
            this.line("down: " + i.body.touching.down);
            this.line("velocity.x: " + i.body.velocity.x);
            this.line("velocity.y: " + i.body.velocity.y);
            this.stop()
        }, renderInputInfo: function (b, i, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255,255,0)";
            this.start(b, i, h);
            this.line("Input");
            this.line("X: " + this.game.input.x + " Y: " + this.game.input.y);
            this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY);
            this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1));
            this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY);
            this.stop()
        }, renderSpriteInfo: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255, 255, 255)";
            this.start(b, j, h);
            this.line("Sprite:  (" + i.width + " x " + i.height + ") anchor: " + i.anchor.x + " x " + i.anchor.y);
            this.line("x: " + i.x.toFixed(1) + " y: " + i.y.toFixed(1));
            this.line("angle: " + i.angle.toFixed(1) + " rotation: " + i.rotation.toFixed(1));
            this.line("visible: " + i.visible + " in camera: " + i.inCamera);
            this.line("body x: " + i.body.x.toFixed(1) + " y: " + i.body.y.toFixed(1));
            this.line("deltaX: " + i.body.deltaX());
            this.line("deltaY: " + i.body.deltaY());
            this.stop()
        }, renderWorldTransformInfo: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255, 255, 255)";
            this.start(b, j, h);
            this.line("World Transform");
            this.line("skewX:  " + i.worldTransform[3]);
            this.line("skewY:  " + i.worldTransform[1]);
            this.line("scaleX: " + i.worldTransform[0]);
            this.line("scaleY: " + i.worldTransform[4]);
            this.line("transX: " + i.worldTransform[2]);
            this.line("transY: " + i.worldTransform[5]);
            this.stop()
        }, renderLocalTransformInfo: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255, 255, 255)";
            this.start(b, j, h);
            this.line("Local Transform");
            this.line("skewX:  " + i.localTransform[3]);
            this.line("skewY:  " + i.localTransform[1]);
            this.line("scaleX: " + i.localTransform[0]);
            this.line("scaleY: " + i.localTransform[4]);
            this.line("transX: " + i.localTransform[2]);
            this.line("transY: " + i.localTransform[5]);
            this.stop()
        }, renderSpriteCoords: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255, 255, 255)";
            this.start(b, j, h);
            if (i.name) {
                this.line(i.name)
            }
            this.line("x: " + i.x);
            this.line("y: " + i.y);
            this.line("pos x: " + i.position.x);
            this.line("pos y: " + i.position.y);
            this.line("local x: " + i.localTransform[2]);
            this.line("local y: " + i.localTransform[5]);
            this.line("t x: " + i.worldTransform[2]);
            this.line("t y: " + i.worldTransform[5]);
            this.line("world x: " + i.world.x);
            this.line("world y: " + i.world.y);
            this.stop()
        }, renderGroupInfo: function (i, b, j, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgb(255, 255, 255)";
            this.start(b, j, h);
            this.line("Group (size: " + i.length + ")");
            this.line("x: " + i.x);
            this.line("y: " + i.y);
            this.stop()
        }, renderPointInfo: function (h, b, j, i) {
            if (this.context == null) {
                return
            }
            i = i || "rgb(255, 255, 255)";
            this.start(b, j, i);
            this.line("px: " + h.x.toFixed(1) + " py: " + h.y.toFixed(1));
            this.stop()
        }, renderSpriteBody: function (h, b) {
            if (this.context == null) {
                return
            }
            b = b || "rgba(255,0,255, 0.3)";
            this.start(0, 0, b);
            this.context.fillStyle = b;
            this.context.fillRect(h.body.screenX, h.body.screenY, h.body.width, h.body.height);
            this.stop()
        }, renderSpriteBounds: function (h, b, i) {
            if (this.context == null) {
                return
            }
            b = b || "rgb(255,0,255)";
            if (typeof i === "undefined") {
                i = false
            }
            this.start(0, 0, b);
            if (i) {
                this.context.fillStyle = b;
                this.context.fillRect(h.bounds.x, h.bounds.y, h.bounds.width, h.bounds.height)
            } else {
                this.context.strokeStyle = b;
                this.context.strokeRect(h.bounds.x, h.bounds.y, h.bounds.width, h.bounds.height);
                this.context.stroke()
            }
            this.stop()
        }, renderPixel: function (b, i, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgba(0,255,0,1)";
            this.start();
            this.context.fillStyle = h;
            this.context.fillRect(b, i, 2, 2);
            this.stop()
        }, renderPoint: function (b, h) {
            if (this.context == null) {
                return
            }
            h = h || "rgba(0,255,0,1)";
            this.start();
            this.context.fillStyle = h;
            this.context.fillRect(b.x, b.y, 4, 4);
            this.stop()
        }, renderRectangle: function (h, b) {
            if (this.context == null) {
                return
            }
            b = b || "rgba(0,255,0,0.3)";
            this.start();
            this.context.fillStyle = b;
            this.context.fillRect(h.x, h.y, h.width, h.height);
            this.stop()
        }, renderCircle: function (h, b) {
            if (this.context == null) {
                return
            }
            b = b || "rgba(0,255,0,0.3)";
            this.start();
            this.context.beginPath();
            this.context.fillStyle = b;
            this.context.arc(h.x, h.y, h.radius, 0, Math.PI * 2, false);
            this.context.fill();
            this.context.closePath();
            this.stop()
        }, renderText: function (j, b, k, i, h) {
            if (this.context == null) {
                return
            }
            i = i || "rgb(255,255,255)";
            h = h || "16px Courier";
            this.start();
            this.context.font = h;
            this.context.fillStyle = i;
            this.context.fillText(j, b, k);
            this.stop()
        }, dumpLinkedList: function (n) {
            var p = 20;
            var j = "\n" + d.Utils.pad("Node", p) + "|" + d.Utils.pad("Next", p) + "|" + d.Utils.pad("Previous", p) + "|" + d.Utils.pad("First", p) + "|" + d.Utils.pad("Last", p);
            console.log(j);
            var j = d.Utils.pad("----------", p) + "|" + d.Utils.pad("----------", p) + "|" + d.Utils.pad("----------", p) + "|" + d.Utils.pad("----------", p) + "|" + d.Utils.pad("----------", p);
            console.log(j);
            var l = n;
            var h = l.last.next;
            l = l.first;
            do {
                var i = l.sprite.name || "*";
                var k = "-";
                var b = "-";
                var m = "-";
                var o = "-";
                if (l.next) {
                    k = l.next.sprite.name
                }
                if (l.prev) {
                    b = l.prev.sprite.name
                }
                if (l.first) {
                    m = l.first.sprite.name
                }
                if (l.last) {
                    o = l.last.sprite.name
                }
                if (typeof k === "undefined") {
                    k = "-"
                }
                if (typeof b === "undefined") {
                    b = "-"
                }
                if (typeof m === "undefined") {
                    m = "-"
                }
                if (typeof o === "undefined") {
                    o = "-"
                }
                var j = d.Utils.pad(i, p) + "|" + d.Utils.pad(k, p) + "|" + d.Utils.pad(b, p) + "|" + d.Utils.pad(m, p) + "|" + d.Utils.pad(o, p);
                console.log(j);
                l = l.next
            } while (l != h)
        }
    };
    d.Color = {
        getColor32: function (j, i, h, b) {
            return j << 24 | i << 16 | h << 8 | b
        }, getColor: function (i, h, b) {
            return i << 16 | h << 8 | b
        }, hexToRGB: function (j) {
            var i = (j.charAt(0) == "#") ? j.substring(1, 7) : j;
            if (i.length == 3) {
                i = i.charAt(0) + i.charAt(0) + i.charAt(1) + i.charAt(1) + i.charAt(2) + i.charAt(2)
            }
            var l = parseInt(i.substring(0, 2), 16);
            var k = parseInt(i.substring(2, 4), 16);
            var b = parseInt(i.substring(4, 6), 16);
            return l << 16 | k << 8 | b
        }, getColorInfo: function (i) {
            var j = d.Color.getRGB(i);
            var h = d.Color.RGBtoHSV(i);
            var b = d.Color.RGBtoHexstring(i) + "\n";
            b = b.concat("Alpha: " + j.alpha + " Red: " + j.red + " Green: " + j.green + " Blue: " + j.blue) + "\n";
            b = b.concat("Hue: " + h.hue + " Saturation: " + h.saturation + " Lightnes: " + h.lightness);
            return b
        }, RGBtoHexstring: function (b) {
            var h = d.Color.getRGB(b);
            return "0x" + d.Color.colorToHexstring(h.alpha) + d.Color.colorToHexstring(h.red) + d.Color.colorToHexstring(h.green) + d.Color.colorToHexstring(h.blue)
        }, RGBtoWebstring: function (b) {
            var h = d.Color.getRGB(b);
            return "#" + d.Color.colorToHexstring(h.red) + d.Color.colorToHexstring(h.green) + d.Color.colorToHexstring(h.blue)
        }, colorToHexstring: function (i) {
            var k = "0123456789ABCDEF";
            var j = i % 16;
            var h = (i - j) / 16;
            var b = k.charAt(h) + k.charAt(j);
            return b
        }, interpolateColor: function (q, p, o, i, l) {
            if (typeof l === "undefined") {
                l = 255
            }
            var k = d.Color.getRGB(q);
            var j = d.Color.getRGB(p);
            var h = (((j.red - k.red) * i) / o) + k.red;
            var m = (((j.green - k.green) * i) / o) + k.green;
            var n = (((j.blue - k.blue) * i) / o) + k.blue;
            return d.Color.getColor32(l, h, m, n)
        }, interpolateColorWithRGB: function (l, i, n, p, o, j) {
            var h = d.Color.getRGB(l);
            var m = (((i - h.red) * j) / o) + h.red;
            var q = (((n - h.green) * j) / o) + h.green;
            var k = (((p - h.blue) * j) / o) + h.blue;
            return d.Color.getColor(m, q, k)
        }, interpolateRGB: function (l, i, q, k, s, o, p, j) {
            var h = (((k - l) * j) / p) + l;
            var m = (((s - i) * j) / p) + i;
            var n = (((o - q) * j) / p) + q;
            return d.Color.getColor(h, m, n)
        }, getRandomColor: function (i, h, l) {
            if (typeof i === "undefined") {
                i = 0
            }
            if (typeof h === "undefined") {
                h = 255
            }
            if (typeof l === "undefined") {
                l = 255
            }
            if (h > 255) {
                return d.Color.getColor(255, 255, 255)
            }
            if (i > h) {
                return d.Color.getColor(255, 255, 255)
            }
            var k = i + Math.round(Math.random() * (h - i));
            var j = i + Math.round(Math.random() * (h - i));
            var b = i + Math.round(Math.random() * (h - i));
            return d.Color.getColor32(l, k, j, b)
        }, getRGB: function (b) {
            return {alpha: b >>> 24, red: b >> 16 & 255, green: b >> 8 & 255, blue: b & 255}
        }, getWebRGB: function (h) {
            var k = (h >>> 24) / 255;
            var j = h >> 16 & 255;
            var i = h >> 8 & 255;
            var b = h & 255;
            return "rgba(" + j.toString() + "," + i.toString() + "," + b.toString() + "," + k.toString() + ")"
        }, getAlpha: function (b) {
            return b >>> 24
        }, getAlphaFloat: function (b) {
            return (b >>> 24) / 255
        }, getRed: function (b) {
            return b >> 16 & 255
        }, getGreen: function (b) {
            return b >> 8 & 255
        }, getBlue: function (b) {
            return b & 255
        }
    };
    d.Physics = {};
    d.Physics.Arcade = function (b) {
        this.game = b;
        this.gravity = new d.Point;
        this.bounds = new d.Rectangle(0, 0, b.world.width, b.world.height);
        this.maxObjects = 10;
        this.maxLevels = 4;
        this.OVERLAP_BIAS = 4;
        this.quadTree = new d.QuadTree(this, this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels);
        this.quadTreeID = 0;
        this._bounds1 = new d.Rectangle;
        this._bounds2 = new d.Rectangle;
        this._overlap = 0;
        this._maxOverlap = 0;
        this._velocity1 = 0;
        this._velocity2 = 0;
        this._newVelocity1 = 0;
        this._newVelocity2 = 0;
        this._average = 0;
        this._mapData = [];
        this._mapTiles = 0;
        this._result = false;
        this._total = 0;
        this._angle = 0;
        this._dx = 0;
        this._dy = 0
    };
    d.Physics.Arcade.prototype = {
        updateMotion: function (b) {
            this._velocityDelta = (this.computeVelocity(0, b, b.angularVelocity, b.angularAcceleration, b.angularDrag, b.maxAngular) - b.angularVelocity) / 2;
            b.angularVelocity += this._velocityDelta;
            b.rotation += (b.angularVelocity * this.game.time.physicsElapsed);
            b.angularVelocity += this._velocityDelta;
            this._velocityDelta = (this.computeVelocity(1, b, b.velocity.x, b.acceleration.x, b.drag.x, b.maxVelocity.x) - b.velocity.x) / 2;
            b.velocity.x += this._velocityDelta;
            b.x += (b.velocity.x * this.game.time.physicsElapsed);
            b.velocity.x += this._velocityDelta;
            this._velocityDelta = (this.computeVelocity(2, b, b.velocity.y, b.acceleration.y, b.drag.y, b.maxVelocity.y) - b.velocity.y) / 2;
            b.velocity.y += this._velocityDelta;
            b.y += (b.velocity.y * this.game.time.physicsElapsed);
            b.velocity.y += this._velocityDelta
        }, computeVelocity: function (j, h, l, k, i, b) {
            b = b || 10000;
            if (j == 1 && h.allowGravity) {
                l += this.gravity.x + h.gravity.x
            } else {
                if (j == 2 && h.allowGravity) {
                    l += this.gravity.y + h.gravity.y
                }
            }
            if (k !== 0) {
                l += k * this.game.time.physicsElapsed
            } else {
                if (i !== 0) {
                    this._drag = i * this.game.time.physicsElapsed;
                    if (l - this._drag > 0) {
                        l -= this._drag
                    } else {
                        if (l + this._drag < 0) {
                            l += this._drag
                        } else {
                            l = 0
                        }
                    }
                }
            }
            if (l > b) {
                l = b
            } else {
                if (l < -b) {
                    l = -b
                }
            }
            return l
        }, preUpdate: function () {
            this.quadTree.clear();
            this.quadTreeID = 0;
            this.quadTree = new d.QuadTree(this, this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels)
        }, postUpdate: function () {
            this.quadTree.clear()
        }, overlap: function (h, b) {
            if (h && b && h.exists && b.exists) {
                return (d.Rectangle.intersects(h.body, b.body))
            }
            return false
        }, collide: function (k, j, i, h, b) {
            i = i || null;
            h = h || null;
            b = b || i;
            this._result = false;
            this._total = 0;
            if (k && j && k.exists && j.exists) {
                if (k.type == d.SPRITE) {
                    if (j.type == d.SPRITE) {
                        this.collideSpriteVsSprite(k, j, i, h, b)
                    } else {
                        if (j.type == d.GROUP || j.type == d.EMITTER) {
                            this.collideSpriteVsGroup(k, j, i, h, b)
                        } else {
                            if (j.type == d.TILEMAPLAYER) {
                                this.collideSpriteVsTilemapLayer(k, j, i, h, b)
                            }
                        }
                    }
                } else {
                    if (k.type == d.GROUP) {
                        if (j.type == d.SPRITE) {
                            this.collideSpriteVsGroup(j, k, i, h, b)
                        } else {
                            if (j.type == d.GROUP || j.type == d.EMITTER) {
                                this.collideGroupVsGroup(k, j, i, h, b)
                            } else {
                                if (j.type == d.TILEMAPLAYER) {
                                    this.collideGroupVsTilemapLayer(k, j, i, h, b)
                                }
                            }
                        }
                    } else {
                        if (k.type == d.TILEMAPLAYER) {
                            if (j.type == d.SPRITE) {
                                this.collideSpriteVsTilemapLayer(j, k, i, h, b)
                            } else {
                                if (j.type == d.GROUP || j.type == d.EMITTER) {
                                    this.collideGroupVsTilemapLayer(j, k, i, h, b)
                                }
                            }
                        } else {
                            if (k.type == d.EMITTER) {
                                if (j.type == d.SPRITE) {
                                    this.collideSpriteVsGroup(j, k, i, h, b)
                                } else {
                                    if (j.type == d.GROUP || j.type == d.EMITTER) {
                                        this.collideGroupVsGroup(k, j, i, h, b)
                                    } else {
                                        if (j.type == d.TILEMAPLAYER) {
                                            this.collideGroupVsTilemapLayer(k, j, i, h, b)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return (this._total > 0)
        }, collideSpriteVsTilemapLayer: function (k, b, m, l, h) {
            this._mapData = b.getTiles(k.body.x, k.body.y, k.body.width, k.body.height, true);
            if (this._mapData.length == 0) {
                return
            }
            for (var j = 0; j < this._mapData.length; j++) {
                if (this.separateTile(k.body, this._mapData[j])) {
                    if (l) {
                        if (l.call(h, k, this._mapData[j])) {
                            this._total++;
                            if (m) {
                                m.call(h, k, this._mapData[j])
                            }
                        }
                    } else {
                        this._total++;
                        if (m) {
                            m.call(h, k, this._mapData[j])
                        }
                    }
                }
            }
        }, collideGroupVsTilemapLayer: function (l, b, k, j, h) {
            if (l.length == 0) {
                return
            }
            if (l.length == 0) {
                return
            }
            if (l._container.first._iNext) {
                var i = l._container.first._iNext;
                do {
                    if (i.exists) {
                        this.collideSpriteVsTilemapLayer(i, b, k, j, h)
                    }
                    i = i._iNext
                } while (i != l._container.last._iNext)
            }
        }, collideSpriteVsSprite: function (k, j, i, h, b) {
            this.separate(k.body, j.body);
            if (this._result) {
                if (h) {
                    if (h.call(b, k, j)) {
                        this._total++;
                        if (i) {
                            i.call(b, k, j)
                        }
                    }
                } else {
                    this._total++;
                    if (i) {
                        i.call(b, k, j)
                    }
                }
            }
        }, collideSpriteVsGroup: function (k, n, m, l, h) {
            if (n.length == 0) {
                return
            }
            this._potentials = this.quadTree.retrieve(k);
            for (var j = 0, b = this._potentials.length; j < b; j++) {
                if (this._potentials[j].sprite.group == n) {
                    this.separate(k.body, this._potentials[j]);
                    if (this._result && l) {
                        this._result = l.call(h, k, this._potentials[j].sprite)
                    }
                    if (this._result) {
                        this._total++;
                        if (m) {
                            m.call(h, k, this._potentials[j].sprite)
                        }
                    }
                }
            }
        }, collideGroupVsGroup: function (b, l, k, j, h) {
            if (b.length == 0 || l.length == 0) {
                return
            }
            if (b._container.first._iNext) {
                var i = b._container.first._iNext;
                do {
                    if (i.exists) {
                        this.collideSpriteVsGroup(i, l, k, j, h)
                    }
                    i = i._iNext
                } while (i != b._container.last._iNext)
            }
        }, separate: function (h, b) {
            this._result = (this.separateX(h, b) || this.separateY(h, b))
        }, separateX: function (h, b) {
            if (h.immovable && b.immovable) {
                return false
            }
            this._overlap = 0;
            if (d.Rectangle.intersects(h, b)) {
                this._maxOverlap = h.deltaAbsX() + b.deltaAbsX() + this.OVERLAP_BIAS;
                if (h.deltaX() == 0 && b.deltaX() == 0) {
                    h.embedded = true;
                    b.embedded = true
                } else {
                    if (h.deltaX() > b.deltaX()) {
                        this._overlap = h.x + h.width - b.x;
                        if ((this._overlap > this._maxOverlap) || h.allowCollision.right == false || b.allowCollision.left == false) {
                            this._overlap = 0
                        } else {
                            h.touching.right = true;
                            b.touching.left = true
                        }
                    } else {
                        if (h.deltaX() < b.deltaX()) {
                            this._overlap = h.x - b.width - b.x;
                            if ((-this._overlap > this._maxOverlap) || h.allowCollision.left == false || b.allowCollision.right == false) {
                                this._overlap = 0
                            } else {
                                h.touching.left = true;
                                b.touching.right = true
                            }
                        }
                    }
                }
                if (this._overlap != 0) {
                    h.overlapX = this._overlap;
                    b.overlapX = this._overlap;
                    if (h.customSeparateX || b.customSeparateX) {
                        return true
                    }
                    this._velocity1 = h.velocity.x;
                    this._velocity2 = b.velocity.x;
                    if (!h.immovable && !b.immovable) {
                        this._overlap *= 0.5;
                        h.x = h.x - this._overlap;
                        b.x += this._overlap;
                        this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * b.mass) / h.mass) * ((this._velocity2 > 0) ? 1 : -1);
                        this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * h.mass) / b.mass) * ((this._velocity1 > 0) ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        h.velocity.x = this._average + this._newVelocity1 * h.bounce.x;
                        b.velocity.x = this._average + this._newVelocity2 * b.bounce.x
                    } else {
                        if (!h.immovable) {
                            h.x = h.x - this._overlap;
                            h.velocity.x = this._velocity2 - this._velocity1 * h.bounce.x
                        } else {
                            if (!b.immovable) {
                                b.x += this._overlap;
                                b.velocity.x = this._velocity1 - this._velocity2 * b.bounce.x
                            }
                        }
                    }
                    return true
                }
            }
            return false
        }, separateY: function (h, b) {
            if (h.immovable && b.immovable) {
                return false
            }
            this._overlap = 0;
            if (d.Rectangle.intersects(h, b)) {
                this._maxOverlap = h.deltaAbsY() + b.deltaAbsY() + this.OVERLAP_BIAS;
                if (h.deltaY() == 0 && b.deltaY() == 0) {
                    h.embedded = true;
                    b.embedded = true
                } else {
                    if (h.deltaY() > b.deltaY()) {
                        this._overlap = h.y + h.height - b.y;
                        if ((this._overlap > this._maxOverlap) || h.allowCollision.down == false || b.allowCollision.up == false) {
                            this._overlap = 0
                        } else {
                            h.touching.down = true;
                            b.touching.up = true
                        }
                    } else {
                        if (h.deltaY() < b.deltaY()) {
                            this._overlap = h.y - b.height - b.y;
                            if ((-this._overlap > this._maxOverlap) || h.allowCollision.up == false || b.allowCollision.down == false) {
                                this._overlap = 0
                            } else {
                                h.touching.up = true;
                                b.touching.down = true
                            }
                        }
                    }
                }
                if (this._overlap != 0) {
                    h.overlapY = this._overlap;
                    b.overlapY = this._overlap;
                    if (h.customSeparateY || b.customSeparateY) {
                        return true
                    }
                    this._velocity1 = h.velocity.y;
                    this._velocity2 = b.velocity.y;
                    if (!h.immovable && !b.immovable) {
                        this._overlap *= 0.5;
                        h.y = h.y - this._overlap;
                        b.y += this._overlap;
                        this._newVelocity1 = Math.sqrt((this._velocity2 * this._velocity2 * b.mass) / h.mass) * ((this._velocity2 > 0) ? 1 : -1);
                        this._newVelocity2 = Math.sqrt((this._velocity1 * this._velocity1 * h.mass) / b.mass) * ((this._velocity1 > 0) ? 1 : -1);
                        this._average = (this._newVelocity1 + this._newVelocity2) * 0.5;
                        this._newVelocity1 -= this._average;
                        this._newVelocity2 -= this._average;
                        h.velocity.y = this._average + this._newVelocity1 * h.bounce.y;
                        b.velocity.y = this._average + this._newVelocity2 * b.bounce.y
                    } else {
                        if (!h.immovable) {
                            h.y = h.y - this._overlap;
                            h.velocity.y = this._velocity2 - this._velocity1 * h.bounce.y;
                            if (b.active && b.moves && (h.deltaY() > b.deltaY())) {
                                h.x += b.x - b.lastX
                            }
                        } else {
                            if (!b.immovable) {
                                b.y += this._overlap;
                                b.velocity.y = this._velocity1 - this._velocity2 * b.bounce.y;
                                if (h.sprite.active && h.moves && (h.deltaY() < b.deltaY())) {
                                    b.x += h.x - h.lastX
                                }
                            }
                        }
                    }
                    return true
                }
            }
            return false
        }, separateTile: function (b, h) {
            this._result = (this.separateTileX(b, h, true) || this.separateTileY(b, h, true))
        }, separateTileX: function (b, i, h) {
            if (b.immovable || b.deltaX() == 0 || d.Rectangle.intersects(b.hullX, i) == false) {
                return false
            }
            this._overlap = 0;
            if (b.deltaX() < 0) {
                this._overlap = i.right - b.hullX.x;
                if (b.allowCollision.left == false || i.tile.collideRight == false) {
                    this._overlap = 0
                } else {
                    b.touching.left = true
                }
            } else {
                this._overlap = b.hullX.right - i.x;
                if (b.allowCollision.right == false || i.tile.collideLeft == false) {
                    this._overlap = 0
                } else {
                    b.touching.right = true
                }
            }
            if (this._overlap != 0) {
                if (h) {
                    if (b.deltaX() < 0) {
                        b.x = b.x + this._overlap
                    } else {
                        b.x = b.x - this._overlap
                    }
                    if (b.bounce.x == 0) {
                        b.velocity.x = 0
                    } else {
                        b.velocity.x = -b.velocity.x * b.bounce.x
                    }
                    b.updateHulls()
                }
                return true
            } else {
                return false
            }
        }, separateTileY: function (b, i, h) {
            if (b.immovable || b.deltaY() == 0 || d.Rectangle.intersects(b.hullY, i) == false) {
                return false
            }
            this._overlap = 0;
            if (b.deltaY() < 0) {
                this._overlap = i.bottom - b.hullY.y;
                if (b.allowCollision.up == false || i.tile.collideDown == false) {
                    this._overlap = 0
                } else {
                    b.touching.up = true
                }
            } else {
                this._overlap = b.hullY.bottom - i.y;
                if (b.allowCollision.down == false || i.tile.collideUp == false) {
                    this._overlap = 0
                } else {
                    b.touching.down = true
                }
            }
            if (this._overlap != 0) {
                if (h) {
                    if (b.deltaY() < 0) {
                        b.y = b.y + this._overlap
                    } else {
                        b.y = b.y - this._overlap
                    }
                    if (b.bounce.y == 0) {
                        b.velocity.y = 0
                    } else {
                        b.velocity.y = -b.velocity.y * b.bounce.y
                    }
                    b.updateHulls()
                }
                return true
            } else {
                return false
            }
        }, moveToObject: function (j, b, i, h) {
            if (typeof i === "undefined") {
                i = 60
            }
            if (typeof h === "undefined") {
                h = 0
            }
            this._angle = Math.atan2(b.y - j.y, b.x - j.x);
            if (h > 0) {
                i = this.distanceBetween(j, b) / (h / 1000)
            }
            j.body.velocity.x = Math.cos(this._angle) * i;
            j.body.velocity.y = Math.sin(this._angle) * i;
            return this._angle
        }, moveToPointer: function (j, h, i, b) {
            if (typeof h === "undefined") {
                h = 60
            }
            i = i || this.game.input.activePointer;
            if (typeof b === "undefined") {
                b = 0
            }
            this._angle = this.angleToPointer(j, i);
            if (b > 0) {
                h = this.distanceToPointer(j, i) / (b / 1000)
            }
            j.body.velocity.x = Math.cos(this._angle) * h;
            j.body.velocity.y = Math.sin(this._angle) * h;
            return this._angle
        }, moveToXY: function (j, b, k, i, h) {
            if (typeof i === "undefined") {
                i = 60
            }
            if (typeof h === "undefined") {
                h = 0
            }
            this._angle = Math.atan2(k - j.y, b - j.x);
            if (h > 0) {
                i = this.distanceToXY(j, b, k) / (h / 1000)
            }
            j.body.velocity.x = Math.cos(this._angle) * i;
            j.body.velocity.y = Math.sin(this._angle) * i;
            return this._angle
        }, velocityFromAngle: function (i, h, b) {
            if (typeof h === "undefined") {
                h = 60
            }
            b = b || new d.Point;
            return b.setTo((Math.cos(this.game.math.degToRad(i)) * h), (Math.sin(this.game.math.degToRad(i)) * h))
        }, velocityFromRotation: function (h, i, b) {
            if (typeof i === "undefined") {
                i = 60
            }
            b = b || new d.Point;
            return b.setTo((Math.cos(h) * i), (Math.sin(h) * i))
        }, accelerationFromRotation: function (h, i, b) {
            if (typeof i === "undefined") {
                i = 60
            }
            b = b || new d.Point;
            return b.setTo((Math.cos(h) * i), (Math.sin(h) * i))
        }, accelerateToObject: function (j, h, i, b, k) {
            if (typeof i === "undefined") {
                i = 60
            }
            if (typeof b === "undefined") {
                b = 1000
            }
            if (typeof k === "undefined") {
                k = 1000
            }
            this._angle = this.angleBetween(j, h);
            j.body.acceleration.setTo(Math.cos(this._angle) * i, Math.sin(this._angle) * i);
            j.body.maxVelocity.setTo(b, k);
            return this._angle
        }, accelerateToPointer: function (j, i, h, b, k) {
            if (typeof h === "undefined") {
                h = 60
            }
            if (typeof i === "undefined") {
                i = this.game.input.activePointer
            }
            if (typeof b === "undefined") {
                b = 1000
            }
            if (typeof k === "undefined") {
                k = 1000
            }
            this._angle = this.angleToPointer(j, i);
            j.body.acceleration.setTo(Math.cos(this._angle) * h, Math.sin(this._angle) * h);
            j.body.maxVelocity.setTo(b, k);
            return this._angle
        }, accelerateToXY: function (j, h, l, i, b, k) {
            if (typeof i === "undefined") {
                i = 60
            }
            if (typeof b === "undefined") {
                b = 1000
            }
            if (typeof k === "undefined") {
                k = 1000
            }
            this._angle = this.angleToXY(j, h, l);
            j.body.acceleration.setTo(Math.cos(this._angle) * i, Math.sin(this._angle) * i);
            j.body.maxVelocity.setTo(b, k);
            return this._angle
        }, distanceBetween: function (b, h) {
            this._dx = b.x - h.x;
            this._dy = b.y - h.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        }, distanceToXY: function (h, b, i) {
            this._dx = h.x - b;
            this._dy = h.y - i;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        }, distanceToPointer: function (h, b) {
            b = b || this.game.input.activePointer;
            this._dx = h.x - b.x;
            this._dy = h.y - b.y;
            return Math.sqrt(this._dx * this._dx + this._dy * this._dy)
        }, angleBetween: function (b, h) {
            this._dx = h.x - b.x;
            this._dy = h.y - b.y;
            return Math.atan2(this._dy, this._dx)
        }, angleToXY: function (h, b, i) {
            this._dx = b - h.x;
            this._dy = i - h.y;
            return Math.atan2(this._dy, this._dx)
        }, angleToPointer: function (h, b) {
            b = b || this.game.input.activePointer;
            this._dx = b.worldX - h.x;
            this._dy = b.worldY - h.y;
            return Math.atan2(this._dy, this._dx)
        }
    };
    d.Physics.Arcade.Body = function (b) {
        this.sprite = b;
        this.game = b.game;
        this.offset = new d.Point;
        this.x = b.x;
        this.y = b.y;
        this.preX = b.x;
        this.preY = b.y;
        this.preRotation = b.angle;
        this.screenX = b.x;
        this.screenY = b.y;
        this.sourceWidth = b.currentFrame.sourceSizeW;
        this.sourceHeight = b.currentFrame.sourceSizeH;
        this.width = b.currentFrame.sourceSizeW;
        this.height = b.currentFrame.sourceSizeH;
        this.halfWidth = Math.floor(b.currentFrame.sourceSizeW / 2);
        this.halfHeight = Math.floor(b.currentFrame.sourceSizeH / 2);
        this.center = new d.Point(this.x + this.halfWidth, this.y + this.halfHeight);
        this._sx = b.scale.x;
        this._sy = b.scale.y;
        this.velocity = new d.Point;
        this.acceleration = new d.Point;
        this.drag = new d.Point;
        this.gravity = new d.Point;
        this.bounce = new d.Point;
        this.maxVelocity = new d.Point(10000, 10000);
        this.angularVelocity = 0;
        this.angularAcceleration = 0;
        this.angularDrag = 0;
        this.maxAngular = 1000;
        this.mass = 1;
        this.skipQuadTree = false;
        this.quadTreeIDs = [];
        this.quadTreeIndex = -1;
        this.allowCollision = {none: false, any: true, up: true, down: true, left: true, right: true};
        this.touching = {none: true, up: false, down: false, left: false, right: false};
        this.wasTouching = {none: true, up: false, down: false, left: false, right: false};
        this.facing = d.NONE;
        this.immovable = false;
        this.moves = true;
        this.rotation = 0;
        this.allowRotation = true;
        this.allowGravity = true;
        this.customSeparateX = false;
        this.customSeparateY = false;
        this.overlapX = 0;
        this.overlapY = 0;
        this.hullX = new d.Rectangle();
        this.hullY = new d.Rectangle();
        this.embedded = false;
        this.collideWorldBounds = false
    };
    d.Physics.Arcade.Body.prototype = {
        updateBounds: function (j, i, h, b) {
            if (h != this._sx || b != this._sy) {
                this.width = this.sourceWidth * h;
                this.height = this.sourceHeight * b;
                this.halfWidth = Math.floor(this.width / 2);
                this.halfHeight = Math.floor(this.height / 2);
                this._sx = h;
                this._sy = b;
                this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
            }
        }, preUpdate: function () {
            this.wasTouching.none = this.touching.none;
            this.wasTouching.up = this.touching.up;
            this.wasTouching.down = this.touching.down;
            this.wasTouching.left = this.touching.left;
            this.wasTouching.right = this.touching.right;
            this.touching.none = true;
            this.touching.up = false;
            this.touching.down = false;
            this.touching.left = false;
            this.touching.right = false;
            this.embedded = false;
            this.screenX = (this.sprite.worldTransform[2] - (this.sprite.anchor.x * this.width)) + this.offset.x;
            this.screenY = (this.sprite.worldTransform[5] - (this.sprite.anchor.y * this.height)) + this.offset.y;
            this.preX = (this.sprite.world.x - (this.sprite.anchor.x * this.width)) + this.offset.x;
            this.preY = (this.sprite.world.y - (this.sprite.anchor.y * this.height)) + this.offset.y;
            this.preRotation = this.sprite.angle;
            this.x = this.preX;
            this.y = this.preY;
            this.rotation = this.preRotation;
            if (this.moves) {
                this.game.physics.updateMotion(this);
                if (this.collideWorldBounds) {
                    this.checkWorldBounds()
                }
                this.updateHulls()
            }
            if (this.skipQuadTree == false && this.allowCollision.none == false && this.sprite.visible && this.sprite.alive) {
                this.quadTreeIDs = [];
                this.quadTreeIndex = -1;
                this.game.physics.quadTree.insert(this)
            }
        }, postUpdate: function () {
            if (this.deltaX() < 0) {
                this.facing = d.LEFT
            } else {
                if (this.deltaX() > 0) {
                    this.facing = d.RIGHT
                }
            }
            if (this.deltaY() < 0) {
                this.facing = d.UP
            } else {
                if (this.deltaY() > 0) {
                    this.facing = d.DOWN
                }
            }
            if (this.deltaX() !== 0 || this.deltaY() !== 0) {
                this.sprite.x += this.deltaX();
                this.sprite.y += this.deltaY();
                this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
            }
            if (this.allowRotation) {
                this.sprite.angle += this.deltaZ()
            }
        }, updateHulls: function () {
            this.hullX.setTo(this.x, this.preY, this.width, this.height);
            this.hullY.setTo(this.preX, this.y, this.width, this.height)
        }, checkWorldBounds: function () {
            if (this.x < this.game.world.bounds.x) {
                this.x = this.game.world.bounds.x;
                this.velocity.x *= -this.bounce.x
            } else {
                if (this.right > this.game.world.bounds.right) {
                    this.x = this.game.world.bounds.right - this.width;
                    this.velocity.x *= -this.bounce.x
                }
            }
            if (this.y < this.game.world.bounds.y) {
                this.y = this.game.world.bounds.y;
                this.velocity.y *= -this.bounce.y
            } else {
                if (this.bottom > this.game.world.bounds.bottom) {
                    this.y = this.game.world.bounds.bottom - this.height;
                    this.velocity.y *= -this.bounce.y
                }
            }
        }, setSize: function (i, h, b, j) {
            b = b || this.offset.x;
            j = j || this.offset.y;
            this.sourceWidth = i;
            this.sourceHeight = h;
            this.width = this.sourceWidth * this._sx;
            this.height = this.sourceHeight * this._sy;
            this.halfWidth = Math.floor(this.width / 2);
            this.halfHeight = Math.floor(this.height / 2);
            this.offset.setTo(b, j);
            this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
        }, reset: function () {
            this.velocity.setTo(0, 0);
            this.acceleration.setTo(0, 0);
            this.angularVelocity = 0;
            this.angularAcceleration = 0;
            this.preX = (this.sprite.world.x - (this.sprite.anchor.x * this.width)) + this.offset.x;
            this.preY = (this.sprite.world.y - (this.sprite.anchor.y * this.height)) + this.offset.y;
            this.preRotation = this.sprite.angle;
            this.x = this.preX;
            this.y = this.preY;
            this.rotation = this.preRotation;
            this.center.setTo(this.x + this.halfWidth, this.y + this.halfHeight)
        }, deltaAbsX: function () {
            return (this.deltaX() > 0 ? this.deltaX() : -this.deltaX())
        }, deltaAbsY: function () {
            return (this.deltaY() > 0 ? this.deltaY() : -this.deltaY())
        }, deltaX: function () {
            return this.x - this.preX
        }, deltaY: function () {
            return this.y - this.preY
        }, deltaZ: function () {
            return this.rotation - this.preRotation
        }
    };
    Object.defineProperty(d.Physics.Arcade.Body.prototype, "bottom", {
        get: function () {
            return this.y + this.height
        }, set: function (b) {
            if (b <= this.y) {
                this.height = 0
            } else {
                this.height = (this.y - b)
            }
        }
    });
    Object.defineProperty(d.Physics.Arcade.Body.prototype, "right", {
        get: function () {
            return this.x + this.width
        }, set: function (b) {
            if (b <= this.x) {
                this.width = 0
            } else {
                this.width = this.x + b
            }
        }
    });
    d.Particles = function (b) {
        this.emitters = {};
        this.ID = 0
    };
    d.Particles.prototype = {
        add: function (b) {
            this.emitters[b.name] = b;
            return b
        }, remove: function (b) {
            delete this.emitters[b.name]
        }, update: function () {
            for (var b in this.emitters) {
                if (this.emitters[b].exists) {
                    this.emitters[b].update()
                }
            }
        }
    };
    d.Particles.Arcade = {};
    d.Particles.Arcade.Emitter = function (h, b, j, i) {
        this.maxParticles = i || 50;
        d.Group.call(this, h);
        this.name = "emitter" + this.game.particles.ID++;
        this.type = d.EMITTER;
        this.x = 0;
        this.y = 0;
        this.width = 1;
        this.height = 1;
        this.minParticleSpeed = new d.Point(-100, -100);
        this.maxParticleSpeed = new d.Point(100, 100);
        this.minParticleScale = 1;
        this.maxParticleScale = 1;
        this.minRotation = -360;
        this.maxRotation = 360;
        this.gravity = 2;
        this.particleClass = null;
        this.particleDrag = new d.Point();
        this.angularDrag = 0;
        this.frequency = 100;
        this.lifespan = 2000;
        this.bounce = new d.Point();
        this._quantity = 0;
        this._timer = 0;
        this._counter = 0;
        this._explode = true;
        this.on = false;
        this.exists = true;
        this.emitX = b;
        this.emitY = j
    };
    d.Particles.Arcade.Emitter.prototype = Object.create(d.Group.prototype);
    d.Particles.Arcade.Emitter.prototype.constructor = d.Particles.Arcade.Emitter;
    d.Particles.Arcade.Emitter.prototype.update = function () {
        if (this.on) {
            if (this._explode) {
                this._counter = 0;
                do {
                    this.emitParticle();
                    this._counter++
                } while (this._counter < this._quantity);
                this.on = false
            } else {
                if (this.game.time.now >= this._timer) {
                    this.emitParticle();
                    this._counter++;
                    if (this._quantity > 0) {
                        if (this._counter >= this._quantity) {
                            this.on = false
                        }
                    }
                    this._timer = this.game.time.now + this.frequency
                }
            }
        }
    };
    d.Particles.Arcade.Emitter.prototype.makeParticles = function (o, l, h, n, p) {
        if (typeof l == "undefined") {
            l = 0
        }
        h = h || this.maxParticles;
        n = n || 0;
        if (typeof p == "undefined") {
            p = false
        }
        var k;
        var j = 0;
        var b = o;
        var m = 0;
        while (j < h) {
            if (this.particleClass == null) {
                if (typeof o == "object") {
                    b = this.game.rnd.pick(o)
                }
                if (typeof l == "object") {
                    m = this.game.rnd.pick(l)
                }
                k = new d.Sprite(this.game, 0, 0, b, m)
            } else {
            }
            if (n > 0) {
                k.body.allowCollision.any = true;
                k.body.allowCollision.none = false
            } else {
                k.body.allowCollision.none = true
            }
            k.body.collideWorldBounds = p;
            k.exists = false;
            k.visible = false;
            k.anchor.setTo(0.5, 0.5);
            this.add(k);
            j++
        }
        return this
    };
    d.Particles.Arcade.Emitter.prototype.kill = function () {
        this.on = false;
        this.alive = false;
        this.exists = false
    };
    d.Particles.Arcade.Emitter.prototype.revive = function () {
        this.alive = true;
        this.exists = true
    };
    d.Particles.Arcade.Emitter.prototype.start = function (b, j, i, h) {
        if (typeof b !== "boolean") {
            b = true
        }
        j = j || 0;
        i = i || 250;
        h = h || 0;
        this.revive();
        this.visible = true;
        this.on = true;
        this._explode = b;
        this.lifespan = j;
        this.frequency = i;
        if (b) {
            this._quantity = h
        } else {
            this._quantity += h
        }
        this._counter = 0;
        this._timer = this.game.time.now + i
    };
    d.Particles.Arcade.Emitter.prototype.emitParticle = function () {
        var h = this.getFirstExists(false);
        if (h == null) {
            return
        }
        if (this.width > 1 || this.height > 1) {
            h.reset(this.game.rnd.integerInRange(this.left, this.right), this.game.rnd.integerInRange(this.top, this.bottom))
        } else {
            h.reset(this.emitX, this.emitY)
        }
        h.lifespan = this.lifespan;
        h.body.bounce.setTo(this.bounce.x, this.bounce.y);
        if (this.minParticleSpeed.x != this.maxParticleSpeed.x) {
            h.body.velocity.x = this.game.rnd.integerInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x)
        } else {
            h.body.velocity.x = this.minParticleSpeed.x
        }
        if (this.minParticleSpeed.y != this.maxParticleSpeed.y) {
            h.body.velocity.y = this.game.rnd.integerInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y)
        } else {
            h.body.velocity.y = this.minParticleSpeed.y
        }
        h.body.gravity.y = this.gravity;
        if (this.minRotation != this.maxRotation) {
            h.body.angularVelocity = this.game.rnd.integerInRange(this.minRotation, this.maxRotation)
        } else {
            h.body.angularVelocity = this.minRotation
        }
        if (this.minParticleScale !== 1 || this.maxParticleScale !== 1) {
            var b = this.game.rnd.realInRange(this.minParticleScale, this.maxParticleScale);
            h.scale.setTo(b, b)
        }
        h.body.drag.x = this.particleDrag.x;
        h.body.drag.y = this.particleDrag.y;
        h.body.angularDrag = this.angularDrag
    };
    d.Particles.Arcade.Emitter.prototype.setSize = function (h, b) {
        this.width = h;
        this.height = b
    };
    d.Particles.Arcade.Emitter.prototype.setXSpeed = function (h, b) {
        h = h || 0;
        b = b || 0;
        this.minParticleSpeed.x = h;
        this.maxParticleSpeed.x = b
    };
    d.Particles.Arcade.Emitter.prototype.setYSpeed = function (h, b) {
        h = h || 0;
        b = b || 0;
        this.minParticleSpeed.y = h;
        this.maxParticleSpeed.y = b
    };
    d.Particles.Arcade.Emitter.prototype.setRotation = function (h, b) {
        h = h || 0;
        b = b || 0;
        this.minRotation = h;
        this.maxRotation = b
    };
    d.Particles.Arcade.Emitter.prototype.at = function (b) {
        this.emitX = b.center.x;
        this.emitY = b.center.y
    };
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "alpha", {
        get: function () {
            return this._container.alpha
        }, set: function (b) {
            this._container.alpha = b
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "visible", {
        get: function () {
            return this._container.visible
        }, set: function (b) {
            this._container.visible = b
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "x", {
        get: function () {
            return this.emitX
        }, set: function (b) {
            this.emitX = b
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "y", {
        get: function () {
            return this.emitY
        }, set: function (b) {
            this.emitY = b
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "left", {
        get: function () {
            return Math.floor(this.x - (this.width / 2))
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "right", {
        get: function () {
            return Math.floor(this.x + (this.width / 2))
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "top", {
        get: function () {
            return Math.floor(this.y - (this.height / 2))
        }
    });
    Object.defineProperty(d.Particles.Arcade.Emitter.prototype, "bottom", {
        get: function () {
            return Math.floor(this.y + (this.height / 2))
        }
    });
    d.Tile = function (k, i, h, l, j, b) {
        this.tileset = k;
        this.index = i;
        this.width = j;
        this.height = b;
        this.x = h;
        this.y = l;
        this.mass = 1;
        this.collideNone = true;
        this.collideLeft = false;
        this.collideRight = false;
        this.collideUp = false;
        this.collideDown = false;
        this.separateX = true;
        this.separateY = true;
        this.collisionCallback = null;
        this.collisionCallbackContext = this
    };
    d.Tile.prototype = {
        setCollisionCallback: function (h, b) {
            this.collisionCallbackContext = b;
            this.collisionCallback = h
        }, destroy: function () {
            this.tileset = null
        }, setCollision: function (i, h, b, j) {
            this.collideLeft = i;
            this.collideRight = h;
            this.collideUp = b;
            this.collideDown = j;
            if (i || h || b || j) {
                this.collideNone = false
            } else {
                this.collideNone = true
            }
        }, resetCollision: function () {
            this.collideNone = true;
            this.collideLeft = false;
            this.collideRight = false;
            this.collideUp = false;
            this.collideDown = false
        }
    };
    Object.defineProperty(d.Tile.prototype, "bottom", {
        get: function () {
            return this.y + this.height
        }
    });
    Object.defineProperty(d.Tile.prototype, "right", {
        get: function () {
            return this.x + this.width
        }
    });
    d.Tilemap = function (b, h) {
        this.game = b;
        this.layers;
        if (typeof h === "string") {
            this.key = h;
            this.layers = b.cache.getTilemapData(h).layers;
            this.calculateIndexes()
        } else {
            this.layers = []
        }
        this.currentLayer = 0;
        this.debugMap = [];
        this.dirty = false;
        this._results = [];
        this._tempA = 0;
        this._tempB = 0
    };
    d.Tilemap.CSV = 0;
    d.Tilemap.TILED_JSON = 1;
    d.Tilemap.prototype = {
        create: function (i, j, h) {
            var k = [];
            for (var l = 0; l < h; l++) {
                k[l] = [];
                for (var b = 0; b < j; b++) {
                    k[l][b] = 0
                }
            }
            this.currentLayer = this.layers.push({
                name: i,
                width: j,
                height: h,
                alpha: 1,
                visible: true,
                tileMargin: 0,
                tileSpacing: 0,
                format: d.Tilemap.CSV,
                data: k,
                indexes: []
            });
            this.dirty = true
        }, calculateIndexes: function () {
            for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].indexes = [];
                for (var j = 0; j < this.layers[i].height; j++) {
                    for (var h = 0; h < this.layers[i].width; h++) {
                        var b = this.layers[i].data[j][h];
                        if (this.layers[i].indexes.indexOf(b) === -1) {
                            this.layers[i].indexes.push(b)
                        }
                    }
                }
            }
        }, setLayer: function (b) {
            if (this.layers[b]) {
                this.currentLayer = b
            }
        }, putTile: function (h, b, j, i) {
            if (typeof i === "undefined") {
                i = this.currentLayer
            }
            if (b >= 0 && b < this.layers[this.currentLayer].width && j >= 0 && j < this.layers[this.currentLayer].height) {
                this.layers[this.currentLayer].data[j][b] = h
            }
            this.dirty = true
        }, getTile: function (b, i, h) {
            if (typeof h === "undefined") {
                h = this.currentLayer
            }
            if (b >= 0 && b < this.layers[this.currentLayer].width && i >= 0 && i < this.layers[this.currentLayer].height) {
                return this.layers[this.currentLayer].data[i][b]
            }
        }, getTileWorldXY: function (b, k, j, h, i) {
            if (typeof i === "undefined") {
                i = this.currentLayer
            }
            b = this.game.math.snapToFloor(b, j) / j;
            k = this.game.math.snapToFloor(k, h) / h;
            if (b >= 0 && b < this.layers[this.currentLayer].width && k >= 0 && k < this.layers[this.currentLayer].height) {
                return this.layers[this.currentLayer].data[k][b]
            }
        }, putTileWorldXY: function (i, b, l, k, h, j) {
            b = this.game.math.snapToFloor(b, k) / k;
            l = this.game.math.snapToFloor(l, h) / h;
            if (b >= 0 && b < this.layers[this.currentLayer].width && l >= 0 && l < this.layers[this.currentLayer].height) {
                this.layers[this.currentLayer].data[l][b] = i
            }
            this.dirty = true
        }, copy: function (i, m, l, h, k) {
            if (typeof k === "undefined") {
                k = this.currentLayer
            }
            if (!this.layers[k]) {
                this._results.length = 0;
                return
            }
            if (typeof i === "undefined") {
                i = 0
            }
            if (typeof m === "undefined") {
                m = 0
            }
            if (typeof l === "undefined") {
                l = this.layers[k].width
            }
            if (typeof h === "undefined") {
                h = this.layers[k].height
            }
            if (i < 0) {
                i = 0
            }
            if (m < 0) {
                m = 0
            }
            if (l > this.layers[k].width) {
                l = this.layers[k].width
            }
            if (h > this.layers[k].height) {
                h = this.layers[k].height
            }
            this._results.length = 0;
            this._results.push({x: i, y: m, width: l, height: h, layer: k});
            for (var b = m; b < m + h; b++) {
                for (var j = i; j < i + l; j++) {
                    this._results.push({x: j, y: b, index: this.layers[k].data[b][j]})
                }
            }
            return this._results
        }, paste: function (b, n, m, l) {
            if (typeof b === "undefined") {
                b = 0
            }
            if (typeof n === "undefined") {
                n = 0
            }
            if (typeof l === "undefined") {
                l = this.currentLayer
            }
            if (!m || m.length < 2) {
                return
            }
            var j = m[1].x - b;
            var h = m[1].y - n;
            for (var k = 1; k < m.length; k++) {
                this.layers[l].data[h + m[k].y][j + m[k].x] = m[k].index
            }
            this.dirty = true
        }, swap: function (l, k, h, m, j, b, i) {
            this.copy(h, m, j, b, i);
            if (this._results.length < 2) {
                return
            }
            this._tempA = l;
            this._tempB = k;
            this._results.forEach(this.swapHandler, this);
            this.paste(h, m, this._results)
        }, swapHandler: function (h, b, i) {
            if (h.index === this._tempA) {
                this._results[b].index = this._tempB
            } else {
                if (h.index === this._tempB) {
                    this._results[b].index = this._tempA
                }
            }
        }, forEach: function (m, j, h, l, k, b, i) {
            this.copy(h, l, k, b, i);
            if (this._results.length < 2) {
                return
            }
            this._results.forEach(m, j);
            this.paste(h, l, this._results)
        }, replace: function (n, m, h, o, l, b, k) {
            this.copy(h, o, l, b, k);
            if (this._results.length < 2) {
                return
            }
            for (var j = 1; j < this._results.length; j++) {
                if (this._results[j].index === n) {
                    this._results[j].index = m
                }
            }
            this.paste(h, o, this._results)
        }, random: function (m, l, b, o, j) {
            if (typeof j === "undefined") {
                j = this.currentLayer
            }
            this.copy(m, l, b, o, j);
            if (this._results.length < 2) {
                return
            }
            var k = [];
            for (var p = 1; p < this._results.length; p++) {
                var n = this._results[p].index;
                if (k.indexOf(n) === -1) {
                    k.push(n)
                }
            }
            for (var h = 1; h < this._results.length; h++) {
                this._results[h].index = this.game.rnd.pick(k)
            }
            this.paste(m, l, this._results)
        }, shuffle: function (h, l, j, b, i) {
            if (typeof i === "undefined") {
                i = this.currentLayer
            }
            this.copy(h, l, j, b, i);
            if (this._results.length < 2) {
                return
            }
            var k = this._results.shift();
            d.Utils.shuffle(this._results);
            this._results.unshift(k);
            this.paste(h, l, this._results)
        }, fill: function (j, h, n, m, b, l) {
            this.copy(h, n, m, b, l);
            if (this._results.length < 2) {
                return
            }
            for (var k = 1; k < this._results.length; k++) {
                this._results[k].index = j
            }
            this.paste(h, n, this._results)
        }, removeAllLayers: function () {
            this.layers.length = 0;
            this.currentLayer = 0
        }, dump: function () {
            var h = "";
            var i = [""];
            for (var j = 0; j < this.layers[this.currentLayer].height; j++) {
                for (var b = 0; b < this.layers[this.currentLayer].width; b++) {
                    h += "%c  ";
                    if (this.layers[this.currentLayer].data[j][b] > 1) {
                        if (this.debugMap[this.layers[this.currentLayer].data[j][b]]) {
                            i.push("background: " + this.debugMap[this.layers[this.currentLayer].data[j][b]])
                        } else {
                            i.push("background: #ffffff")
                        }
                    } else {
                        i.push("background: rgb(0, 0, 0)")
                    }
                }
                h += "\n"
            }
            i[0] = h;
            console.log.apply(console, i)
        }, destroy: function () {
            this.removeAllLayers();
            this.game = null
        }
    };
    d.TilemapLayer = function (h, b, n, k, m, l, j, i) {
        this.game = h;
        this.canvas = d.Canvas.create(k, m);
        this.context = this.canvas.getContext("2d");
        this.baseTexture = new g.BaseTexture(this.canvas);
        this.texture = new g.Texture(this.baseTexture);
        this.textureFrame = new d.Frame(0, 0, 0, k, m, "tilemaplayer", h.rnd.uuid());
        d.Sprite.call(this, this.game, b, n, this.texture, this.textureFrame);
        this.type = d.TILEMAPLAYER;
        this.fixedToCamera = true;
        this.tileset = null;
        this.tileWidth = 0;
        this.tileHeight = 0;
        this.tileMargin = 0;
        this.tileSpacing = 0;
        this.widthInPixels = 0;
        this.heightInPixels = 0;
        this.renderWidth = k;
        this.renderHeight = m;
        this._ga = 1;
        this._dx = 0;
        this._dy = 0;
        this._dw = 0;
        this._dh = 0;
        this._tx = 0;
        this._ty = 0;
        this._results = [];
        this._tw = 0;
        this._th = 0;
        this._tl = 0;
        this._maxX = 0;
        this._maxY = 0;
        this._startX = 0;
        this._startY = 0;
        this.tilemap = null;
        this.layer = null;
        this.index = 0;
        this._x = 0;
        this._y = 0;
        this._prevX = 0;
        this._prevY = 0;
        this.dirty = true;
        if (l instanceof d.Tileset || typeof l === "string") {
            this.updateTileset(l)
        }
        if (j instanceof d.Tilemap) {
            this.updateMapData(j, i)
        }
    };
    d.TilemapLayer.prototype = Object.create(d.Sprite.prototype);
    d.TilemapLayer.prototype = d.Utils.extend(true, d.TilemapLayer.prototype, d.Sprite.prototype, g.Sprite.prototype);
    d.TilemapLayer.prototype.constructor = d.TilemapLayer;
    d.TilemapLayer.prototype.update = function () {
        this.scrollX = this.game.camera.x;
        this.scrollY = this.game.camera.y;
        this.render()
    };
    d.TilemapLayer.prototype.resizeWorld = function () {
        this.game.world.setBounds(0, 0, this.widthInPixels, this.heightInPixels)
    };
    d.TilemapLayer.prototype.updateTileset = function (b) {
        if (b instanceof d.Tileset) {
            this.tileset = b
        } else {
            if (typeof b === "string") {
                this.tileset = this.game.cache.getTileset("tiles")
            } else {
                return
            }
        }
        this.tileWidth = this.tileset.tileWidth;
        this.tileHeight = this.tileset.tileHeight;
        this.tileMargin = this.tileset.tileMargin;
        this.tileSpacing = this.tileset.tileSpacing;
        this.updateMax()
    };
    d.TilemapLayer.prototype.updateMapData = function (h, b) {
        if (typeof b === "undefined") {
            b = 0
        }
        if (h instanceof d.Tilemap) {
            this.tilemap = h;
            this.layer = this.tilemap.layers[b];
            this.index = b;
            this.updateMax();
            this.tilemap.dirty = true
        }
    };
    d.TilemapLayer.prototype.getTileX = function (b) {
        var h = this.tileWidth * this.scale.x;
        return this.game.math.snapToFloor(b, h) / h
    };
    d.TilemapLayer.prototype.getTileY = function (h) {
        var b = this.tileHeight * this.scale.y;
        return this.game.math.snapToFloor(h, b) / b
    };
    d.TilemapLayer.prototype.getTileXY = function (h, i, b) {
        b.x = this.getTileX(h);
        b.y = this.getTileY(i);
        return b
    };
    d.TilemapLayer.prototype.getTiles = function (r, n, b, s, j) {
        if (this.tilemap === null) {
            return
        }
        if (typeof j === "undefined") {
            j = false
        }
        if (r < 0) {
            r = 0
        }
        if (n < 0) {
            n = 0
        }
        if (b > this.widthInPixels) {
            b = this.widthInPixels
        }
        if (s > this.heightInPixels) {
            s = this.heightInPixels
        }
        var q = this.tileWidth * this.scale.x;
        var l = this.tileHeight * this.scale.y;
        this._tx = this.game.math.snapToFloor(r, q) / q;
        this._ty = this.game.math.snapToFloor(n, l) / l;
        this._tw = (this.game.math.snapToCeil(b, q) + q) / q;
        this._th = (this.game.math.snapToCeil(s, l) + l) / l;
        this._results = [];
        var o = 0;
        var i = null;
        var p = 0;
        var m = 0;
        for (var h = this._ty; h < this._ty + this._th; h++) {
            for (var k = this._tx; k < this._tx + this._tw; k++) {
                if (this.layer.data[h] && this.layer.data[h][k]) {
                    o = this.layer.data[h][k] - 1;
                    i = this.tileset.getTile(o);
                    p = i.width * this.scale.x;
                    m = i.height * this.scale.y;
                    if (j == false || (j && i.collideNone == false)) {
                        this._results.push({
                            x: k * p,
                            right: (k * p) + p,
                            y: h * m,
                            bottom: (h * m) + m,
                            width: p,
                            height: m,
                            tx: k,
                            ty: h,
                            tile: i
                        })
                    }
                }
            }
        }
        return this._results
    };
    d.TilemapLayer.prototype.updateMax = function () {
        this._maxX = this.game.math.ceil(this.canvas.width / this.tileWidth) + 1;
        this._maxY = this.game.math.ceil(this.canvas.height / this.tileHeight) + 1;
        if (this.layer) {
            if (this._maxX > this.layer.width) {
                this._maxX = this.layer.width
            }
            if (this._maxY > this.layer.height) {
                this._maxY = this.layer.height
            }
            this.widthInPixels = this.layer.width * this.tileWidth;
            this.heightInPixels = this.layer.height * this.tileHeight
        }
        this.dirty = true
    };
    d.TilemapLayer.prototype.render = function () {
        if (this.tilemap && this.tilemap.dirty) {
            this.dirty = true
        }
        if (!this.dirty || !this.tileset || !this.tilemap || !this.visible) {
            return
        }
        this._prevX = this._dx;
        this._prevY = this._dy;
        this._dx = -(this._x - (this._startX * this.tileWidth));
        this._dy = -(this._y - (this._startY * this.tileHeight));
        this._tx = this._dx;
        this._ty = this._dy;
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (var i = this._startY; i < this._startY + this._maxY; i++) {
            this._column = this.layer.data[i];
            for (var b = this._startX; b < this._startX + this._maxX; b++) {
                var h = this.tileset.tiles[this._column[b] - 1];
                if (h) {
                    this.context.drawImage(this.tileset.image, h.x, h.y, this.tileWidth, this.tileHeight, Math.floor(this._tx), Math.floor(this._ty), this.tileWidth, this.tileHeight)
                }
                this._tx += this.tileWidth
            }
            this._tx = this._dx;
            this._ty += this.tileHeight
        }
        if (this.game.renderType == d.WEBGL) {
            g.texturesToUpdate.push(this.baseTexture)
        }
        this.dirty = false;
        if (this.tilemap.dirty) {
            this.tilemap.dirty = false
        }
        return true
    };
    d.TilemapLayer.prototype.deltaAbsX = function () {
        return (this.deltaX() > 0 ? this.deltaX() : -this.deltaX())
    };
    d.TilemapLayer.prototype.deltaAbsY = function () {
        return (this.deltaY() > 0 ? this.deltaY() : -this.deltaY())
    };
    d.TilemapLayer.prototype.deltaX = function () {
        return this._dx - this._prevX
    };
    d.TilemapLayer.prototype.deltaY = function () {
        return this._dy - this._prevY
    };
    Object.defineProperty(d.TilemapLayer.prototype, "scrollX", {
        get: function () {
            return this._x
        }, set: function (b) {
            if (b !== this._x && b >= 0 && this.layer) {
                this._x = b;
                if (this._x > (this.widthInPixels - this.renderWidth)) {
                    this._x = this.widthInPixels - this.renderWidth
                }
                this._startX = this.game.math.floor(this._x / this.tileWidth);
                if (this._startX < 0) {
                    this._startX = 0
                }
                if (this._startX + this._maxX > this.layer.width) {
                    this._startX = this.layer.width - this._maxX
                }
                this.dirty = true
            }
        }
    });
    Object.defineProperty(d.TilemapLayer.prototype, "scrollY", {
        get: function () {
            return this._y
        }, set: function (b) {
            if (b !== this._y && b >= 0 && this.layer) {
                this._y = b;
                if (this._y > (this.heightInPixels - this.renderHeight)) {
                    this._y = this.heightInPixels - this.renderHeight
                }
                this._startY = this.game.math.floor(this._y / this.tileHeight);
                if (this._startY < 0) {
                    this._startY = 0
                }
                if (this._startY + this._maxY > this.layer.height) {
                    this._startY = this.layer.height - this._maxY
                }
                this.dirty = true
            }
        }
    });
    d.TilemapParser = {
        tileset: function (v, t, s, n, h, z, o) {
            var m = v.cache.getTilesetImage(t);
            if (m == null) {
                return null
            }
            var b = m.width;
            var u = m.height;
            if (s <= 0) {
                s = Math.floor(-b / Math.min(-1, s))
            }
            if (n <= 0) {
                n = Math.floor(-u / Math.min(-1, n))
            }
            var w = Math.round(b / s);
            var k = Math.round(u / n);
            var q = w * k;
            if (h !== -1) {
                q = h
            }
            if (b == 0 || u == 0 || b < s || u < n || q === 0) {
                console.warn("Phaser.TilemapParser.tileSet: width/height zero or width/height < given tileWidth/tileHeight");
                return null
            }
            var r = z;
            var p = z;
            var j = new d.Tileset(m, t, s, n, z, o);
            for (var l = 0; l < q; l++) {
                j.addTile(new d.Tile(j, l, r, p, s, n));
                r += s + o;
                if (r === b) {
                    r = z;
                    p += n + o
                }
            }
            return j
        }, parse: function (b, h, i) {
            if (i === d.Tilemap.CSV) {
                return this.parseCSV(h)
            } else {
                if (i === d.Tilemap.TILED_JSON) {
                    return this.parseTiledJSON(h)
                }
            }
        }, parseCSV: function (n) {
            n = n.trim();
            var h = [];
            var m = n.split("\n");
            var b = m.length;
            var l = 0;
            for (var j = 0; j < m.length; j++) {
                h[j] = [];
                var k = m[j].split(",");
                for (var o = 0; o < k.length; o++) {
                    h[j][o] = parseInt(k[o])
                }
                if (l == 0) {
                    l = k.length
                }
            }
            return [{
                name: "csv",
                width: l,
                height: b,
                alpha: 1,
                visible: true,
                indexes: [],
                tileMargin: 0,
                tileSpacing: 0,
                data: h
            }]
        }, parseTiledJSON: function (l) {
            var m = [];
            for (var k = 0; k < l.layers.length; k++) {
                if (!l.layers[k].data) {
                    continue
                }
                var j = {
                    name: l.layers[k].name,
                    width: l.layers[k].width,
                    height: l.layers[k].height,
                    alpha: l.layers[k].opacity,
                    visible: l.layers[k].visible,
                    indexes: [],
                    tileMargin: l.tilesets[0].margin,
                    tileSpacing: l.tilesets[0].spacing
                };
                var b = [];
                var o = 0;
                var n;
                for (var h = 0; h < l.layers[k].data.length; h++) {
                    if (o == 0) {
                        n = []
                    }
                    n.push(l.layers[k].data[h]);
                    o++;
                    if (o == l.layers[k].width) {
                        b.push(n);
                        o = 0
                    }
                }
                j.data = b;
                m.push(j)
            }
            return m
        }
    };
    d.Tileset = function (j, i, l, b, k, h) {
        if (typeof k === "undefined") {
            k = 0
        }
        if (typeof h === "undefined") {
            h = 0
        }
        this.key = i;
        this.image = j;
        this.tileWidth = l;
        this.tileHeight = b;
        this.margin = k;
        this.spacing = h;
        this.tiles = []
    };
    d.Tileset.prototype = {
        addTile: function (b) {
            this.tiles.push(b);
            return b
        }, getTile: function (b) {
            if (this.tiles[b]) {
                return this.tiles[b]
            }
            return null
        }, setSpacing: function (b, h) {
            this.tileMargin = b;
            this.tileSpacing = h
        }, canCollide: function (b) {
            if (this.tiles[b]) {
                return this.tiles[b].collideNone
            }
            return null
        }, checkTileIndex: function (b) {
            return (this.tiles[b])
        }, setCollisionRange: function (n, k, l, j, b, m) {
            if (this.tiles[n] && this.tiles[k] && n < k) {
                for (var h = n; h <= k; h++) {
                    this.tiles[h].setCollision(l, j, b, m)
                }
            }
        }, setCollision: function (h, j, i, b, k) {
            if (this.tiles[h]) {
                this.tiles[h].setCollision(j, i, b, k)
            }
        }
    };
    Object.defineProperty(d.Tileset.prototype, "total", {
        get: function () {
            return this.tiles.length
        }
    });
    g.CanvasRenderer.prototype.renderDisplayObject = function (m) {
        var j;
        var k = this.context;
        k.globalCompositeOperation = "source-over";
        var i = m.last._iNext;
        m = m.first;
        do {
            j = m.worldTransform;
            if (!m.visible) {
                m = m.last._iNext;
                continue
            }
            if (!m.renderable || m.alpha == 0) {
                m = m._iNext;
                continue
            }
            if (m instanceof g.Sprite) {
                var l = m.texture.frame;
                if (l) {
                    k.globalAlpha = m.worldAlpha;
                    if (m.texture.trimmed) {
                        k.setTransform(j[0], j[3], j[1], j[4], j[2] + m.texture.trim.x, j[5] + m.texture.trim.y)
                    } else {
                        k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5])
                    }
                    k.drawImage(m.texture.baseTexture.source, l.x, l.y, l.width, l.height, (m.anchor.x) * -l.width, (m.anchor.y) * -l.height, l.width, l.height)
                }
            } else {
                if (m instanceof g.Strip) {
                    k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                    this.renderStrip(m)
                } else {
                    if (m instanceof g.TilingSprite) {
                        k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                        this.renderTilingSprite(m)
                    } else {
                        if (m instanceof g.CustomRenderable) {
                            m.renderCanvas(this)
                        } else {
                            if (m instanceof g.Graphics) {
                                k.setTransform(j[0], j[3], j[1], j[4], j[2], j[5]);
                                g.CanvasGraphics.renderGraphics(m, k)
                            } else {
                                if (m instanceof g.FilterBlock) {
                                    if (m.open) {
                                        k.save();
                                        var h = m.mask.alpha;
                                        var b = m.mask.worldTransform;
                                        k.setTransform(b[0], b[3], b[1], b[4], b[2], b[5]);
                                        m.mask.worldAlpha = 0.5;
                                        k.worldAlpha = 0;
                                        g.CanvasGraphics.renderGraphicsMask(m.mask, k);
                                        k.clip();
                                        m.mask.worldAlpha = h
                                    } else {
                                        k.restore()
                                    }
                                }
                            }
                        }
                    }
                }
            }
            m = m._iNext
        } while (m != i)
    };
    g.WebGLBatch.prototype.update = function () {
        var B = this.gl;
        var A, z, w, i, h, r, q, p, o, n, m, k;
        var H, F, D, C, G, E;
        var u = 0;
        var v = this.head;
        while (v) {
            if (v.vcount === g.visibleCount) {
                z = v.texture.frame.width;
                w = v.texture.frame.height;
                i = v.anchor.x;
                h = v.anchor.y;
                r = z * (1 - i);
                q = z * -i;
                p = w * (1 - h);
                o = w * -h;
                n = u * 8;
                A = v.worldTransform;
                H = A[0];
                F = A[3];
                D = A[1];
                C = A[4];
                G = A[2];
                E = A[5];
                if (v.texture.trimmed) {
                    G += v.texture.trim.x;
                    E += v.texture.trim.y
                }
                this.verticies[n + 0] = H * q + D * o + G;
                this.verticies[n + 1] = C * o + F * q + E;
                this.verticies[n + 2] = H * r + D * o + G;
                this.verticies[n + 3] = C * o + F * r + E;
                this.verticies[n + 4] = H * r + D * p + G;
                this.verticies[n + 5] = C * p + F * r + E;
                this.verticies[n + 6] = H * q + D * p + G;
                this.verticies[n + 7] = C * p + F * q + E;
                if (v.updateFrame || v.texture.updateFrame) {
                    this.dirtyUVS = true;
                    var t = v.texture;
                    var s = t.frame;
                    var I = t.baseTexture.width;
                    var l = t.baseTexture.height;
                    this.uvs[n + 0] = s.x / I;
                    this.uvs[n + 1] = s.y / l;
                    this.uvs[n + 2] = (s.x + s.width) / I;
                    this.uvs[n + 3] = s.y / l;
                    this.uvs[n + 4] = (s.x + s.width) / I;
                    this.uvs[n + 5] = (s.y + s.height) / l;
                    this.uvs[n + 6] = s.x / I;
                    this.uvs[n + 7] = (s.y + s.height) / l;
                    v.updateFrame = false
                }
                if (v.cacheAlpha != v.worldAlpha) {
                    v.cacheAlpha = v.worldAlpha;
                    var j = u * 4;
                    this.colors[j] = this.colors[j + 1] = this.colors[j + 2] = this.colors[j + 3] = v.worldAlpha;
                    this.dirtyColors = true
                }
            } else {
                n = u * 8;
                this.verticies[n + 0] = 0;
                this.verticies[n + 1] = 0;
                this.verticies[n + 2] = 0;
                this.verticies[n + 3] = 0;
                this.verticies[n + 4] = 0;
                this.verticies[n + 5] = 0;
                this.verticies[n + 6] = 0;
                this.verticies[n + 7] = 0
            }
            u++;
            v = v.__next
        }
    };
    return d
}));